/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Magento Commerce for B2B
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://pwa-pos.ezerway.com/index.php/rest/default".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Interface LinkInterface Represents link with collected data and initialized vector for decryption.
 * @export
 * @interface AnalyticsDataLinkInterface
 */
export interface AnalyticsDataLinkInterface {
    /**
     *
     * @type {string}
     * @memberof AnalyticsDataLinkInterface
     */
    url: string;
    /**
     *
     * @type {string}
     * @memberof AnalyticsDataLinkInterface
     */
    initializationVector: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Bundle\\Api\\Data\\BundleOptionInterface
 * @export
 * @interface BundleDataBundleOptionExtensionInterface
 */
export interface BundleDataBundleOptionExtensionInterface {
}

/**
 * Interface BundleOptionInterface
 * @export
 * @interface BundleDataBundleOptionInterface
 */
export interface BundleDataBundleOptionInterface {
    /**
     * Bundle option id.
     * @type {number}
     * @memberof BundleDataBundleOptionInterface
     */
    optionId: number;
    /**
     * Bundle option quantity.
     * @type {number}
     * @memberof BundleDataBundleOptionInterface
     */
    optionQty: number;
    /**
     * Bundle option selection ids.
     * @type {Array<number>}
     * @memberof BundleDataBundleOptionInterface
     */
    optionSelections: Array<number>;
    /**
     *
     * @type {BundleDataBundleOptionExtensionInterface}
     * @memberof BundleDataBundleOptionInterface
     */
    extensionAttributes?: BundleDataBundleOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Bundle\\Api\\Data\\LinkInterface
 * @export
 * @interface BundleDataLinkExtensionInterface
 */
export interface BundleDataLinkExtensionInterface {
}

/**
 * Interface LinkInterface
 * @export
 * @interface BundleDataLinkInterface
 */
export interface BundleDataLinkInterface {
    /**
     * The identifier
     * @type {string}
     * @memberof BundleDataLinkInterface
     */
    id?: string;
    /**
     * Linked product sku
     * @type {string}
     * @memberof BundleDataLinkInterface
     */
    sku?: string;
    /**
     * Option id
     * @type {number}
     * @memberof BundleDataLinkInterface
     */
    optionId?: number;
    /**
     * Qty
     * @type {number}
     * @memberof BundleDataLinkInterface
     */
    qty?: number;
    /**
     * Position
     * @type {number}
     * @memberof BundleDataLinkInterface
     */
    position?: number;
    /**
     * Is default
     * @type {boolean}
     * @memberof BundleDataLinkInterface
     */
    isDefault: boolean;
    /**
     * Price
     * @type {number}
     * @memberof BundleDataLinkInterface
     */
    price: number;
    /**
     * Price type
     * @type {number}
     * @memberof BundleDataLinkInterface
     */
    priceType: number;
    /**
     * Whether quantity could be changed
     * @type {number}
     * @memberof BundleDataLinkInterface
     */
    canChangeQuantity?: number;
    /**
     *
     * @type {BundleDataLinkExtensionInterface}
     * @memberof BundleDataLinkInterface
     */
    extensionAttributes?: BundleDataLinkExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Bundle\\Api\\Data\\OptionInterface
 * @export
 * @interface BundleDataOptionExtensionInterface
 */
export interface BundleDataOptionExtensionInterface {
}

/**
 * Interface OptionInterface
 * @export
 * @interface BundleDataOptionInterface
 */
export interface BundleDataOptionInterface {
    /**
     * Option id
     * @type {number}
     * @memberof BundleDataOptionInterface
     */
    optionId?: number;
    /**
     * Option title
     * @type {string}
     * @memberof BundleDataOptionInterface
     */
    title?: string;
    /**
     * Is required option
     * @type {boolean}
     * @memberof BundleDataOptionInterface
     */
    required?: boolean;
    /**
     * Input type
     * @type {string}
     * @memberof BundleDataOptionInterface
     */
    type?: string;
    /**
     * Option position
     * @type {number}
     * @memberof BundleDataOptionInterface
     */
    position?: number;
    /**
     * Product sku
     * @type {string}
     * @memberof BundleDataOptionInterface
     */
    sku?: string;
    /**
     * Product links
     * @type {Array<BundleDataLinkInterface>}
     * @memberof BundleDataOptionInterface
     */
    productLinks?: Array<BundleDataLinkInterface>;
    /**
     *
     * @type {BundleDataOptionExtensionInterface}
     * @memberof BundleDataOptionInterface
     */
    extensionAttributes?: BundleDataOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Bundle\\Api\\Data\\OptionTypeInterface
 * @export
 * @interface BundleDataOptionTypeExtensionInterface
 */
export interface BundleDataOptionTypeExtensionInterface {
}

/**
 * Interface OptionTypeInterface
 * @export
 * @interface BundleDataOptionTypeInterface
 */
export interface BundleDataOptionTypeInterface {
    /**
     * Type label
     * @type {string}
     * @memberof BundleDataOptionTypeInterface
     */
    label: string;
    /**
     * Type code
     * @type {string}
     * @memberof BundleDataOptionTypeInterface
     */
    code: string;
    /**
     *
     * @type {BundleDataOptionTypeExtensionInterface}
     * @memberof BundleDataOptionTypeInterface
     */
    extensionAttributes?: BundleDataOptionTypeExtensionInterface;
}

/**
 *
 * @export
 * @interface BundleProductLinkManagementV1AddChildByProductSkuPostBody
 */
export interface BundleProductLinkManagementV1AddChildByProductSkuPostBody {
    /**
     *
     * @type {BundleDataLinkInterface}
     * @memberof BundleProductLinkManagementV1AddChildByProductSkuPostBody
     */
    linkedProduct: BundleDataLinkInterface;
}

/**
 *
 * @export
 * @interface BundleProductLinkManagementV1SaveChildPutBody
 */
export interface BundleProductLinkManagementV1SaveChildPutBody {
    /**
     *
     * @type {BundleDataLinkInterface}
     * @memberof BundleProductLinkManagementV1SaveChildPutBody
     */
    linkedProduct: BundleDataLinkInterface;
}

/**
 *
 * @export
 * @interface BundleProductOptionManagementV1SavePostBody
 */
export interface BundleProductOptionManagementV1SavePostBody {
    /**
     *
     * @type {BundleDataOptionInterface}
     * @memberof BundleProductOptionManagementV1SavePostBody
     */
    option: BundleDataOptionInterface;
}

/**
 *
 * @export
 * @interface BundleProductOptionManagementV1SavePutBody
 */
export interface BundleProductOptionManagementV1SavePutBody {
    /**
     *
     * @type {BundleDataOptionInterface}
     * @memberof BundleProductOptionManagementV1SavePutBody
     */
    option: BundleDataOptionInterface;
}

/**
 *
 * @export
 * @interface CatalogAttributeSetManagementV1CreatePostBody
 */
export interface CatalogAttributeSetManagementV1CreatePostBody {
    /**
     *
     * @type {EavDataAttributeSetInterface}
     * @memberof CatalogAttributeSetManagementV1CreatePostBody
     */
    attributeSet: EavDataAttributeSetInterface;
    /**
     *
     * @type {number}
     * @memberof CatalogAttributeSetManagementV1CreatePostBody
     */
    skeletonId: number;
}

/**
 *
 * @export
 * @interface CatalogAttributeSetRepositoryV1SavePutBody
 */
export interface CatalogAttributeSetRepositoryV1SavePutBody {
    /**
     *
     * @type {EavDataAttributeSetInterface}
     * @memberof CatalogAttributeSetRepositoryV1SavePutBody
     */
    attributeSet: EavDataAttributeSetInterface;
}

/**
 *
 * @export
 * @interface CatalogBasePriceStorageV1GetPostBody
 */
export interface CatalogBasePriceStorageV1GetPostBody {
    /**
     *
     * @type {Array<string>}
     * @memberof CatalogBasePriceStorageV1GetPostBody
     */
    skus: Array<string>;
}

/**
 *
 * @export
 * @interface CatalogBasePriceStorageV1UpdatePostBody
 */
export interface CatalogBasePriceStorageV1UpdatePostBody {
    /**
     *
     * @type {Array<CatalogDataBasePriceInterface>}
     * @memberof CatalogBasePriceStorageV1UpdatePostBody
     */
    prices: Array<CatalogDataBasePriceInterface>;
}

/**
 *
 * @export
 * @interface CatalogCategoryLinkRepositoryV1SavePostBody
 */
export interface CatalogCategoryLinkRepositoryV1SavePostBody {
    /**
     *
     * @type {CatalogDataCategoryProductLinkInterface}
     * @memberof CatalogCategoryLinkRepositoryV1SavePostBody
     */
    productLink: CatalogDataCategoryProductLinkInterface;
}

/**
 *
 * @export
 * @interface CatalogCategoryLinkRepositoryV1SavePutBody
 */
export interface CatalogCategoryLinkRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataCategoryProductLinkInterface}
     * @memberof CatalogCategoryLinkRepositoryV1SavePutBody
     */
    productLink: CatalogDataCategoryProductLinkInterface;
}

/**
 *
 * @export
 * @interface CatalogCategoryManagementV1MovePutBody
 */
export interface CatalogCategoryManagementV1MovePutBody {
    /**
     *
     * @type {number}
     * @memberof CatalogCategoryManagementV1MovePutBody
     */
    parentId: number;
    /**
     *
     * @type {number}
     * @memberof CatalogCategoryManagementV1MovePutBody
     */
    afterId?: number;
}

/**
 *
 * @export
 * @interface CatalogCategoryRepositoryV1SavePostBody
 */
export interface CatalogCategoryRepositoryV1SavePostBody {
    /**
     *
     * @type {CatalogDataCategoryInterface}
     * @memberof CatalogCategoryRepositoryV1SavePostBody
     */
    category: CatalogDataCategoryInterface;
}

/**
 *
 * @export
 * @interface CatalogCategoryRepositoryV1SavePutBody
 */
export interface CatalogCategoryRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataCategoryInterface}
     * @memberof CatalogCategoryRepositoryV1SavePutBody
     */
    category: CatalogDataCategoryInterface;
}

/**
 *
 * @export
 * @interface CatalogCostStorageV1DeletePostBody
 */
export interface CatalogCostStorageV1DeletePostBody {
    /**
     *
     * @type {Array<string>}
     * @memberof CatalogCostStorageV1DeletePostBody
     */
    skus: Array<string>;
}

/**
 *
 * @export
 * @interface CatalogCostStorageV1GetPostBody
 */
export interface CatalogCostStorageV1GetPostBody {
    /**
     *
     * @type {Array<string>}
     * @memberof CatalogCostStorageV1GetPostBody
     */
    skus: Array<string>;
}

/**
 *
 * @export
 * @interface CatalogCostStorageV1UpdatePostBody
 */
export interface CatalogCostStorageV1UpdatePostBody {
    /**
     *
     * @type {Array<CatalogDataCostInterface>}
     * @memberof CatalogCostStorageV1UpdatePostBody
     */
    prices: Array<CatalogDataCostInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\BasePriceInterface
 * @export
 * @interface CatalogDataBasePriceExtensionInterface
 */
export interface CatalogDataBasePriceExtensionInterface {
}

/**
 * Price interface.
 * @export
 * @interface CatalogDataBasePriceInterface
 */
export interface CatalogDataBasePriceInterface {
    /**
     * Price.
     * @type {number}
     * @memberof CatalogDataBasePriceInterface
     */
    price: number;
    /**
     * Store id.
     * @type {number}
     * @memberof CatalogDataBasePriceInterface
     */
    storeId: number;
    /**
     * SKU.
     * @type {string}
     * @memberof CatalogDataBasePriceInterface
     */
    sku: string;
    /**
     *
     * @type {CatalogDataBasePriceExtensionInterface}
     * @memberof CatalogDataBasePriceInterface
     */
    extensionAttributes?: CatalogDataBasePriceExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogDataCategoryAttributeInterface
 */
export interface CatalogDataCategoryAttributeInterface {
    /**
     * WYSIWYG flag
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isWysiwygEnabled?: boolean;
    /**
     * The HTML tags are allowed on the frontend
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isHtmlAllowedOnFront?: boolean;
    /**
     * It is used for sorting in product listing
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    usedForSortBy?: boolean;
    /**
     * It used in layered navigation
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isFilterable?: boolean;
    /**
     * It is used in search results layered navigation
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isFilterableInSearch?: boolean;
    /**
     * It is used in catalog product grid
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isUsedInGrid?: boolean;
    /**
     * It is visible in catalog product grid
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isVisibleInGrid?: boolean;
    /**
     * It is filterable in catalog product grid
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isFilterableInGrid?: boolean;
    /**
     * Position
     * @type {number}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    position?: number;
    /**
     * Apply to value for the element
     * @type {Array<string>}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    applyTo?: Array<string>;
    /**
     * The attribute can be used in Quick Search
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isSearchable?: string;
    /**
     * The attribute can be used in Advanced Search
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isVisibleInAdvancedSearch?: string;
    /**
     * The attribute can be compared on the frontend
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isComparable?: string;
    /**
     * The attribute can be used for promo rules
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isUsedForPromoRules?: string;
    /**
     * The attribute is visible on the frontend
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isVisibleOnFront?: string;
    /**
     * The attribute can be used in product listing
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    usedInProductListing?: string;
    /**
     * Attribute is visible on frontend.
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isVisible?: boolean;
    /**
     * Attribute scope
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    scope?: string;
    /**
     *
     * @type {CatalogDataEavAttributeExtensionInterface}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    extensionAttributes?: CatalogDataEavAttributeExtensionInterface;
    /**
     * Id of the attribute.
     * @type {number}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    attributeId?: number;
    /**
     * Code of the attribute.
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    attributeCode: string;
    /**
     * HTML for input element.
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    frontendInput: string;
    /**
     * Entity type id
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    entityTypeId: string;
    /**
     * Attribute is required.
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isRequired: boolean;
    /**
     * Options of the attribute (key => value pairs for select)
     * @type {Array<EavDataAttributeOptionInterface>}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    options?: Array<EavDataAttributeOptionInterface>;
    /**
     * Current attribute has been defined by a user.
     * @type {boolean}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isUserDefined?: boolean;
    /**
     * Frontend label for default store
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    defaultFrontendLabel?: string;
    /**
     * Frontend label for each store
     * @type {Array<EavDataAttributeFrontendLabelInterface>}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    frontendLabels: Array<EavDataAttributeFrontendLabelInterface>;
    /**
     * The note attribute for the element.
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    note?: string;
    /**
     * Backend type.
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    backendType?: string;
    /**
     * Backend model
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    backendModel?: string;
    /**
     * Source model
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    sourceModel?: string;
    /**
     * Default value for the element.
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    defaultValue?: string;
    /**
     * This is a unique attribute
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    isUnique?: string;
    /**
     * Frontend class of attribute
     * @type {string}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    frontendClass?: string;
    /**
     * Validation rules.
     * @type {Array<EavDataAttributeValidationRuleInterface>}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    validationRules?: Array<EavDataAttributeValidationRuleInterface>;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CatalogDataCategoryAttributeInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 *
 * @export
 * @interface CatalogDataCategoryAttributeSearchResultsInterface
 */
export interface CatalogDataCategoryAttributeSearchResultsInterface {
    /**
     * Attributes list.
     * @type {Array<CatalogDataCategoryAttributeInterface>}
     * @memberof CatalogDataCategoryAttributeSearchResultsInterface
     */
    items: Array<CatalogDataCategoryAttributeInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CatalogDataCategoryAttributeSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CatalogDataCategoryAttributeSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\CategoryInterface
 * @export
 * @interface CatalogDataCategoryExtensionInterface
 */
export interface CatalogDataCategoryExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataCategoryInterface
 */
export interface CatalogDataCategoryInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogDataCategoryInterface
     */
    id?: number;
    /**
     * Parent category ID
     * @type {number}
     * @memberof CatalogDataCategoryInterface
     */
    parentId?: number;
    /**
     * Category name
     * @type {string}
     * @memberof CatalogDataCategoryInterface
     */
    name: string;
    /**
     * Whether category is active
     * @type {boolean}
     * @memberof CatalogDataCategoryInterface
     */
    isActive?: boolean;
    /**
     * Category position
     * @type {number}
     * @memberof CatalogDataCategoryInterface
     */
    position?: number;
    /**
     * Category level
     * @type {number}
     * @memberof CatalogDataCategoryInterface
     */
    level?: number;
    /**
     *
     * @type {string}
     * @memberof CatalogDataCategoryInterface
     */
    children?: string;
    /**
     *
     * @type {string}
     * @memberof CatalogDataCategoryInterface
     */
    createdAt?: string;
    /**
     *
     * @type {string}
     * @memberof CatalogDataCategoryInterface
     */
    updatedAt?: string;
    /**
     *
     * @type {string}
     * @memberof CatalogDataCategoryInterface
     */
    path?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CatalogDataCategoryInterface
     */
    availableSortBy?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof CatalogDataCategoryInterface
     */
    includeInMenu?: boolean;
    /**
     *
     * @type {CatalogDataCategoryExtensionInterface}
     * @memberof CatalogDataCategoryInterface
     */
    extensionAttributes?: CatalogDataCategoryExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CatalogDataCategoryInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\CategoryLinkInterface
 * @export
 * @interface CatalogDataCategoryLinkExtensionInterface
 */
export interface CatalogDataCategoryLinkExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataCategoryLinkInterface
 */
export interface CatalogDataCategoryLinkInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogDataCategoryLinkInterface
     */
    position?: number;
    /**
     * Category id
     * @type {string}
     * @memberof CatalogDataCategoryLinkInterface
     */
    categoryId: string;
    /**
     *
     * @type {CatalogDataCategoryLinkExtensionInterface}
     * @memberof CatalogDataCategoryLinkInterface
     */
    extensionAttributes?: CatalogDataCategoryLinkExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\CategoryProductLinkInterface
 * @export
 * @interface CatalogDataCategoryProductLinkExtensionInterface
 */
export interface CatalogDataCategoryProductLinkExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataCategoryProductLinkInterface
 */
export interface CatalogDataCategoryProductLinkInterface {
    /**
     *
     * @type {string}
     * @memberof CatalogDataCategoryProductLinkInterface
     */
    sku?: string;
    /**
     *
     * @type {number}
     * @memberof CatalogDataCategoryProductLinkInterface
     */
    position?: number;
    /**
     * Category id
     * @type {string}
     * @memberof CatalogDataCategoryProductLinkInterface
     */
    categoryId: string;
    /**
     *
     * @type {CatalogDataCategoryProductLinkExtensionInterface}
     * @memberof CatalogDataCategoryProductLinkInterface
     */
    extensionAttributes?: CatalogDataCategoryProductLinkExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogDataCategorySearchResultsInterface
 */
export interface CatalogDataCategorySearchResultsInterface {
    /**
     * Categories
     * @type {Array<CatalogDataCategoryInterface>}
     * @memberof CatalogDataCategorySearchResultsInterface
     */
    items: Array<CatalogDataCategoryInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CatalogDataCategorySearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CatalogDataCategorySearchResultsInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface CatalogDataCategoryTreeInterface
 */
export interface CatalogDataCategoryTreeInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogDataCategoryTreeInterface
     */
    id?: number;
    /**
     * Parent category ID
     * @type {number}
     * @memberof CatalogDataCategoryTreeInterface
     */
    parentId: number;
    /**
     * Category name
     * @type {string}
     * @memberof CatalogDataCategoryTreeInterface
     */
    name: string;
    /**
     * Whether category is active
     * @type {boolean}
     * @memberof CatalogDataCategoryTreeInterface
     */
    isActive: boolean;
    /**
     * Category position
     * @type {number}
     * @memberof CatalogDataCategoryTreeInterface
     */
    position: number;
    /**
     * Category level
     * @type {number}
     * @memberof CatalogDataCategoryTreeInterface
     */
    level: number;
    /**
     * Product count
     * @type {number}
     * @memberof CatalogDataCategoryTreeInterface
     */
    productCount: number;
    /**
     *
     * @type {Array<CatalogDataCategoryTreeInterface>}
     * @memberof CatalogDataCategoryTreeInterface
     */
    childrenData: Array<CatalogDataCategoryTreeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\CostInterface
 * @export
 * @interface CatalogDataCostExtensionInterface
 */
export interface CatalogDataCostExtensionInterface {
}

/**
 * Cost interface.
 * @export
 * @interface CatalogDataCostInterface
 */
export interface CatalogDataCostInterface {
    /**
     * Cost value.
     * @type {number}
     * @memberof CatalogDataCostInterface
     */
    cost: number;
    /**
     * Store id.
     * @type {number}
     * @memberof CatalogDataCostInterface
     */
    storeId: number;
    /**
     * SKU.
     * @type {string}
     * @memberof CatalogDataCostInterface
     */
    sku: string;
    /**
     *
     * @type {CatalogDataCostExtensionInterface}
     * @memberof CatalogDataCostInterface
     */
    extensionAttributes?: CatalogDataCostExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\CustomOptionInterface
 * @export
 * @interface CatalogDataCustomOptionExtensionInterface
 */
export interface CatalogDataCustomOptionExtensionInterface {
    /**
     *
     * @type {FrameworkDataImageContentInterface}
     * @memberof CatalogDataCustomOptionExtensionInterface
     */
    fileInfo?: FrameworkDataImageContentInterface;
}

/**
 * Interface CustomOptionInterface
 * @export
 * @interface CatalogDataCustomOptionInterface
 */
export interface CatalogDataCustomOptionInterface {
    /**
     * Option id
     * @type {string}
     * @memberof CatalogDataCustomOptionInterface
     */
    optionId: string;
    /**
     * Option value
     * @type {string}
     * @memberof CatalogDataCustomOptionInterface
     */
    optionValue: string;
    /**
     *
     * @type {CatalogDataCustomOptionExtensionInterface}
     * @memberof CatalogDataCustomOptionInterface
     */
    extensionAttributes?: CatalogDataCustomOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\EavAttributeInterface
 * @export
 * @interface CatalogDataEavAttributeExtensionInterface
 */
export interface CatalogDataEavAttributeExtensionInterface {
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface
 * @export
 * @interface CatalogDataPriceUpdateResultExtensionInterface
 */
export interface CatalogDataPriceUpdateResultExtensionInterface {
}

/**
 * Interface returned in case of incorrect price passed to efficient price API.
 * @export
 * @interface CatalogDataPriceUpdateResultInterface
 */
export interface CatalogDataPriceUpdateResultInterface {
    /**
     * Error message, that contains description of error occurred during price update.
     * @type {string}
     * @memberof CatalogDataPriceUpdateResultInterface
     */
    message: string;
    /**
     * Parameters, that could be displayed in error message placeholders.
     * @type {Array<string>}
     * @memberof CatalogDataPriceUpdateResultInterface
     */
    parameters: Array<string>;
    /**
     *
     * @type {CatalogDataPriceUpdateResultExtensionInterface}
     * @memberof CatalogDataPriceUpdateResultInterface
     */
    extensionAttributes?: CatalogDataPriceUpdateResultExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogDataProductAttributeInterface
 */
export interface CatalogDataProductAttributeInterface {
    /**
     * WYSIWYG flag
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isWysiwygEnabled?: boolean;
    /**
     * The HTML tags are allowed on the frontend
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isHtmlAllowedOnFront?: boolean;
    /**
     * It is used for sorting in product listing
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    usedForSortBy?: boolean;
    /**
     * It used in layered navigation
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isFilterable?: boolean;
    /**
     * It is used in search results layered navigation
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isFilterableInSearch?: boolean;
    /**
     * It is used in catalog product grid
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isUsedInGrid?: boolean;
    /**
     * It is visible in catalog product grid
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isVisibleInGrid?: boolean;
    /**
     * It is filterable in catalog product grid
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isFilterableInGrid?: boolean;
    /**
     * Position
     * @type {number}
     * @memberof CatalogDataProductAttributeInterface
     */
    position?: number;
    /**
     * Apply to value for the element
     * @type {Array<string>}
     * @memberof CatalogDataProductAttributeInterface
     */
    applyTo?: Array<string>;
    /**
     * The attribute can be used in Quick Search
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    isSearchable?: string;
    /**
     * The attribute can be used in Advanced Search
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    isVisibleInAdvancedSearch?: string;
    /**
     * The attribute can be compared on the frontend
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    isComparable?: string;
    /**
     * The attribute can be used for promo rules
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    isUsedForPromoRules?: string;
    /**
     * The attribute is visible on the frontend
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    isVisibleOnFront?: string;
    /**
     * The attribute can be used in product listing
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    usedInProductListing?: string;
    /**
     * Attribute is visible on frontend.
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isVisible?: boolean;
    /**
     * Attribute scope
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    scope?: string;
    /**
     *
     * @type {CatalogDataEavAttributeExtensionInterface}
     * @memberof CatalogDataProductAttributeInterface
     */
    extensionAttributes?: CatalogDataEavAttributeExtensionInterface;
    /**
     * Id of the attribute.
     * @type {number}
     * @memberof CatalogDataProductAttributeInterface
     */
    attributeId?: number;
    /**
     * Code of the attribute.
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    attributeCode: string;
    /**
     * HTML for input element.
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    frontendInput: string;
    /**
     * Entity type id
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    entityTypeId: string;
    /**
     * Attribute is required.
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isRequired: boolean;
    /**
     * Options of the attribute (key => value pairs for select)
     * @type {Array<EavDataAttributeOptionInterface>}
     * @memberof CatalogDataProductAttributeInterface
     */
    options?: Array<EavDataAttributeOptionInterface>;
    /**
     * Current attribute has been defined by a user.
     * @type {boolean}
     * @memberof CatalogDataProductAttributeInterface
     */
    isUserDefined?: boolean;
    /**
     * Frontend label for default store
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    defaultFrontendLabel?: string;
    /**
     * Frontend label for each store
     * @type {Array<EavDataAttributeFrontendLabelInterface>}
     * @memberof CatalogDataProductAttributeInterface
     */
    frontendLabels: Array<EavDataAttributeFrontendLabelInterface>;
    /**
     * The note attribute for the element.
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    note?: string;
    /**
     * Backend type.
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    backendType?: string;
    /**
     * Backend model
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    backendModel?: string;
    /**
     * Source model
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    sourceModel?: string;
    /**
     * Default value for the element.
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    defaultValue?: string;
    /**
     * This is a unique attribute
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    isUnique?: string;
    /**
     * Frontend class of attribute
     * @type {string}
     * @memberof CatalogDataProductAttributeInterface
     */
    frontendClass?: string;
    /**
     * Validation rules.
     * @type {Array<EavDataAttributeValidationRuleInterface>}
     * @memberof CatalogDataProductAttributeInterface
     */
    validationRules?: Array<EavDataAttributeValidationRuleInterface>;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CatalogDataProductAttributeInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductAttributeMediaGalleryEntryInterface
 * @export
 * @interface CatalogDataProductAttributeMediaGalleryEntryExtensionInterface
 */
export interface CatalogDataProductAttributeMediaGalleryEntryExtensionInterface {
    /**
     *
     * @type {FrameworkDataVideoContentInterface}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryExtensionInterface
     */
    videoContent?: FrameworkDataVideoContentInterface;
}

/**
 *
 * @export
 * @interface CatalogDataProductAttributeMediaGalleryEntryInterface
 */
export interface CatalogDataProductAttributeMediaGalleryEntryInterface {
    /**
     * Gallery entry ID
     * @type {number}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    id?: number;
    /**
     * Media type
     * @type {string}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    mediaType: string;
    /**
     * Gallery entry alternative text
     * @type {string}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    label: string;
    /**
     * Gallery entry position (sort order)
     * @type {number}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    position: number;
    /**
     * If gallery entry is hidden from product page
     * @type {boolean}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    disabled: boolean;
    /**
     * Gallery entry image types (thumbnail, image, small_image etc)
     * @type {Array<string>}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    types: Array<string>;
    /**
     * File path
     * @type {string}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    file?: string;
    /**
     *
     * @type {FrameworkDataImageContentInterface}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    content?: FrameworkDataImageContentInterface;
    /**
     *
     * @type {CatalogDataProductAttributeMediaGalleryEntryExtensionInterface}
     * @memberof CatalogDataProductAttributeMediaGalleryEntryInterface
     */
    extensionAttributes?: CatalogDataProductAttributeMediaGalleryEntryExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogDataProductAttributeSearchResultsInterface
 */
export interface CatalogDataProductAttributeSearchResultsInterface {
    /**
     * Attributes list.
     * @type {Array<CatalogDataProductAttributeInterface>}
     * @memberof CatalogDataProductAttributeSearchResultsInterface
     */
    items: Array<CatalogDataProductAttributeInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CatalogDataProductAttributeSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CatalogDataProductAttributeSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductAttributeTypeInterface
 * @export
 * @interface CatalogDataProductAttributeTypeExtensionInterface
 */
export interface CatalogDataProductAttributeTypeExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataProductAttributeTypeInterface
 */
export interface CatalogDataProductAttributeTypeInterface {
    /**
     * Value
     * @type {string}
     * @memberof CatalogDataProductAttributeTypeInterface
     */
    value: string;
    /**
     * Type label
     * @type {string}
     * @memberof CatalogDataProductAttributeTypeInterface
     */
    label: string;
    /**
     *
     * @type {CatalogDataProductAttributeTypeExtensionInterface}
     * @memberof CatalogDataProductAttributeTypeInterface
     */
    extensionAttributes?: CatalogDataProductAttributeTypeExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductCustomOptionInterface
 * @export
 * @interface CatalogDataProductCustomOptionExtensionInterface
 */
export interface CatalogDataProductCustomOptionExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataProductCustomOptionInterface
 */
export interface CatalogDataProductCustomOptionInterface {
    /**
     * Product SKU
     * @type {string}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    productSku: string;
    /**
     * Option id
     * @type {number}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    optionId?: number;
    /**
     * Option title
     * @type {string}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    title: string;
    /**
     * Option type
     * @type {string}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    type: string;
    /**
     * Sort order
     * @type {number}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    sortOrder: number;
    /**
     * Is require
     * @type {boolean}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    isRequire: boolean;
    /**
     * Price
     * @type {number}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    price?: number;
    /**
     * Price type
     * @type {string}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    priceType?: string;
    /**
     * Sku
     * @type {string}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    sku?: string;
    /**
     *
     * @type {string}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    fileExtension?: string;
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    maxCharacters?: number;
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    imageSizeX?: number;
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    imageSizeY?: number;
    /**
     *
     * @type {Array<CatalogDataProductCustomOptionValuesInterface>}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    values?: Array<CatalogDataProductCustomOptionValuesInterface>;
    /**
     *
     * @type {CatalogDataProductCustomOptionExtensionInterface}
     * @memberof CatalogDataProductCustomOptionInterface
     */
    extensionAttributes?: CatalogDataProductCustomOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductCustomOptionTypeInterface
 * @export
 * @interface CatalogDataProductCustomOptionTypeExtensionInterface
 */
export interface CatalogDataProductCustomOptionTypeExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataProductCustomOptionTypeInterface
 */
export interface CatalogDataProductCustomOptionTypeInterface {
    /**
     * Option type label
     * @type {string}
     * @memberof CatalogDataProductCustomOptionTypeInterface
     */
    label: string;
    /**
     * Option type code
     * @type {string}
     * @memberof CatalogDataProductCustomOptionTypeInterface
     */
    code: string;
    /**
     * Option type group
     * @type {string}
     * @memberof CatalogDataProductCustomOptionTypeInterface
     */
    group: string;
    /**
     *
     * @type {CatalogDataProductCustomOptionTypeExtensionInterface}
     * @memberof CatalogDataProductCustomOptionTypeInterface
     */
    extensionAttributes?: CatalogDataProductCustomOptionTypeExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogDataProductCustomOptionValuesInterface
 */
export interface CatalogDataProductCustomOptionValuesInterface {
    /**
     * Option title
     * @type {string}
     * @memberof CatalogDataProductCustomOptionValuesInterface
     */
    title: string;
    /**
     * Sort order
     * @type {number}
     * @memberof CatalogDataProductCustomOptionValuesInterface
     */
    sortOrder: number;
    /**
     * Price
     * @type {number}
     * @memberof CatalogDataProductCustomOptionValuesInterface
     */
    price: number;
    /**
     * Price type
     * @type {string}
     * @memberof CatalogDataProductCustomOptionValuesInterface
     */
    priceType: string;
    /**
     * Sku
     * @type {string}
     * @memberof CatalogDataProductCustomOptionValuesInterface
     */
    sku?: string;
    /**
     * Option type id
     * @type {number}
     * @memberof CatalogDataProductCustomOptionValuesInterface
     */
    optionTypeId?: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductInterface
 * @export
 * @interface CatalogDataProductExtensionInterface
 */
export interface CatalogDataProductExtensionInterface {
    /**
     *
     * @type {Array<number>}
     * @memberof CatalogDataProductExtensionInterface
     */
    websiteIds?: Array<number>;
    /**
     *
     * @type {Array<CatalogDataCategoryLinkInterface>}
     * @memberof CatalogDataProductExtensionInterface
     */
    categoryLinks?: Array<CatalogDataCategoryLinkInterface>;
    /**
     *
     * @type {CatalogInventoryDataStockItemInterface}
     * @memberof CatalogDataProductExtensionInterface
     */
    stockItem?: CatalogInventoryDataStockItemInterface;
    /**
     *
     * @type {Array<BundleDataOptionInterface>}
     * @memberof CatalogDataProductExtensionInterface
     */
    bundleProductOptions?: Array<BundleDataOptionInterface>;
    /**
     *
     * @type {Array<ConfigurableProductDataOptionInterface>}
     * @memberof CatalogDataProductExtensionInterface
     */
    configurableProductOptions?: Array<ConfigurableProductDataOptionInterface>;
    /**
     *
     * @type {Array<number>}
     * @memberof CatalogDataProductExtensionInterface
     */
    configurableProductLinks?: Array<number>;
    /**
     *
     * @type {Array<DownloadableDataLinkInterface>}
     * @memberof CatalogDataProductExtensionInterface
     */
    downloadableProductLinks?: Array<DownloadableDataLinkInterface>;
    /**
     *
     * @type {Array<DownloadableDataSampleInterface>}
     * @memberof CatalogDataProductExtensionInterface
     */
    downloadableProductSamples?: Array<DownloadableDataSampleInterface>;
    /**
     *
     * @type {Array<GiftCardDataGiftcardAmountInterface>}
     * @memberof CatalogDataProductExtensionInterface
     */
    giftcardAmounts?: Array<GiftCardDataGiftcardAmountInterface>;
}

/**
 *
 * @export
 * @interface CatalogDataProductInterface
 */
export interface CatalogDataProductInterface {
    /**
     * Id
     * @type {number}
     * @memberof CatalogDataProductInterface
     */
    id?: number;
    /**
     * Sku
     * @type {string}
     * @memberof CatalogDataProductInterface
     */
    sku: string;
    /**
     * Name
     * @type {string}
     * @memberof CatalogDataProductInterface
     */
    name?: string;
    /**
     * Attribute set id
     * @type {number}
     * @memberof CatalogDataProductInterface
     */
    attributeSetId?: number;
    /**
     * Price
     * @type {number}
     * @memberof CatalogDataProductInterface
     */
    price?: number;
    /**
     * Status
     * @type {number}
     * @memberof CatalogDataProductInterface
     */
    status?: number;
    /**
     * Visibility
     * @type {number}
     * @memberof CatalogDataProductInterface
     */
    visibility?: number;
    /**
     * Type id
     * @type {string}
     * @memberof CatalogDataProductInterface
     */
    typeId?: string;
    /**
     * Created date
     * @type {string}
     * @memberof CatalogDataProductInterface
     */
    createdAt?: string;
    /**
     * Updated date
     * @type {string}
     * @memberof CatalogDataProductInterface
     */
    updatedAt?: string;
    /**
     * Weight
     * @type {number}
     * @memberof CatalogDataProductInterface
     */
    weight?: number;
    /**
     *
     * @type {CatalogDataProductExtensionInterface}
     * @memberof CatalogDataProductInterface
     */
    extensionAttributes?: CatalogDataProductExtensionInterface;
    /**
     * Product links info
     * @type {Array<CatalogDataProductLinkInterface>}
     * @memberof CatalogDataProductInterface
     */
    productLinks?: Array<CatalogDataProductLinkInterface>;
    /**
     * List of product options
     * @type {Array<CatalogDataProductCustomOptionInterface>}
     * @memberof CatalogDataProductInterface
     */
    options?: Array<CatalogDataProductCustomOptionInterface>;
    /**
     * Media gallery entries
     * @type {Array<CatalogDataProductAttributeMediaGalleryEntryInterface>}
     * @memberof CatalogDataProductInterface
     */
    mediaGalleryEntries?: Array<CatalogDataProductAttributeMediaGalleryEntryInterface>;
    /**
     * List of product tier prices
     * @type {Array<CatalogDataProductTierPriceInterface>}
     * @memberof CatalogDataProductInterface
     */
    tierPrices?: Array<CatalogDataProductTierPriceInterface>;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CatalogDataProductInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductLinkAttributeInterface
 * @export
 * @interface CatalogDataProductLinkAttributeExtensionInterface
 */
export interface CatalogDataProductLinkAttributeExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataProductLinkAttributeInterface
 */
export interface CatalogDataProductLinkAttributeInterface {
    /**
     * Attribute code
     * @type {string}
     * @memberof CatalogDataProductLinkAttributeInterface
     */
    code: string;
    /**
     * Attribute type
     * @type {string}
     * @memberof CatalogDataProductLinkAttributeInterface
     */
    type: string;
    /**
     *
     * @type {CatalogDataProductLinkAttributeExtensionInterface}
     * @memberof CatalogDataProductLinkAttributeInterface
     */
    extensionAttributes?: CatalogDataProductLinkAttributeExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductLinkInterface
 * @export
 * @interface CatalogDataProductLinkExtensionInterface
 */
export interface CatalogDataProductLinkExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductLinkExtensionInterface
     */
    qty?: number;
}

/**
 *
 * @export
 * @interface CatalogDataProductLinkInterface
 */
export interface CatalogDataProductLinkInterface {
    /**
     * SKU
     * @type {string}
     * @memberof CatalogDataProductLinkInterface
     */
    sku: string;
    /**
     * Link type
     * @type {string}
     * @memberof CatalogDataProductLinkInterface
     */
    linkType: string;
    /**
     * Linked product sku
     * @type {string}
     * @memberof CatalogDataProductLinkInterface
     */
    linkedProductSku: string;
    /**
     * Linked product type (simple, virtual, etc)
     * @type {string}
     * @memberof CatalogDataProductLinkInterface
     */
    linkedProductType: string;
    /**
     * Linked item position
     * @type {number}
     * @memberof CatalogDataProductLinkInterface
     */
    position: number;
    /**
     *
     * @type {CatalogDataProductLinkExtensionInterface}
     * @memberof CatalogDataProductLinkInterface
     */
    extensionAttributes?: CatalogDataProductLinkExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductLinkTypeInterface
 * @export
 * @interface CatalogDataProductLinkTypeExtensionInterface
 */
export interface CatalogDataProductLinkTypeExtensionInterface {
}

/**
 *
 * @export
 * @interface CatalogDataProductLinkTypeInterface
 */
export interface CatalogDataProductLinkTypeInterface {
    /**
     * Link type code
     * @type {number}
     * @memberof CatalogDataProductLinkTypeInterface
     */
    code: number;
    /**
     * Link type name
     * @type {string}
     * @memberof CatalogDataProductLinkTypeInterface
     */
    name: string;
    /**
     *
     * @type {CatalogDataProductLinkTypeExtensionInterface}
     * @memberof CatalogDataProductLinkTypeInterface
     */
    extensionAttributes?: CatalogDataProductLinkTypeExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductOptionInterface
 * @export
 * @interface CatalogDataProductOptionExtensionInterface
 */
export interface CatalogDataProductOptionExtensionInterface {
    /**
     *
     * @type {Array<CatalogDataCustomOptionInterface>}
     * @memberof CatalogDataProductOptionExtensionInterface
     */
    customOptions?: Array<CatalogDataCustomOptionInterface>;
    /**
     *
     * @type {Array<BundleDataBundleOptionInterface>}
     * @memberof CatalogDataProductOptionExtensionInterface
     */
    bundleOptions?: Array<BundleDataBundleOptionInterface>;
    /**
     *
     * @type {Array<ConfigurableProductDataConfigurableItemOptionValueInterface>}
     * @memberof CatalogDataProductOptionExtensionInterface
     */
    configurableItemOptions?: Array<ConfigurableProductDataConfigurableItemOptionValueInterface>;
    /**
     *
     * @type {DownloadableDataDownloadableOptionInterface}
     * @memberof CatalogDataProductOptionExtensionInterface
     */
    downloadableOption?: DownloadableDataDownloadableOptionInterface;
    /**
     *
     * @type {GiftCardDataGiftCardOptionInterface}
     * @memberof CatalogDataProductOptionExtensionInterface
     */
    giftcardItemOption?: GiftCardDataGiftCardOptionInterface;
}

/**
 * Product option interface
 * @export
 * @interface CatalogDataProductOptionInterface
 */
export interface CatalogDataProductOptionInterface {
    /**
     *
     * @type {CatalogDataProductOptionExtensionInterface}
     * @memberof CatalogDataProductOptionInterface
     */
    extensionAttributes?: CatalogDataProductOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductRender\\ButtonInterface
 * @export
 * @interface CatalogDataProductRenderButtonExtensionInterface
 */
export interface CatalogDataProductRenderButtonExtensionInterface {
}

/**
 * Button interface. This interface represents all manner of product buttons: add to cart, add to compare, etc... The buttons describes by this interface should have interaction with backend
 * @export
 * @interface CatalogDataProductRenderButtonInterface
 */
export interface CatalogDataProductRenderButtonInterface {
    /**
     * Post data
     * @type {string}
     * @memberof CatalogDataProductRenderButtonInterface
     */
    postData: string;
    /**
     * Url, needed to add product to cart
     * @type {string}
     * @memberof CatalogDataProductRenderButtonInterface
     */
    url: string;
    /**
     * Flag whether a product has options or not
     * @type {boolean}
     * @memberof CatalogDataProductRenderButtonInterface
     */
    requiredOptions: boolean;
    /**
     *
     * @type {CatalogDataProductRenderButtonExtensionInterface}
     * @memberof CatalogDataProductRenderButtonInterface
     */
    extensionAttributes?: CatalogDataProductRenderButtonExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductRenderInterface
 * @export
 * @interface CatalogDataProductRenderExtensionInterface
 */
export interface CatalogDataProductRenderExtensionInterface {
    /**
     *
     * @type {CatalogDataProductRenderButtonInterface}
     * @memberof CatalogDataProductRenderExtensionInterface
     */
    wishlistButton?: CatalogDataProductRenderButtonInterface;
    /**
     *
     * @type {string}
     * @memberof CatalogDataProductRenderExtensionInterface
     */
    reviewHtml?: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductRender\\FormattedPriceInfoInterface
 * @export
 * @interface CatalogDataProductRenderFormattedPriceInfoExtensionInterface
 */
export interface CatalogDataProductRenderFormattedPriceInfoExtensionInterface {
}

/**
 * Formatted Price interface. Aggregate formatted html with price representations. E.g.: <span class=\"price\">$9.00</span> Consider currency, rounding and html
 * @export
 * @interface CatalogDataProductRenderFormattedPriceInfoInterface
 */
export interface CatalogDataProductRenderFormattedPriceInfoInterface {
    /**
     * Html with final price
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    finalPrice: string;
    /**
     * Max price of a product
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    maxPrice: string;
    /**
     * The minimal price of the product or variation
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    minimalPrice: string;
    /**
     * Max regular price
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    maxRegularPrice: string;
    /**
     * Minimal regular price
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    minimalRegularPrice: string;
    /**
     * Special price
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    specialPrice: string;
    /**
     * Price - is price of product without discounts and special price with taxes and fixed product tax
     * @type {string}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    regularPrice: string;
    /**
     *
     * @type {CatalogDataProductRenderFormattedPriceInfoExtensionInterface}
     * @memberof CatalogDataProductRenderFormattedPriceInfoInterface
     */
    extensionAttributes?: CatalogDataProductRenderFormattedPriceInfoExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductRender\\ImageInterface
 * @export
 * @interface CatalogDataProductRenderImageExtensionInterface
 */
export interface CatalogDataProductRenderImageExtensionInterface {
}

/**
 * Product Render image interface. Represents physical characteristics of image, that can be used in product listing or product view
 * @export
 * @interface CatalogDataProductRenderImageInterface
 */
export interface CatalogDataProductRenderImageInterface {
    /**
     * Image url
     * @type {string}
     * @memberof CatalogDataProductRenderImageInterface
     */
    url: string;
    /**
     * Image code
     * @type {string}
     * @memberof CatalogDataProductRenderImageInterface
     */
    code: string;
    /**
     * Image height
     * @type {number}
     * @memberof CatalogDataProductRenderImageInterface
     */
    height: number;
    /**
     * Image width in px
     * @type {number}
     * @memberof CatalogDataProductRenderImageInterface
     */
    width: number;
    /**
     * Image label
     * @type {string}
     * @memberof CatalogDataProductRenderImageInterface
     */
    label: string;
    /**
     * Resize width
     * @type {number}
     * @memberof CatalogDataProductRenderImageInterface
     */
    resizedWidth: number;
    /**
     * Resize height
     * @type {number}
     * @memberof CatalogDataProductRenderImageInterface
     */
    resizedHeight: number;
    /**
     *
     * @type {CatalogDataProductRenderImageExtensionInterface}
     * @memberof CatalogDataProductRenderImageInterface
     */
    extensionAttributes?: CatalogDataProductRenderImageExtensionInterface;
}

/**
 * Represents Data Object which holds enough information to render product This information is put into part as Add To Cart or Add to Compare Data or Price Data
 * @export
 * @interface CatalogDataProductRenderInterface
 */
export interface CatalogDataProductRenderInterface {
    /**
     *
     * @type {CatalogDataProductRenderButtonInterface}
     * @memberof CatalogDataProductRenderInterface
     */
    addToCartButton: CatalogDataProductRenderButtonInterface;
    /**
     *
     * @type {CatalogDataProductRenderButtonInterface}
     * @memberof CatalogDataProductRenderInterface
     */
    addToCompareButton: CatalogDataProductRenderButtonInterface;
    /**
     *
     * @type {CatalogDataProductRenderPriceInfoInterface}
     * @memberof CatalogDataProductRenderInterface
     */
    priceInfo: CatalogDataProductRenderPriceInfoInterface;
    /**
     * Enough information, that needed to render image on front
     * @type {Array<CatalogDataProductRenderImageInterface>}
     * @memberof CatalogDataProductRenderInterface
     */
    images: Array<CatalogDataProductRenderImageInterface>;
    /**
     * Product url
     * @type {string}
     * @memberof CatalogDataProductRenderInterface
     */
    url: string;
    /**
     * Product identifier
     * @type {number}
     * @memberof CatalogDataProductRenderInterface
     */
    id: number;
    /**
     * Product name
     * @type {string}
     * @memberof CatalogDataProductRenderInterface
     */
    name: string;
    /**
     * Product type. Such as bundle, grouped, simple, etc...
     * @type {string}
     * @memberof CatalogDataProductRenderInterface
     */
    type: string;
    /**
     * Information about product saleability (In Stock)
     * @type {string}
     * @memberof CatalogDataProductRenderInterface
     */
    isSalable: string;
    /**
     * Information about current store id or requested store id
     * @type {number}
     * @memberof CatalogDataProductRenderInterface
     */
    storeId: number;
    /**
     * Current or desired currency code to product
     * @type {string}
     * @memberof CatalogDataProductRenderInterface
     */
    currencyCode: string;
    /**
     *
     * @type {CatalogDataProductRenderExtensionInterface}
     * @memberof CatalogDataProductRenderInterface
     */
    extensionAttributes: CatalogDataProductRenderExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductRender\\PriceInfoInterface
 * @export
 * @interface CatalogDataProductRenderPriceInfoExtensionInterface
 */
export interface CatalogDataProductRenderPriceInfoExtensionInterface {
    /**
     *
     * @type {MsrpDataProductRenderMsrpPriceInfoInterface}
     * @memberof CatalogDataProductRenderPriceInfoExtensionInterface
     */
    msrp?: MsrpDataProductRenderMsrpPriceInfoInterface;
    /**
     *
     * @type {CatalogDataProductRenderPriceInfoInterface}
     * @memberof CatalogDataProductRenderPriceInfoExtensionInterface
     */
    taxAdjustments?: CatalogDataProductRenderPriceInfoInterface;
    /**
     *
     * @type {Array<WeeeDataProductRenderWeeeAdjustmentAttributeInterface>}
     * @memberof CatalogDataProductRenderPriceInfoExtensionInterface
     */
    weeeAttributes?: Array<WeeeDataProductRenderWeeeAdjustmentAttributeInterface>;
    /**
     *
     * @type {string}
     * @memberof CatalogDataProductRenderPriceInfoExtensionInterface
     */
    weeeAdjustment?: string;
}

/**
 * Price interface.
 * @export
 * @interface CatalogDataProductRenderPriceInfoInterface
 */
export interface CatalogDataProductRenderPriceInfoInterface {
    /**
     * Final price
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    finalPrice: number;
    /**
     * Max price of a product
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    maxPrice: number;
    /**
     * Max regular price
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    maxRegularPrice: number;
    /**
     * Minimal regular price
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    minimalRegularPrice: number;
    /**
     * Special price
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    specialPrice: number;
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    minimalPrice: number;
    /**
     * Regular price
     * @type {number}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    regularPrice: number;
    /**
     *
     * @type {CatalogDataProductRenderFormattedPriceInfoInterface}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    formattedPrices: CatalogDataProductRenderFormattedPriceInfoInterface;
    /**
     *
     * @type {CatalogDataProductRenderPriceInfoExtensionInterface}
     * @memberof CatalogDataProductRenderPriceInfoInterface
     */
    extensionAttributes?: CatalogDataProductRenderPriceInfoExtensionInterface;
}

/**
 * Dto that holds render information about products
 * @export
 * @interface CatalogDataProductRenderSearchResultsInterface
 */
export interface CatalogDataProductRenderSearchResultsInterface {
    /**
     * List of products rendered information
     * @type {Array<CatalogDataProductRenderInterface>}
     * @memberof CatalogDataProductRenderSearchResultsInterface
     */
    items: Array<CatalogDataProductRenderInterface>;
}

/**
 *
 * @export
 * @interface CatalogDataProductSearchResultsInterface
 */
export interface CatalogDataProductSearchResultsInterface {
    /**
     * Attributes list.
     * @type {Array<CatalogDataProductInterface>}
     * @memberof CatalogDataProductSearchResultsInterface
     */
    items: Array<CatalogDataProductInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CatalogDataProductSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CatalogDataProductSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductTierPriceInterface
 * @export
 * @interface CatalogDataProductTierPriceExtensionInterface
 */
export interface CatalogDataProductTierPriceExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductTierPriceExtensionInterface
     */
    percentageValue?: number;
    /**
     *
     * @type {number}
     * @memberof CatalogDataProductTierPriceExtensionInterface
     */
    websiteId?: number;
}

/**
 *
 * @export
 * @interface CatalogDataProductTierPriceInterface
 */
export interface CatalogDataProductTierPriceInterface {
    /**
     * Customer group id
     * @type {number}
     * @memberof CatalogDataProductTierPriceInterface
     */
    customerGroupId: number;
    /**
     * Tier qty
     * @type {number}
     * @memberof CatalogDataProductTierPriceInterface
     */
    qty: number;
    /**
     * Price value
     * @type {number}
     * @memberof CatalogDataProductTierPriceInterface
     */
    value: number;
    /**
     *
     * @type {CatalogDataProductTierPriceExtensionInterface}
     * @memberof CatalogDataProductTierPriceInterface
     */
    extensionAttributes?: CatalogDataProductTierPriceExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\ProductTypeInterface
 * @export
 * @interface CatalogDataProductTypeExtensionInterface
 */
export interface CatalogDataProductTypeExtensionInterface {
}

/**
 * Product type details
 * @export
 * @interface CatalogDataProductTypeInterface
 */
export interface CatalogDataProductTypeInterface {
    /**
     * Product type code
     * @type {string}
     * @memberof CatalogDataProductTypeInterface
     */
    name: string;
    /**
     * Product type label
     * @type {string}
     * @memberof CatalogDataProductTypeInterface
     */
    label: string;
    /**
     *
     * @type {CatalogDataProductTypeExtensionInterface}
     * @memberof CatalogDataProductTypeInterface
     */
    extensionAttributes?: CatalogDataProductTypeExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogDataProductWebsiteLinkInterface
 */
export interface CatalogDataProductWebsiteLinkInterface {
    /**
     *
     * @type {string}
     * @memberof CatalogDataProductWebsiteLinkInterface
     */
    sku: string;
    /**
     * Website ids
     * @type {number}
     * @memberof CatalogDataProductWebsiteLinkInterface
     */
    websiteId: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\SpecialPriceInterface
 * @export
 * @interface CatalogDataSpecialPriceExtensionInterface
 */
export interface CatalogDataSpecialPriceExtensionInterface {
}

/**
 * Product Special Price Interface is used to encapsulate data that can be processed by efficient price API.
 * @export
 * @interface CatalogDataSpecialPriceInterface
 */
export interface CatalogDataSpecialPriceInterface {
    /**
     * Product special price value.
     * @type {number}
     * @memberof CatalogDataSpecialPriceInterface
     */
    price: number;
    /**
     * ID of store, that contains special price value.
     * @type {number}
     * @memberof CatalogDataSpecialPriceInterface
     */
    storeId: number;
    /**
     * SKU of product, that contains special price value.
     * @type {string}
     * @memberof CatalogDataSpecialPriceInterface
     */
    sku: string;
    /**
     * Start date for special price in Y-m-d H:i:s format.
     * @type {string}
     * @memberof CatalogDataSpecialPriceInterface
     */
    priceFrom: string;
    /**
     * End date for special price in Y-m-d H:i:s format.
     * @type {string}
     * @memberof CatalogDataSpecialPriceInterface
     */
    priceTo: string;
    /**
     *
     * @type {CatalogDataSpecialPriceExtensionInterface}
     * @memberof CatalogDataSpecialPriceInterface
     */
    extensionAttributes?: CatalogDataSpecialPriceExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Catalog\\Api\\Data\\TierPriceInterface
 * @export
 * @interface CatalogDataTierPriceExtensionInterface
 */
export interface CatalogDataTierPriceExtensionInterface {
}

/**
 * Tier price interface.
 * @export
 * @interface CatalogDataTierPriceInterface
 */
export interface CatalogDataTierPriceInterface {
    /**
     * Tier price.
     * @type {number}
     * @memberof CatalogDataTierPriceInterface
     */
    price: number;
    /**
     * Tier price type.
     * @type {string}
     * @memberof CatalogDataTierPriceInterface
     */
    priceType: string;
    /**
     * Website id.
     * @type {number}
     * @memberof CatalogDataTierPriceInterface
     */
    websiteId: number;
    /**
     * SKU.
     * @type {string}
     * @memberof CatalogDataTierPriceInterface
     */
    sku: string;
    /**
     * Customer group.
     * @type {string}
     * @memberof CatalogDataTierPriceInterface
     */
    customerGroup: string;
    /**
     * Quantity.
     * @type {number}
     * @memberof CatalogDataTierPriceInterface
     */
    quantity: number;
    /**
     *
     * @type {CatalogDataTierPriceExtensionInterface}
     * @memberof CatalogDataTierPriceInterface
     */
    extensionAttributes?: CatalogDataTierPriceExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\CatalogInventory\\Api\\Data\\StockItemInterface
 * @export
 * @interface CatalogInventoryDataStockItemExtensionInterface
 */
export interface CatalogInventoryDataStockItemExtensionInterface {
}

/**
 * Interface StockItem
 * @export
 * @interface CatalogInventoryDataStockItemInterface
 */
export interface CatalogInventoryDataStockItemInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    itemId?: number;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    productId?: number;
    /**
     * Stock identifier
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    stockId?: number;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    qty: number;
    /**
     * Stock Availability
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    isInStock: boolean;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    isQtyDecimal: boolean;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    showDefaultNotificationMessage: boolean;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigMinQty: boolean;
    /**
     * Minimal quantity available for item status in stock
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    minQty: number;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigMinSaleQty: number;
    /**
     * Minimum Qty Allowed in Shopping Cart or NULL when there is no limitation
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    minSaleQty: number;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigMaxSaleQty: boolean;
    /**
     * Maximum Qty Allowed in Shopping Cart data wrapper
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    maxSaleQty: number;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigBackorders: boolean;
    /**
     * Backorders status
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    backorders: number;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigNotifyStockQty: boolean;
    /**
     * Notify for Quantity Below data wrapper
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    notifyStockQty: number;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigQtyIncrements: boolean;
    /**
     * Quantity Increments data wrapper
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    qtyIncrements: number;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigEnableQtyInc: boolean;
    /**
     * Whether Quantity Increments is enabled
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    enableQtyIncrements: boolean;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    useConfigManageStock: boolean;
    /**
     * Can Manage Stock
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    manageStock: boolean;
    /**
     *
     * @type {string}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    lowStockDate: string;
    /**
     *
     * @type {boolean}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    isDecimalDivided: boolean;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    stockStatusChangedAuto: number;
    /**
     *
     * @type {CatalogInventoryDataStockItemExtensionInterface}
     * @memberof CatalogInventoryDataStockItemInterface
     */
    extensionAttributes?: CatalogInventoryDataStockItemExtensionInterface;
}

/**
 * Stock Status collection interface
 * @export
 * @interface CatalogInventoryDataStockStatusCollectionInterface
 */
export interface CatalogInventoryDataStockStatusCollectionInterface {
    /**
     * Items
     * @type {Array<CatalogInventoryDataStockStatusInterface>}
     * @memberof CatalogInventoryDataStockStatusCollectionInterface
     */
    items: Array<CatalogInventoryDataStockStatusInterface>;
    /**
     *
     * @type {CatalogInventoryStockStatusCriteriaInterface}
     * @memberof CatalogInventoryDataStockStatusCollectionInterface
     */
    searchCriteria: CatalogInventoryStockStatusCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CatalogInventoryDataStockStatusCollectionInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\CatalogInventory\\Api\\Data\\StockStatusInterface
 * @export
 * @interface CatalogInventoryDataStockStatusExtensionInterface
 */
export interface CatalogInventoryDataStockStatusExtensionInterface {
}

/**
 * Interface StockStatusInterface
 * @export
 * @interface CatalogInventoryDataStockStatusInterface
 */
export interface CatalogInventoryDataStockStatusInterface {
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockStatusInterface
     */
    productId: number;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockStatusInterface
     */
    stockId: number;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockStatusInterface
     */
    qty: number;
    /**
     *
     * @type {number}
     * @memberof CatalogInventoryDataStockStatusInterface
     */
    stockStatus: number;
    /**
     *
     * @type {CatalogInventoryDataStockItemInterface}
     * @memberof CatalogInventoryDataStockStatusInterface
     */
    stockItem: CatalogInventoryDataStockItemInterface;
    /**
     *
     * @type {CatalogInventoryDataStockStatusExtensionInterface}
     * @memberof CatalogInventoryDataStockStatusInterface
     */
    extensionAttributes?: CatalogInventoryDataStockStatusExtensionInterface;
}

/**
 *
 * @export
 * @interface CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody
 */
export interface CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody {
    /**
     *
     * @type {CatalogInventoryDataStockItemInterface}
     * @memberof CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody
     */
    stockItem: CatalogInventoryDataStockItemInterface;
}

/**
 * Interface StockStatusCriteriaInterface
 * @export
 * @interface CatalogInventoryStockStatusCriteriaInterface
 */
export interface CatalogInventoryStockStatusCriteriaInterface {
    /**
     * Associated Mapper Interface name
     * @type {string}
     * @memberof CatalogInventoryStockStatusCriteriaInterface
     */
    mapperInterfaceName: string;
    /**
     * Criteria objects added to current Composite Criteria
     * @type {Array<FrameworkCriteriaInterface>}
     * @memberof CatalogInventoryStockStatusCriteriaInterface
     */
    criteriaList: Array<FrameworkCriteriaInterface>;
    /**
     * List of filters
     * @type {Array<string>}
     * @memberof CatalogInventoryStockStatusCriteriaInterface
     */
    filters: Array<string>;
    /**
     * Ordering criteria
     * @type {Array<string>}
     * @memberof CatalogInventoryStockStatusCriteriaInterface
     */
    orders: Array<string>;
    /**
     * Limit
     * @type {Array<string>}
     * @memberof CatalogInventoryStockStatusCriteriaInterface
     */
    limit: Array<string>;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeGroupRepositoryV1SavePostBody
 */
export interface CatalogProductAttributeGroupRepositoryV1SavePostBody {
    /**
     *
     * @type {EavDataAttributeGroupInterface}
     * @memberof CatalogProductAttributeGroupRepositoryV1SavePostBody
     */
    group: EavDataAttributeGroupInterface;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeGroupRepositoryV1SavePutBody
 */
export interface CatalogProductAttributeGroupRepositoryV1SavePutBody {
    /**
     *
     * @type {EavDataAttributeGroupInterface}
     * @memberof CatalogProductAttributeGroupRepositoryV1SavePutBody
     */
    group: EavDataAttributeGroupInterface;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeManagementV1AssignPostBody
 */
export interface CatalogProductAttributeManagementV1AssignPostBody {
    /**
     *
     * @type {number}
     * @memberof CatalogProductAttributeManagementV1AssignPostBody
     */
    attributeSetId: number;
    /**
     *
     * @type {number}
     * @memberof CatalogProductAttributeManagementV1AssignPostBody
     */
    attributeGroupId: number;
    /**
     *
     * @type {string}
     * @memberof CatalogProductAttributeManagementV1AssignPostBody
     */
    attributeCode: string;
    /**
     *
     * @type {number}
     * @memberof CatalogProductAttributeManagementV1AssignPostBody
     */
    sortOrder: number;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeMediaGalleryManagementV1CreatePostBody
 */
export interface CatalogProductAttributeMediaGalleryManagementV1CreatePostBody {
    /**
     *
     * @type {CatalogDataProductAttributeMediaGalleryEntryInterface}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1CreatePostBody
     */
    entry: CatalogDataProductAttributeMediaGalleryEntryInterface;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody
 */
export interface CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody {
    /**
     *
     * @type {CatalogDataProductAttributeMediaGalleryEntryInterface}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody
     */
    entry: CatalogDataProductAttributeMediaGalleryEntryInterface;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeOptionManagementV1AddPostBody
 */
export interface CatalogProductAttributeOptionManagementV1AddPostBody {
    /**
     *
     * @type {EavDataAttributeOptionInterface}
     * @memberof CatalogProductAttributeOptionManagementV1AddPostBody
     */
    option: EavDataAttributeOptionInterface;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeRepositoryV1SavePostBody
 */
export interface CatalogProductAttributeRepositoryV1SavePostBody {
    /**
     *
     * @type {CatalogDataProductAttributeInterface}
     * @memberof CatalogProductAttributeRepositoryV1SavePostBody
     */
    attribute: CatalogDataProductAttributeInterface;
}

/**
 *
 * @export
 * @interface CatalogProductAttributeRepositoryV1SavePutBody
 */
export interface CatalogProductAttributeRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataProductAttributeInterface}
     * @memberof CatalogProductAttributeRepositoryV1SavePutBody
     */
    attribute: CatalogDataProductAttributeInterface;
}

/**
 *
 * @export
 * @interface CatalogProductCustomOptionRepositoryV1SavePostBody
 */
export interface CatalogProductCustomOptionRepositoryV1SavePostBody {
    /**
     *
     * @type {CatalogDataProductCustomOptionInterface}
     * @memberof CatalogProductCustomOptionRepositoryV1SavePostBody
     */
    option: CatalogDataProductCustomOptionInterface;
}

/**
 *
 * @export
 * @interface CatalogProductCustomOptionRepositoryV1SavePutBody
 */
export interface CatalogProductCustomOptionRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataProductCustomOptionInterface}
     * @memberof CatalogProductCustomOptionRepositoryV1SavePutBody
     */
    option: CatalogDataProductCustomOptionInterface;
}

/**
 *
 * @export
 * @interface CatalogProductLinkManagementV1SetProductLinksPostBody
 */
export interface CatalogProductLinkManagementV1SetProductLinksPostBody {
    /**
     *
     * @type {Array<CatalogDataProductLinkInterface>}
     * @memberof CatalogProductLinkManagementV1SetProductLinksPostBody
     */
    items: Array<CatalogDataProductLinkInterface>;
}

/**
 *
 * @export
 * @interface CatalogProductLinkRepositoryV1SavePutBody
 */
export interface CatalogProductLinkRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataProductLinkInterface}
     * @memberof CatalogProductLinkRepositoryV1SavePutBody
     */
    entity: CatalogDataProductLinkInterface;
}

/**
 *
 * @export
 * @interface CatalogProductRepositoryV1SavePostBody
 */
export interface CatalogProductRepositoryV1SavePostBody {
    /**
     *
     * @type {CatalogDataProductInterface}
     * @memberof CatalogProductRepositoryV1SavePostBody
     */
    product: CatalogDataProductInterface;
    /**
     *
     * @type {boolean}
     * @memberof CatalogProductRepositoryV1SavePostBody
     */
    saveOptions?: boolean;
}

/**
 *
 * @export
 * @interface CatalogProductRepositoryV1SavePutBody
 */
export interface CatalogProductRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataProductInterface}
     * @memberof CatalogProductRepositoryV1SavePutBody
     */
    product: CatalogDataProductInterface;
    /**
     *
     * @type {boolean}
     * @memberof CatalogProductRepositoryV1SavePutBody
     */
    saveOptions?: boolean;
}

/**
 *
 * @export
 * @interface CatalogProductWebsiteLinkRepositoryV1SavePostBody
 */
export interface CatalogProductWebsiteLinkRepositoryV1SavePostBody {
    /**
     *
     * @type {CatalogDataProductWebsiteLinkInterface}
     * @memberof CatalogProductWebsiteLinkRepositoryV1SavePostBody
     */
    productWebsiteLink: CatalogDataProductWebsiteLinkInterface;
}

/**
 *
 * @export
 * @interface CatalogProductWebsiteLinkRepositoryV1SavePutBody
 */
export interface CatalogProductWebsiteLinkRepositoryV1SavePutBody {
    /**
     *
     * @type {CatalogDataProductWebsiteLinkInterface}
     * @memberof CatalogProductWebsiteLinkRepositoryV1SavePutBody
     */
    productWebsiteLink: CatalogDataProductWebsiteLinkInterface;
}

/**
 *
 * @export
 * @interface CatalogSpecialPriceStorageV1DeletePostBody
 */
export interface CatalogSpecialPriceStorageV1DeletePostBody {
    /**
     *
     * @type {Array<CatalogDataSpecialPriceInterface>}
     * @memberof CatalogSpecialPriceStorageV1DeletePostBody
     */
    prices: Array<CatalogDataSpecialPriceInterface>;
}

/**
 *
 * @export
 * @interface CatalogSpecialPriceStorageV1GetPostBody
 */
export interface CatalogSpecialPriceStorageV1GetPostBody {
    /**
     *
     * @type {Array<string>}
     * @memberof CatalogSpecialPriceStorageV1GetPostBody
     */
    skus: Array<string>;
}

/**
 *
 * @export
 * @interface CatalogSpecialPriceStorageV1UpdatePostBody
 */
export interface CatalogSpecialPriceStorageV1UpdatePostBody {
    /**
     *
     * @type {Array<CatalogDataSpecialPriceInterface>}
     * @memberof CatalogSpecialPriceStorageV1UpdatePostBody
     */
    prices: Array<CatalogDataSpecialPriceInterface>;
}

/**
 *
 * @export
 * @interface CatalogTierPriceStorageV1DeletePostBody
 */
export interface CatalogTierPriceStorageV1DeletePostBody {
    /**
     *
     * @type {Array<CatalogDataTierPriceInterface>}
     * @memberof CatalogTierPriceStorageV1DeletePostBody
     */
    prices: Array<CatalogDataTierPriceInterface>;
}

/**
 *
 * @export
 * @interface CatalogTierPriceStorageV1GetPostBody
 */
export interface CatalogTierPriceStorageV1GetPostBody {
    /**
     *
     * @type {Array<string>}
     * @memberof CatalogTierPriceStorageV1GetPostBody
     */
    skus: Array<string>;
}

/**
 *
 * @export
 * @interface CatalogTierPriceStorageV1ReplacePutBody
 */
export interface CatalogTierPriceStorageV1ReplacePutBody {
    /**
     *
     * @type {Array<CatalogDataTierPriceInterface>}
     * @memberof CatalogTierPriceStorageV1ReplacePutBody
     */
    prices: Array<CatalogDataTierPriceInterface>;
}

/**
 *
 * @export
 * @interface CatalogTierPriceStorageV1UpdatePostBody
 */
export interface CatalogTierPriceStorageV1UpdatePostBody {
    /**
     *
     * @type {Array<CatalogDataTierPriceInterface>}
     * @memberof CatalogTierPriceStorageV1UpdatePostBody
     */
    prices: Array<CatalogDataTierPriceInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\CheckoutAgreements\\Api\\Data\\AgreementInterface
 * @export
 * @interface CheckoutAgreementsDataAgreementExtensionInterface
 */
export interface CheckoutAgreementsDataAgreementExtensionInterface {
}

/**
 * Interface AgreementInterface
 * @export
 * @interface CheckoutAgreementsDataAgreementInterface
 */
export interface CheckoutAgreementsDataAgreementInterface {
    /**
     * Agreement ID.
     * @type {number}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    agreementId: number;
    /**
     * Agreement name.
     * @type {string}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    name: string;
    /**
     * Agreement content.
     * @type {string}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    content: string;
    /**
     * Agreement content height. Otherwise, null.
     * @type {string}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    contentHeight?: string;
    /**
     * Agreement checkbox text.
     * @type {string}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    checkboxText: string;
    /**
     * Agreement status.
     * @type {boolean}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    isActive: boolean;
    /**
     * * true - HTML. * false - plain text.
     * @type {boolean}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    isHtml: boolean;
    /**
     * The agreement applied mode.
     * @type {number}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    mode: number;
    /**
     *
     * @type {CheckoutAgreementsDataAgreementExtensionInterface}
     * @memberof CheckoutAgreementsDataAgreementInterface
     */
    extensionAttributes?: CheckoutAgreementsDataAgreementExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Checkout\\Api\\Data\\PaymentDetailsInterface
 * @export
 * @interface CheckoutDataPaymentDetailsExtensionInterface
 */
export interface CheckoutDataPaymentDetailsExtensionInterface {
}

/**
 * Interface PaymentDetailsInterface
 * @export
 * @interface CheckoutDataPaymentDetailsInterface
 */
export interface CheckoutDataPaymentDetailsInterface {
    /**
     *
     * @type {Array<QuoteDataPaymentMethodInterface>}
     * @memberof CheckoutDataPaymentDetailsInterface
     */
    paymentMethods: Array<QuoteDataPaymentMethodInterface>;
    /**
     *
     * @type {QuoteDataTotalsInterface}
     * @memberof CheckoutDataPaymentDetailsInterface
     */
    totals: QuoteDataTotalsInterface;
    /**
     *
     * @type {CheckoutDataPaymentDetailsExtensionInterface}
     * @memberof CheckoutDataPaymentDetailsInterface
     */
    extensionAttributes?: CheckoutDataPaymentDetailsExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Checkout\\Api\\Data\\ShippingInformationInterface
 * @export
 * @interface CheckoutDataShippingInformationExtensionInterface
 */
export interface CheckoutDataShippingInformationExtensionInterface {
}

/**
 * Interface ShippingInformationInterface
 * @export
 * @interface CheckoutDataShippingInformationInterface
 */
export interface CheckoutDataShippingInformationInterface {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutDataShippingInformationInterface
     */
    shippingAddress: QuoteDataAddressInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutDataShippingInformationInterface
     */
    billingAddress?: QuoteDataAddressInterface;
    /**
     * Shipping method code
     * @type {string}
     * @memberof CheckoutDataShippingInformationInterface
     */
    shippingMethodCode: string;
    /**
     * Carrier code
     * @type {string}
     * @memberof CheckoutDataShippingInformationInterface
     */
    shippingCarrierCode: string;
    /**
     *
     * @type {CheckoutDataShippingInformationExtensionInterface}
     * @memberof CheckoutDataShippingInformationInterface
     */
    extensionAttributes?: CheckoutDataShippingInformationExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CheckoutDataShippingInformationInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Checkout\\Api\\Data\\TotalsInformationInterface
 * @export
 * @interface CheckoutDataTotalsInformationExtensionInterface
 */
export interface CheckoutDataTotalsInformationExtensionInterface {
}

/**
 * Interface TotalsInformationInterface
 * @export
 * @interface CheckoutDataTotalsInformationInterface
 */
export interface CheckoutDataTotalsInformationInterface {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutDataTotalsInformationInterface
     */
    address: QuoteDataAddressInterface;
    /**
     * Shipping method code
     * @type {string}
     * @memberof CheckoutDataTotalsInformationInterface
     */
    shippingMethodCode?: string;
    /**
     * Carrier code
     * @type {string}
     * @memberof CheckoutDataTotalsInformationInterface
     */
    shippingCarrierCode?: string;
    /**
     *
     * @type {CheckoutDataTotalsInformationExtensionInterface}
     * @memberof CheckoutDataTotalsInformationInterface
     */
    extensionAttributes?: CheckoutDataTotalsInformationExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CheckoutDataTotalsInformationInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 *
 * @export
 * @interface CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
 */
export interface CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody {
    /**
     *
     * @type {string}
     * @memberof CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    email: string;
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody
 */
export interface CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody {
    /**
     *
     * @type {string}
     * @memberof CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody
     */
    email: string;
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody
 */
export interface CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody {
    /**
     *
     * @type {CheckoutDataShippingInformationInterface}
     * @memberof CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody
     */
    addressInformation: CheckoutDataShippingInformationInterface;
}

/**
 *
 * @export
 * @interface CheckoutGuestTotalsInformationManagementV1CalculatePostBody
 */
export interface CheckoutGuestTotalsInformationManagementV1CalculatePostBody {
    /**
     *
     * @type {CheckoutDataTotalsInformationInterface}
     * @memberof CheckoutGuestTotalsInformationManagementV1CalculatePostBody
     */
    addressInformation: CheckoutDataTotalsInformationInterface;
}

/**
 *
 * @export
 * @interface CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
 */
export interface CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody
 */
export interface CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface CheckoutShippingInformationManagementV1SaveAddressInformationPostBody
 */
export interface CheckoutShippingInformationManagementV1SaveAddressInformationPostBody {
    /**
     *
     * @type {CheckoutDataShippingInformationInterface}
     * @memberof CheckoutShippingInformationManagementV1SaveAddressInformationPostBody
     */
    addressInformation: CheckoutDataShippingInformationInterface;
}

/**
 *
 * @export
 * @interface CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1
 */
export interface CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1 {
    /**
     *
     * @type {CheckoutDataShippingInformationInterface}
     * @memberof CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1
     */
    addressInformation: CheckoutDataShippingInformationInterface;
}

/**
 *
 * @export
 * @interface CheckoutTotalsInformationManagementV1CalculatePostBody
 */
export interface CheckoutTotalsInformationManagementV1CalculatePostBody {
    /**
     *
     * @type {CheckoutDataTotalsInformationInterface}
     * @memberof CheckoutTotalsInformationManagementV1CalculatePostBody
     */
    addressInformation: CheckoutDataTotalsInformationInterface;
}

/**
 *
 * @export
 * @interface CheckoutTotalsInformationManagementV1CalculatePostBody1
 */
export interface CheckoutTotalsInformationManagementV1CalculatePostBody1 {
    /**
     *
     * @type {CheckoutDataTotalsInformationInterface}
     * @memberof CheckoutTotalsInformationManagementV1CalculatePostBody1
     */
    addressInformation: CheckoutDataTotalsInformationInterface;
}

/**
 *
 * @export
 * @interface CmsBlockRepositoryV1SavePostBody
 */
export interface CmsBlockRepositoryV1SavePostBody {
    /**
     *
     * @type {CmsDataBlockInterface}
     * @memberof CmsBlockRepositoryV1SavePostBody
     */
    block: CmsDataBlockInterface;
}

/**
 *
 * @export
 * @interface CmsBlockRepositoryV1SavePutBody
 */
export interface CmsBlockRepositoryV1SavePutBody {
    /**
     *
     * @type {CmsDataBlockInterface}
     * @memberof CmsBlockRepositoryV1SavePutBody
     */
    block: CmsDataBlockInterface;
}

/**
 * CMS block interface.
 * @export
 * @interface CmsDataBlockInterface
 */
export interface CmsDataBlockInterface {
    /**
     * ID
     * @type {number}
     * @memberof CmsDataBlockInterface
     */
    id?: number;
    /**
     * Identifier
     * @type {string}
     * @memberof CmsDataBlockInterface
     */
    identifier: string;
    /**
     * Title
     * @type {string}
     * @memberof CmsDataBlockInterface
     */
    title?: string;
    /**
     * Content
     * @type {string}
     * @memberof CmsDataBlockInterface
     */
    content?: string;
    /**
     * Creation time
     * @type {string}
     * @memberof CmsDataBlockInterface
     */
    creationTime?: string;
    /**
     * Update time
     * @type {string}
     * @memberof CmsDataBlockInterface
     */
    updateTime?: string;
    /**
     * Active
     * @type {boolean}
     * @memberof CmsDataBlockInterface
     */
    active?: boolean;
}

/**
 * Interface for cms block search results.
 * @export
 * @interface CmsDataBlockSearchResultsInterface
 */
export interface CmsDataBlockSearchResultsInterface {
    /**
     * Blocks list.
     * @type {Array<CmsDataBlockInterface>}
     * @memberof CmsDataBlockSearchResultsInterface
     */
    items: Array<CmsDataBlockInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CmsDataBlockSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CmsDataBlockSearchResultsInterface
     */
    totalCount: number;
}

/**
 * CMS page interface.
 * @export
 * @interface CmsDataPageInterface
 */
export interface CmsDataPageInterface {
    /**
     * ID
     * @type {number}
     * @memberof CmsDataPageInterface
     */
    id?: number;
    /**
     * Identifier
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    identifier: string;
    /**
     * Title
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    title?: string;
    /**
     * Page layout
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    pageLayout?: string;
    /**
     * Meta title
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    metaTitle?: string;
    /**
     * Meta keywords
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    metaKeywords?: string;
    /**
     * Meta description
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    metaDescription?: string;
    /**
     * Content heading
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    contentHeading?: string;
    /**
     * Content
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    content?: string;
    /**
     * Creation time
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    creationTime?: string;
    /**
     * Update time
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    updateTime?: string;
    /**
     * Sort order
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    sortOrder?: string;
    /**
     * Layout update xml
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    layoutUpdateXml?: string;
    /**
     * Custom theme
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    customTheme?: string;
    /**
     * Custom root template
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    customRootTemplate?: string;
    /**
     * Custom layout update xml
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    customLayoutUpdateXml?: string;
    /**
     * Custom theme from
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    customThemeFrom?: string;
    /**
     * Custom theme to
     * @type {string}
     * @memberof CmsDataPageInterface
     */
    customThemeTo?: string;
    /**
     * Active
     * @type {boolean}
     * @memberof CmsDataPageInterface
     */
    active?: boolean;
}

/**
 * Interface for cms page search results.
 * @export
 * @interface CmsDataPageSearchResultsInterface
 */
export interface CmsDataPageSearchResultsInterface {
    /**
     * Pages list.
     * @type {Array<CmsDataPageInterface>}
     * @memberof CmsDataPageSearchResultsInterface
     */
    items: Array<CmsDataPageInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CmsDataPageSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CmsDataPageSearchResultsInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface CmsPageRepositoryV1SavePostBody
 */
export interface CmsPageRepositoryV1SavePostBody {
    /**
     *
     * @type {CmsDataPageInterface}
     * @memberof CmsPageRepositoryV1SavePostBody
     */
    page: CmsDataPageInterface;
}

/**
 *
 * @export
 * @interface CmsPageRepositoryV1SavePutBody
 */
export interface CmsPageRepositoryV1SavePutBody {
    /**
     *
     * @type {CmsDataPageInterface}
     * @memberof CmsPageRepositoryV1SavePutBody
     */
    page: CmsDataPageInterface;
}

/**
 *
 * @export
 * @interface CompanyAclV1AssignRolesPutBody
 */
export interface CompanyAclV1AssignRolesPutBody {
    /**
     *
     * @type {number}
     * @memberof CompanyAclV1AssignRolesPutBody
     */
    userId: number;
    /**
     *
     * @type {Array<CompanyDataRoleInterface>}
     * @memberof CompanyAclV1AssignRolesPutBody
     */
    roles: Array<CompanyDataRoleInterface>;
}

/**
 *
 * @export
 * @interface CompanyCompanyHierarchyV1MoveNodePutBody
 */
export interface CompanyCompanyHierarchyV1MoveNodePutBody {
    /**
     *
     * @type {number}
     * @memberof CompanyCompanyHierarchyV1MoveNodePutBody
     */
    newParentId: number;
}

/**
 *
 * @export
 * @interface CompanyCompanyRepositoryV1SavePostBody
 */
export interface CompanyCompanyRepositoryV1SavePostBody {
    /**
     *
     * @type {CompanyDataCompanyInterface}
     * @memberof CompanyCompanyRepositoryV1SavePostBody
     */
    company: CompanyDataCompanyInterface;
}

/**
 *
 * @export
 * @interface CompanyCompanyRepositoryV1SavePutBody
 */
export interface CompanyCompanyRepositoryV1SavePutBody {
    /**
     *
     * @type {CompanyDataCompanyInterface}
     * @memberof CompanyCompanyRepositoryV1SavePutBody
     */
    company: CompanyDataCompanyInterface;
}

/**
 *
 * @export
 * @interface CompanyCreditCreditBalanceManagementV1DecreasePostBody
 */
export interface CompanyCreditCreditBalanceManagementV1DecreasePostBody {
    /**
     *
     * @type {number}
     * @memberof CompanyCreditCreditBalanceManagementV1DecreasePostBody
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof CompanyCreditCreditBalanceManagementV1DecreasePostBody
     */
    currency: string;
    /**
     *
     * @type {number}
     * @memberof CompanyCreditCreditBalanceManagementV1DecreasePostBody
     */
    operationType: number;
    /**
     * [optional]
     * @type {string}
     * @memberof CompanyCreditCreditBalanceManagementV1DecreasePostBody
     */
    comment?: string;
    /**
     *
     * @type {CompanyCreditDataCreditBalanceOptionsInterface}
     * @memberof CompanyCreditCreditBalanceManagementV1DecreasePostBody
     */
    options?: CompanyCreditDataCreditBalanceOptionsInterface;
}

/**
 *
 * @export
 * @interface CompanyCreditCreditBalanceManagementV1IncreasePostBody
 */
export interface CompanyCreditCreditBalanceManagementV1IncreasePostBody {
    /**
     *
     * @type {number}
     * @memberof CompanyCreditCreditBalanceManagementV1IncreasePostBody
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof CompanyCreditCreditBalanceManagementV1IncreasePostBody
     */
    currency: string;
    /**
     *
     * @type {number}
     * @memberof CompanyCreditCreditBalanceManagementV1IncreasePostBody
     */
    operationType: number;
    /**
     * [optional]
     * @type {string}
     * @memberof CompanyCreditCreditBalanceManagementV1IncreasePostBody
     */
    comment?: string;
    /**
     *
     * @type {CompanyCreditDataCreditBalanceOptionsInterface}
     * @memberof CompanyCreditCreditBalanceManagementV1IncreasePostBody
     */
    options?: CompanyCreditDataCreditBalanceOptionsInterface;
}

/**
 *
 * @export
 * @interface CompanyCreditCreditHistoryManagementV1UpdatePutBody
 */
export interface CompanyCreditCreditHistoryManagementV1UpdatePutBody {
    /**
     * [optional]
     * @type {string}
     * @memberof CompanyCreditCreditHistoryManagementV1UpdatePutBody
     */
    purchaseOrder?: string;
    /**
     * [optional]
     * @type {string}
     * @memberof CompanyCreditCreditHistoryManagementV1UpdatePutBody
     */
    comment?: string;
}

/**
 *
 * @export
 * @interface CompanyCreditCreditLimitRepositoryV1SavePutBody
 */
export interface CompanyCreditCreditLimitRepositoryV1SavePutBody {
    /**
     *
     * @type {CompanyCreditDataCreditLimitInterface}
     * @memberof CompanyCreditCreditLimitRepositoryV1SavePutBody
     */
    creditLimit: CompanyCreditDataCreditLimitInterface;
}

/**
 * Credit balance data transfer object interface.
 * @export
 * @interface CompanyCreditDataCreditBalanceOptionsInterface
 */
export interface CompanyCreditDataCreditBalanceOptionsInterface {
    /**
     * Purchase order number.
     * @type {string}
     * @memberof CompanyCreditDataCreditBalanceOptionsInterface
     */
    purchaseOrder: string;
    /**
     * Order increment.
     * @type {string}
     * @memberof CompanyCreditDataCreditBalanceOptionsInterface
     */
    orderIncrement: string;
    /**
     * Currency display.
     * @type {string}
     * @memberof CompanyCreditDataCreditBalanceOptionsInterface
     */
    currencyDisplay: string;
    /**
     * Currency base.
     * @type {string}
     * @memberof CompanyCreditDataCreditBalanceOptionsInterface
     */
    currencyBase: string;
}

/**
 * Credit Data interface.
 * @export
 * @interface CompanyCreditDataCreditDataInterface
 */
export interface CompanyCreditDataCreditDataInterface {
    /**
     * ID.
     * @type {number}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    id?: number;
    /**
     * Company id.
     * @type {number}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    companyId?: number;
    /**
     * Credit Limit.
     * @type {number}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    creditLimit?: number;
    /**
     * Balance.
     * @type {number}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    balance?: number;
    /**
     * Currency Code.
     * @type {string}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    currencyCode?: string;
    /**
     * Exceed Limit.
     * @type {boolean}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    exceedLimit: boolean;
    /**
     * Available Limit.
     * @type {number}
     * @memberof CompanyCreditDataCreditDataInterface
     */
    availableLimit?: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\CompanyCredit\\Api\\Data\\CreditLimitInterface
 * @export
 * @interface CompanyCreditDataCreditLimitExtensionInterface
 */
export interface CompanyCreditDataCreditLimitExtensionInterface {
}

/**
 * Credit Limit data transfer object interface.
 * @export
 * @interface CompanyCreditDataCreditLimitInterface
 */
export interface CompanyCreditDataCreditLimitInterface {
    /**
     * ID.
     * @type {number}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    id?: number;
    /**
     * Company id.
     * @type {number}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    companyId?: number;
    /**
     * Credit Limit.
     * @type {number}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    creditLimit?: number;
    /**
     * Balance.
     * @type {number}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    balance?: number;
    /**
     * Currency Code.
     * @type {string}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    currencyCode?: string;
    /**
     * Exceed Limit.
     * @type {boolean}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    exceedLimit: boolean;
    /**
     * Available Limit.
     * @type {number}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    availableLimit?: number;
    /**
     * Credit comment for company credit history.
     * @type {string}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    creditComment?: string;
    /**
     *
     * @type {CompanyCreditDataCreditLimitExtensionInterface}
     * @memberof CompanyCreditDataCreditLimitInterface
     */
    extensionAttributes?: CompanyCreditDataCreditLimitExtensionInterface;
}

/**
 * Interface for Credit Limit search results.
 * @export
 * @interface CompanyCreditDataCreditLimitSearchResultsInterface
 */
export interface CompanyCreditDataCreditLimitSearchResultsInterface {
    /**
     * Credit Limit list.
     * @type {Array<CompanyCreditDataCreditDataInterface>}
     * @memberof CompanyCreditDataCreditLimitSearchResultsInterface
     */
    items: Array<CompanyCreditDataCreditDataInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CompanyCreditDataCreditLimitSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CompanyCreditDataCreditLimitSearchResultsInterface
     */
    totalCount: number;
}

/**
 * History data transfer object interface.
 * @export
 * @interface CompanyCreditDataHistoryDataInterface
 */
export interface CompanyCreditDataHistoryDataInterface {
    /**
     * ID.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    id?: number;
    /**
     * Company credit id.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    companyCreditId?: number;
    /**
     * User Id.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    userId?: number;
    /**
     * User type: integration, admin, customer.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    userType?: number;
    /**
     * Currency code of credit.
     * @type {string}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    currencyCredit?: string;
    /**
     * Currency code of operation.
     * @type {string}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    currencyOperation?: string;
    /**
     * Currency rate between credit and operation currencies.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    rate: number;
    /**
     * Rate between credit and base currencies.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    rateCredit?: number;
    /**
     * Amount.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    amount: number;
    /**
     * Outstanding balance.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    balance: number;
    /**
     * Credit limit.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    creditLimit: number;
    /**
     * Available limit.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    availableLimit?: number;
    /**
     * Type of operation.
     * @type {number}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    type?: number;
    /**
     * Operation datetime.
     * @type {string}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    datetime?: string;
    /**
     * Purchase Order number.
     * @type {string}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    purchaseOrder?: string;
    /**
     * Comment.
     * @type {string}
     * @memberof CompanyCreditDataHistoryDataInterface
     */
    comment?: string;
}

/**
 * Interface for History search results.
 * @export
 * @interface CompanyCreditDataHistorySearchResultsInterface
 */
export interface CompanyCreditDataHistorySearchResultsInterface {
    /**
     * History list.
     * @type {Array<CompanyCreditDataHistoryDataInterface>}
     * @memberof CompanyCreditDataHistorySearchResultsInterface
     */
    items: Array<CompanyCreditDataHistoryDataInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CompanyCreditDataHistorySearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CompanyCreditDataHistorySearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Company\\Api\\Data\\CompanyCustomerInterface
 * @export
 * @interface CompanyDataCompanyCustomerExtensionInterface
 */
export interface CompanyDataCompanyCustomerExtensionInterface {
}

/**
 * Extended customer custom attributes interface.
 * @export
 * @interface CompanyDataCompanyCustomerInterface
 */
export interface CompanyDataCompanyCustomerInterface {
    /**
     * Customer ID.
     * @type {number}
     * @memberof CompanyDataCompanyCustomerInterface
     */
    customerId?: number;
    /**
     * Company ID.
     * @type {number}
     * @memberof CompanyDataCompanyCustomerInterface
     */
    companyId?: number;
    /**
     * Get job title.
     * @type {string}
     * @memberof CompanyDataCompanyCustomerInterface
     */
    jobTitle?: string;
    /**
     * Customer status.
     * @type {number}
     * @memberof CompanyDataCompanyCustomerInterface
     */
    status?: number;
    /**
     * Get telephone.
     * @type {string}
     * @memberof CompanyDataCompanyCustomerInterface
     */
    telephone?: string;
    /**
     *
     * @type {CompanyDataCompanyCustomerExtensionInterface}
     * @memberof CompanyDataCompanyCustomerInterface
     */
    extensionAttributes?: CompanyDataCompanyCustomerExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Company\\Api\\Data\\CompanyInterface
 * @export
 * @interface CompanyDataCompanyExtensionInterface
 */
export interface CompanyDataCompanyExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof CompanyDataCompanyExtensionInterface
     */
    applicablePaymentMethod?: number;
    /**
     *
     * @type {string}
     * @memberof CompanyDataCompanyExtensionInterface
     */
    availablePaymentMethods?: string;
    /**
     *
     * @type {number}
     * @memberof CompanyDataCompanyExtensionInterface
     */
    useConfigSettings?: number;
    /**
     *
     * @type {NegotiableQuoteDataCompanyQuoteConfigInterface}
     * @memberof CompanyDataCompanyExtensionInterface
     */
    quoteConfig?: NegotiableQuoteDataCompanyQuoteConfigInterface;
}

/**
 * Interface for Company entity.
 * @export
 * @interface CompanyDataCompanyInterface
 */
export interface CompanyDataCompanyInterface {
    /**
     * Id.
     * @type {number}
     * @memberof CompanyDataCompanyInterface
     */
    id?: number;
    /**
     * Status.
     * @type {number}
     * @memberof CompanyDataCompanyInterface
     */
    status?: number;
    /**
     * Company name.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    companyName?: string;
    /**
     * Legal name.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    legalName?: string;
    /**
     * Company email.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    companyEmail?: string;
    /**
     * Vat tax id.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    vatTaxId?: string;
    /**
     * Reseller Id.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    resellerId?: string;
    /**
     * Comment.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    comment?: string;
    /**
     * Street.
     * @type {Array<string>}
     * @memberof CompanyDataCompanyInterface
     */
    street: Array<string>;
    /**
     * City.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    city?: string;
    /**
     * Country.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    countryId?: string;
    /**
     * Region.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    region?: string;
    /**
     * Region Id.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    regionId?: string;
    /**
     * Postcode.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    postcode?: string;
    /**
     * Telephone.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    telephone?: string;
    /**
     * Customer Group Id.
     * @type {number}
     * @memberof CompanyDataCompanyInterface
     */
    customerGroupId: number;
    /**
     * Sales Representative Id.
     * @type {number}
     * @memberof CompanyDataCompanyInterface
     */
    salesRepresentativeId: number;
    /**
     * Reject Reason.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    rejectReason: string;
    /**
     * Rejected at time.
     * @type {string}
     * @memberof CompanyDataCompanyInterface
     */
    rejectedAt: string;
    /**
     * Company admin customer id.
     * @type {number}
     * @memberof CompanyDataCompanyInterface
     */
    superUserId: number;
    /**
     *
     * @type {CompanyDataCompanyExtensionInterface}
     * @memberof CompanyDataCompanyInterface
     */
    extensionAttributes?: CompanyDataCompanyExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Company\\Api\\Data\\CompanyOrderInterface
 * @export
 * @interface CompanyDataCompanyOrderExtensionInterface
 */
export interface CompanyDataCompanyOrderExtensionInterface {
}

/**
 * Order company extension attributes interface. Adds new company attributes to orders.
 * @export
 * @interface CompanyDataCompanyOrderInterface
 */
export interface CompanyDataCompanyOrderInterface {
    /**
     * Order ID.
     * @type {number}
     * @memberof CompanyDataCompanyOrderInterface
     */
    orderId?: number;
    /**
     * Company ID.
     * @type {number}
     * @memberof CompanyDataCompanyOrderInterface
     */
    companyId?: number;
    /**
     * Company name.
     * @type {string}
     * @memberof CompanyDataCompanyOrderInterface
     */
    companyName?: string;
    /**
     *
     * @type {CompanyDataCompanyOrderExtensionInterface}
     * @memberof CompanyDataCompanyOrderInterface
     */
    extensionAttributes?: CompanyDataCompanyOrderExtensionInterface;
}

/**
 * Interface for company search results
 * @export
 * @interface CompanyDataCompanySearchResultsInterface
 */
export interface CompanyDataCompanySearchResultsInterface {
    /**
     * Companies list
     * @type {Array<CompanyDataCompanyInterface>}
     * @memberof CompanyDataCompanySearchResultsInterface
     */
    items: Array<CompanyDataCompanyInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CompanyDataCompanySearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CompanyDataCompanySearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Company\\Api\\Data\\HierarchyInterface
 * @export
 * @interface CompanyDataHierarchyExtensionInterface
 */
export interface CompanyDataHierarchyExtensionInterface {
}

/**
 * Company hierarchy DTO interface for WebAPI.
 * @export
 * @interface CompanyDataHierarchyInterface
 */
export interface CompanyDataHierarchyInterface {
    /**
     * Structure ID.
     * @type {number}
     * @memberof CompanyDataHierarchyInterface
     */
    structureId?: number;
    /**
     * Entity ID.
     * @type {number}
     * @memberof CompanyDataHierarchyInterface
     */
    entityId?: number;
    /**
     * Entity type.
     * @type {string}
     * @memberof CompanyDataHierarchyInterface
     */
    entityType?: string;
    /**
     * Structure parent ID.
     * @type {number}
     * @memberof CompanyDataHierarchyInterface
     */
    structureParentId?: number;
    /**
     *
     * @type {CompanyDataHierarchyExtensionInterface}
     * @memberof CompanyDataHierarchyInterface
     */
    extensionAttributes?: CompanyDataHierarchyExtensionInterface;
}

/**
 * Permission interface.
 * @export
 * @interface CompanyDataPermissionInterface
 */
export interface CompanyDataPermissionInterface {
    /**
     * Id.
     * @type {number}
     * @memberof CompanyDataPermissionInterface
     */
    id?: number;
    /**
     * Role id.
     * @type {number}
     * @memberof CompanyDataPermissionInterface
     */
    roleId?: number;
    /**
     * Resource id.
     * @type {string}
     * @memberof CompanyDataPermissionInterface
     */
    resourceId: string;
    /**
     * Permission.
     * @type {string}
     * @memberof CompanyDataPermissionInterface
     */
    permission: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Company\\Api\\Data\\RoleInterface
 * @export
 * @interface CompanyDataRoleExtensionInterface
 */
export interface CompanyDataRoleExtensionInterface {
}

/**
 * Role data transfer object interface.
 * @export
 * @interface CompanyDataRoleInterface
 */
export interface CompanyDataRoleInterface {
    /**
     * Role id.
     * @type {number}
     * @memberof CompanyDataRoleInterface
     */
    id?: number;
    /**
     * Role name.
     * @type {string}
     * @memberof CompanyDataRoleInterface
     */
    roleName?: string;
    /**
     * Permissions.
     * @type {Array<CompanyDataPermissionInterface>}
     * @memberof CompanyDataRoleInterface
     */
    permissions: Array<CompanyDataPermissionInterface>;
    /**
     * Company id.
     * @type {number}
     * @memberof CompanyDataRoleInterface
     */
    companyId?: number;
    /**
     *
     * @type {CompanyDataRoleExtensionInterface}
     * @memberof CompanyDataRoleInterface
     */
    extensionAttributes?: CompanyDataRoleExtensionInterface;
}

/**
 * Interface for role search results.
 * @export
 * @interface CompanyDataRoleSearchResultsInterface
 */
export interface CompanyDataRoleSearchResultsInterface {
    /**
     * Roles list.
     * @type {Array<CompanyDataRoleInterface>}
     * @memberof CompanyDataRoleSearchResultsInterface
     */
    items: Array<CompanyDataRoleInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CompanyDataRoleSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CompanyDataRoleSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Company\\Api\\Data\\TeamInterface
 * @export
 * @interface CompanyDataTeamExtensionInterface
 */
export interface CompanyDataTeamExtensionInterface {
}

/**
 * Team interface
 * @export
 * @interface CompanyDataTeamInterface
 */
export interface CompanyDataTeamInterface {
    /**
     * ID
     * @type {number}
     * @memberof CompanyDataTeamInterface
     */
    id?: number;
    /**
     * Name
     * @type {string}
     * @memberof CompanyDataTeamInterface
     */
    name?: string;
    /**
     * Description
     * @type {string}
     * @memberof CompanyDataTeamInterface
     */
    description?: string;
    /**
     *
     * @type {CompanyDataTeamExtensionInterface}
     * @memberof CompanyDataTeamInterface
     */
    extensionAttributes?: CompanyDataTeamExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CompanyDataTeamInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * Interface for company team search results
 * @export
 * @interface CompanyDataTeamSearchResultsInterface
 */
export interface CompanyDataTeamSearchResultsInterface {
    /**
     * Teams list
     * @type {Array<CompanyDataTeamInterface>}
     * @memberof CompanyDataTeamSearchResultsInterface
     */
    items: Array<CompanyDataTeamInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CompanyDataTeamSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CompanyDataTeamSearchResultsInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface CompanyRoleRepositoryV1SavePostBody
 */
export interface CompanyRoleRepositoryV1SavePostBody {
    /**
     *
     * @type {CompanyDataRoleInterface}
     * @memberof CompanyRoleRepositoryV1SavePostBody
     */
    role: CompanyDataRoleInterface;
}

/**
 *
 * @export
 * @interface CompanyRoleRepositoryV1SavePutBody
 */
export interface CompanyRoleRepositoryV1SavePutBody {
    /**
     *
     * @type {CompanyDataRoleInterface}
     * @memberof CompanyRoleRepositoryV1SavePutBody
     */
    role: CompanyDataRoleInterface;
}

/**
 *
 * @export
 * @interface CompanyTeamRepositoryV1CreatePostBody
 */
export interface CompanyTeamRepositoryV1CreatePostBody {
    /**
     *
     * @type {CompanyDataTeamInterface}
     * @memberof CompanyTeamRepositoryV1CreatePostBody
     */
    team: CompanyDataTeamInterface;
}

/**
 *
 * @export
 * @interface CompanyTeamRepositoryV1SavePutBody
 */
export interface CompanyTeamRepositoryV1SavePutBody {
    /**
     *
     * @type {CompanyDataTeamInterface}
     * @memberof CompanyTeamRepositoryV1SavePutBody
     */
    team: CompanyDataTeamInterface;
}

/**
 *
 * @export
 * @interface ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody
 */
export interface ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody {
    /**
     *
     * @type {CatalogDataProductInterface}
     * @memberof ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody
     */
    product: CatalogDataProductInterface;
    /**
     *
     * @type {Array<ConfigurableProductDataOptionInterface>}
     * @memberof ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody
     */
    options: Array<ConfigurableProductDataOptionInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\ConfigurableProduct\\Api\\Data\\ConfigurableItemOptionValueInterface
 * @export
 * @interface ConfigurableProductDataConfigurableItemOptionValueExtensionInterface
 */
export interface ConfigurableProductDataConfigurableItemOptionValueExtensionInterface {
}

/**
 * Interface ConfigurableItemOptionValueInterface
 * @export
 * @interface ConfigurableProductDataConfigurableItemOptionValueInterface
 */
export interface ConfigurableProductDataConfigurableItemOptionValueInterface {
    /**
     * Option SKU
     * @type {string}
     * @memberof ConfigurableProductDataConfigurableItemOptionValueInterface
     */
    optionId: string;
    /**
     * Item id
     * @type {number}
     * @memberof ConfigurableProductDataConfigurableItemOptionValueInterface
     */
    optionValue?: number;
    /**
     *
     * @type {ConfigurableProductDataConfigurableItemOptionValueExtensionInterface}
     * @memberof ConfigurableProductDataConfigurableItemOptionValueInterface
     */
    extensionAttributes?: ConfigurableProductDataConfigurableItemOptionValueExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\ConfigurableProduct\\Api\\Data\\OptionInterface
 * @export
 * @interface ConfigurableProductDataOptionExtensionInterface
 */
export interface ConfigurableProductDataOptionExtensionInterface {
}

/**
 * Interface OptionInterface
 * @export
 * @interface ConfigurableProductDataOptionInterface
 */
export interface ConfigurableProductDataOptionInterface {
    /**
     *
     * @type {number}
     * @memberof ConfigurableProductDataOptionInterface
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof ConfigurableProductDataOptionInterface
     */
    attributeId?: string;
    /**
     *
     * @type {string}
     * @memberof ConfigurableProductDataOptionInterface
     */
    label?: string;
    /**
     *
     * @type {number}
     * @memberof ConfigurableProductDataOptionInterface
     */
    position?: number;
    /**
     *
     * @type {boolean}
     * @memberof ConfigurableProductDataOptionInterface
     */
    isUseDefault?: boolean;
    /**
     *
     * @type {Array<ConfigurableProductDataOptionValueInterface>}
     * @memberof ConfigurableProductDataOptionInterface
     */
    values?: Array<ConfigurableProductDataOptionValueInterface>;
    /**
     *
     * @type {ConfigurableProductDataOptionExtensionInterface}
     * @memberof ConfigurableProductDataOptionInterface
     */
    extensionAttributes?: ConfigurableProductDataOptionExtensionInterface;
    /**
     *
     * @type {number}
     * @memberof ConfigurableProductDataOptionInterface
     */
    productId?: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\ConfigurableProduct\\Api\\Data\\OptionValueInterface
 * @export
 * @interface ConfigurableProductDataOptionValueExtensionInterface
 */
export interface ConfigurableProductDataOptionValueExtensionInterface {
}

/**
 * Interface OptionValueInterface
 * @export
 * @interface ConfigurableProductDataOptionValueInterface
 */
export interface ConfigurableProductDataOptionValueInterface {
    /**
     *
     * @type {number}
     * @memberof ConfigurableProductDataOptionValueInterface
     */
    valueIndex: number;
    /**
     *
     * @type {ConfigurableProductDataOptionValueExtensionInterface}
     * @memberof ConfigurableProductDataOptionValueInterface
     */
    extensionAttributes?: ConfigurableProductDataOptionValueExtensionInterface;
}

/**
 *
 * @export
 * @interface ConfigurableProductLinkManagementV1AddChildPostBody
 */
export interface ConfigurableProductLinkManagementV1AddChildPostBody {
    /**
     *
     * @type {string}
     * @memberof ConfigurableProductLinkManagementV1AddChildPostBody
     */
    childSku: string;
}

/**
 *
 * @export
 * @interface ConfigurableProductOptionRepositoryV1SavePostBody
 */
export interface ConfigurableProductOptionRepositoryV1SavePostBody {
    /**
     *
     * @type {ConfigurableProductDataOptionInterface}
     * @memberof ConfigurableProductOptionRepositoryV1SavePostBody
     */
    option: ConfigurableProductDataOptionInterface;
}

/**
 *
 * @export
 * @interface ConfigurableProductOptionRepositoryV1SavePutBody
 */
export interface ConfigurableProductOptionRepositoryV1SavePutBody {
    /**
     *
     * @type {ConfigurableProductDataOptionInterface}
     * @memberof ConfigurableProductOptionRepositoryV1SavePutBody
     */
    option: ConfigurableProductDataOptionInterface;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1ActivateByIdPutBody
 */
export interface CustomerAccountManagementV1ActivateByIdPutBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ActivateByIdPutBody
     */
    confirmationKey: string;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1ActivatePutBody
 */
export interface CustomerAccountManagementV1ActivatePutBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ActivatePutBody
     */
    confirmationKey: string;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1ChangePasswordByIdPutBody
 */
export interface CustomerAccountManagementV1ChangePasswordByIdPutBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ChangePasswordByIdPutBody
     */
    currentPassword: string;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ChangePasswordByIdPutBody
     */
    newPassword: string;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1CreateAccountPostBody
 */
export interface CustomerAccountManagementV1CreateAccountPostBody {
    /**
     *
     * @type {CustomerDataCustomerInterface}
     * @memberof CustomerAccountManagementV1CreateAccountPostBody
     */
    customer: CustomerDataCustomerInterface;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1CreateAccountPostBody
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1CreateAccountPostBody
     */
    redirectUrl?: string;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1InitiatePasswordResetPutBody
 */
export interface CustomerAccountManagementV1InitiatePasswordResetPutBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1InitiatePasswordResetPutBody
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1InitiatePasswordResetPutBody
     */
    template: string;
    /**
     *
     * @type {number}
     * @memberof CustomerAccountManagementV1InitiatePasswordResetPutBody
     */
    websiteId?: number;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1IsEmailAvailablePostBody
 */
export interface CustomerAccountManagementV1IsEmailAvailablePostBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1IsEmailAvailablePostBody
     */
    customerEmail: string;
    /**
     * If not set, will use the current websiteId
     * @type {number}
     * @memberof CustomerAccountManagementV1IsEmailAvailablePostBody
     */
    websiteId?: number;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1ResendConfirmationPostBody
 */
export interface CustomerAccountManagementV1ResendConfirmationPostBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ResendConfirmationPostBody
     */
    email: string;
    /**
     *
     * @type {number}
     * @memberof CustomerAccountManagementV1ResendConfirmationPostBody
     */
    websiteId: number;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ResendConfirmationPostBody
     */
    redirectUrl?: string;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1ResetPasswordPostBody
 */
export interface CustomerAccountManagementV1ResetPasswordPostBody {
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ResetPasswordPostBody
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ResetPasswordPostBody
     */
    resetToken: string;
    /**
     *
     * @type {string}
     * @memberof CustomerAccountManagementV1ResetPasswordPostBody
     */
    newPassword: string;
}

/**
 *
 * @export
 * @interface CustomerAccountManagementV1ValidatePutBody
 */
export interface CustomerAccountManagementV1ValidatePutBody {
    /**
     *
     * @type {CustomerDataCustomerInterface}
     * @memberof CustomerAccountManagementV1ValidatePutBody
     */
    customer: CustomerDataCustomerInterface;
}

/**
 *
 * @export
 * @interface CustomerCustomerRepositoryV1SavePutBody
 */
export interface CustomerCustomerRepositoryV1SavePutBody {
    /**
     *
     * @type {CustomerDataCustomerInterface}
     * @memberof CustomerCustomerRepositoryV1SavePutBody
     */
    customer: CustomerDataCustomerInterface;
    /**
     *
     * @type {string}
     * @memberof CustomerCustomerRepositoryV1SavePutBody
     */
    passwordHash?: string;
}

/**
 *
 * @export
 * @interface CustomerCustomerRepositoryV1SavePutBody1
 */
export interface CustomerCustomerRepositoryV1SavePutBody1 {
    /**
     *
     * @type {CustomerDataCustomerInterface}
     * @memberof CustomerCustomerRepositoryV1SavePutBody1
     */
    customer: CustomerDataCustomerInterface;
    /**
     *
     * @type {string}
     * @memberof CustomerCustomerRepositoryV1SavePutBody1
     */
    passwordHash?: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Customer\\Api\\Data\\AddressInterface
 * @export
 * @interface CustomerDataAddressExtensionInterface
 */
export interface CustomerDataAddressExtensionInterface {
}

/**
 * Customer address interface.
 * @export
 * @interface CustomerDataAddressInterface
 */
export interface CustomerDataAddressInterface {
    /**
     * ID
     * @type {number}
     * @memberof CustomerDataAddressInterface
     */
    id?: number;
    /**
     * Customer ID
     * @type {number}
     * @memberof CustomerDataAddressInterface
     */
    customerId?: number;
    /**
     *
     * @type {CustomerDataRegionInterface}
     * @memberof CustomerDataAddressInterface
     */
    region?: CustomerDataRegionInterface;
    /**
     * Region ID
     * @type {number}
     * @memberof CustomerDataAddressInterface
     */
    regionId?: number;
    /**
     * Country code in ISO_3166-2 format
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    countryId?: string;
    /**
     * Street
     * @type {Array<string>}
     * @memberof CustomerDataAddressInterface
     */
    street?: Array<string>;
    /**
     * Company
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    company?: string;
    /**
     * Telephone number
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    telephone?: string;
    /**
     * Fax number
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    fax?: string;
    /**
     * Postcode
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    postcode?: string;
    /**
     * City name
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    city?: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    firstname?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    lastname?: string;
    /**
     * Middle name
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    middlename?: string;
    /**
     * Prefix
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    prefix?: string;
    /**
     * Suffix
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    suffix?: string;
    /**
     * Vat id
     * @type {string}
     * @memberof CustomerDataAddressInterface
     */
    vatId?: string;
    /**
     * If this address is default shipping address.
     * @type {boolean}
     * @memberof CustomerDataAddressInterface
     */
    defaultShipping?: boolean;
    /**
     * If this address is default billing address
     * @type {boolean}
     * @memberof CustomerDataAddressInterface
     */
    defaultBilling?: boolean;
    /**
     *
     * @type {CustomerDataAddressExtensionInterface}
     * @memberof CustomerDataAddressInterface
     */
    extensionAttributes?: CustomerDataAddressExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CustomerDataAddressInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * Customer attribute metadata interface.
 * @export
 * @interface CustomerDataAttributeMetadataInterface
 */
export interface CustomerDataAttributeMetadataInterface {
    /**
     * HTML for input element.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    frontendInput: string;
    /**
     * Template used for input (e.g. \"date\")
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    inputFilter: string;
    /**
     * Label of the store.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    storeLabel: string;
    /**
     * Validation rules.
     * @type {Array<CustomerDataValidationRuleInterface>}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    validationRules: Array<CustomerDataValidationRuleInterface>;
    /**
     * Of lines of the attribute value.
     * @type {number}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    multilineCount: number;
    /**
     * Attribute is visible on frontend.
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    visible: boolean;
    /**
     * Attribute is required.
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    required: boolean;
    /**
     * Data model for attribute.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    dataModel: string;
    /**
     * Options of the attribute (key => value pairs for select)
     * @type {Array<CustomerDataOptionInterface>}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    options: Array<CustomerDataOptionInterface>;
    /**
     * Class which is used to display the attribute on frontend.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    frontendClass: string;
    /**
     * Current attribute has been defined by a user.
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    userDefined: boolean;
    /**
     * Attributes sort order.
     * @type {number}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    sortOrder: number;
    /**
     * Label which supposed to be displayed on frontend.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    frontendLabel: string;
    /**
     * The note attribute for the element.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    note: string;
    /**
     * This is a system attribute.
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    system: boolean;
    /**
     * Backend type.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    backendType: string;
    /**
     * It is used in customer grid
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    isUsedInGrid?: boolean;
    /**
     * It is visible in customer grid
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    isVisibleInGrid?: boolean;
    /**
     * It is filterable in customer grid
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    isFilterableInGrid?: boolean;
    /**
     * It is searchable in customer grid
     * @type {boolean}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    isSearchableInGrid?: boolean;
    /**
     * Code of the attribute.
     * @type {string}
     * @memberof CustomerDataAttributeMetadataInterface
     */
    attributeCode: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Customer\\Api\\Data\\CustomerInterface
 * @export
 * @interface CustomerDataCustomerExtensionInterface
 */
export interface CustomerDataCustomerExtensionInterface {
    /**
     *
     * @type {CompanyDataCompanyCustomerInterface}
     * @memberof CustomerDataCustomerExtensionInterface
     */
    companyAttributes?: CompanyDataCompanyCustomerInterface;
    /**
     *
     * @type {boolean}
     * @memberof CustomerDataCustomerExtensionInterface
     */
    isSubscribed?: boolean;
}

/**
 * Customer interface.
 * @export
 * @interface CustomerDataCustomerInterface
 */
export interface CustomerDataCustomerInterface {
    /**
     * Customer id
     * @type {number}
     * @memberof CustomerDataCustomerInterface
     */
    id?: number;
    /**
     * Group id
     * @type {number}
     * @memberof CustomerDataCustomerInterface
     */
    groupId?: number;
    /**
     * Default billing address id
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    defaultBilling?: string;
    /**
     * Default shipping address id
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    defaultShipping?: string;
    /**
     * Confirmation
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    confirmation?: string;
    /**
     * Created at time
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    createdAt?: string;
    /**
     * Updated at time
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    updatedAt?: string;
    /**
     * Created in area
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    createdIn?: string;
    /**
     * Date of birth
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    dob?: string;
    /**
     * Email address
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    email: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    firstname: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    lastname: string;
    /**
     * Middle name
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    middlename?: string;
    /**
     * Prefix
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    prefix?: string;
    /**
     * Suffix
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    suffix?: string;
    /**
     * Gender
     * @type {number}
     * @memberof CustomerDataCustomerInterface
     */
    gender?: number;
    /**
     * Store id
     * @type {number}
     * @memberof CustomerDataCustomerInterface
     */
    storeId?: number;
    /**
     * Tax Vat
     * @type {string}
     * @memberof CustomerDataCustomerInterface
     */
    taxvat?: string;
    /**
     * Website id
     * @type {number}
     * @memberof CustomerDataCustomerInterface
     */
    websiteId?: number;
    /**
     * Customer addresses.
     * @type {Array<CustomerDataAddressInterface>}
     * @memberof CustomerDataCustomerInterface
     */
    addresses?: Array<CustomerDataAddressInterface>;
    /**
     * Disable auto group change flag.
     * @type {number}
     * @memberof CustomerDataCustomerInterface
     */
    disableAutoGroupChange?: number;
    /**
     *
     * @type {CustomerDataCustomerExtensionInterface}
     * @memberof CustomerDataCustomerInterface
     */
    extensionAttributes?: CustomerDataCustomerExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof CustomerDataCustomerInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * Interface for customer search results.
 * @export
 * @interface CustomerDataCustomerSearchResultsInterface
 */
export interface CustomerDataCustomerSearchResultsInterface {
    /**
     * Customers list.
     * @type {Array<CustomerDataCustomerInterface>}
     * @memberof CustomerDataCustomerSearchResultsInterface
     */
    items: Array<CustomerDataCustomerInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CustomerDataCustomerSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CustomerDataCustomerSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Customer\\Api\\Data\\GroupInterface
 * @export
 * @interface CustomerDataGroupExtensionInterface
 */
export interface CustomerDataGroupExtensionInterface {
}

/**
 * Customer group interface.
 * @export
 * @interface CustomerDataGroupInterface
 */
export interface CustomerDataGroupInterface {
    /**
     * Id
     * @type {number}
     * @memberof CustomerDataGroupInterface
     */
    id?: number;
    /**
     * Code
     * @type {string}
     * @memberof CustomerDataGroupInterface
     */
    code: string;
    /**
     * Tax class id
     * @type {number}
     * @memberof CustomerDataGroupInterface
     */
    taxClassId: number;
    /**
     * Tax class name
     * @type {string}
     * @memberof CustomerDataGroupInterface
     */
    taxClassName?: string;
    /**
     *
     * @type {CustomerDataGroupExtensionInterface}
     * @memberof CustomerDataGroupInterface
     */
    extensionAttributes?: CustomerDataGroupExtensionInterface;
}

/**
 * Interface for customer groups search results.
 * @export
 * @interface CustomerDataGroupSearchResultsInterface
 */
export interface CustomerDataGroupSearchResultsInterface {
    /**
     * Customer groups list.
     * @type {Array<CustomerDataGroupInterface>}
     * @memberof CustomerDataGroupSearchResultsInterface
     */
    items: Array<CustomerDataGroupInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof CustomerDataGroupSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof CustomerDataGroupSearchResultsInterface
     */
    totalCount: number;
}

/**
 * Option interface.
 * @export
 * @interface CustomerDataOptionInterface
 */
export interface CustomerDataOptionInterface {
    /**
     * Option label
     * @type {string}
     * @memberof CustomerDataOptionInterface
     */
    label: string;
    /**
     * Option value
     * @type {string}
     * @memberof CustomerDataOptionInterface
     */
    value?: string;
    /**
     * Nested options
     * @type {Array<CustomerDataOptionInterface>}
     * @memberof CustomerDataOptionInterface
     */
    options?: Array<CustomerDataOptionInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Customer\\Api\\Data\\RegionInterface
 * @export
 * @interface CustomerDataRegionExtensionInterface
 */
export interface CustomerDataRegionExtensionInterface {
}

/**
 * Customer address region interface.
 * @export
 * @interface CustomerDataRegionInterface
 */
export interface CustomerDataRegionInterface {
    /**
     * Region code
     * @type {string}
     * @memberof CustomerDataRegionInterface
     */
    regionCode: string;
    /**
     * Region
     * @type {string}
     * @memberof CustomerDataRegionInterface
     */
    region: string;
    /**
     * Region id
     * @type {number}
     * @memberof CustomerDataRegionInterface
     */
    regionId: number;
    /**
     *
     * @type {CustomerDataRegionExtensionInterface}
     * @memberof CustomerDataRegionInterface
     */
    extensionAttributes?: CustomerDataRegionExtensionInterface;
}

/**
 * Validation results interface.
 * @export
 * @interface CustomerDataValidationResultsInterface
 */
export interface CustomerDataValidationResultsInterface {
    /**
     * If the provided data is valid.
     * @type {boolean}
     * @memberof CustomerDataValidationResultsInterface
     */
    valid: boolean;
    /**
     * Error messages as array in case of validation failure, else return empty array.
     * @type {Array<string>}
     * @memberof CustomerDataValidationResultsInterface
     */
    messages: Array<string>;
}

/**
 * Validation rule interface.
 * @export
 * @interface CustomerDataValidationRuleInterface
 */
export interface CustomerDataValidationRuleInterface {
    /**
     * Validation rule name
     * @type {string}
     * @memberof CustomerDataValidationRuleInterface
     */
    name: string;
    /**
     * Validation rule value
     * @type {string}
     * @memberof CustomerDataValidationRuleInterface
     */
    value: string;
}

/**
 *
 * @export
 * @interface CustomerGroupRepositoryV1SavePostBody
 */
export interface CustomerGroupRepositoryV1SavePostBody {
    /**
     *
     * @type {CustomerDataGroupInterface}
     * @memberof CustomerGroupRepositoryV1SavePostBody
     */
    group: CustomerDataGroupInterface;
}

/**
 *
 * @export
 * @interface CustomerGroupRepositoryV1SavePutBody
 */
export interface CustomerGroupRepositoryV1SavePutBody {
    /**
     *
     * @type {CustomerDataGroupInterface}
     * @memberof CustomerGroupRepositoryV1SavePutBody
     */
    group: CustomerDataGroupInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Directory\\Api\\Data\\CountryInformationInterface
 * @export
 * @interface DirectoryDataCountryInformationExtensionInterface
 */
export interface DirectoryDataCountryInformationExtensionInterface {
}

/**
 * Country Information interface.
 * @export
 * @interface DirectoryDataCountryInformationInterface
 */
export interface DirectoryDataCountryInformationInterface {
    /**
     * The country id for the store.
     * @type {string}
     * @memberof DirectoryDataCountryInformationInterface
     */
    id: string;
    /**
     * The country 2 letter abbreviation for the store.
     * @type {string}
     * @memberof DirectoryDataCountryInformationInterface
     */
    twoLetterAbbreviation: string;
    /**
     * The country 3 letter abbreviation for the store.
     * @type {string}
     * @memberof DirectoryDataCountryInformationInterface
     */
    threeLetterAbbreviation: string;
    /**
     * The country full name (in store locale) for the store.
     * @type {string}
     * @memberof DirectoryDataCountryInformationInterface
     */
    fullNameLocale: string;
    /**
     * The country full name (in English) for the store.
     * @type {string}
     * @memberof DirectoryDataCountryInformationInterface
     */
    fullNameEnglish: string;
    /**
     * The available regions for the store.
     * @type {Array<DirectoryDataRegionInformationInterface>}
     * @memberof DirectoryDataCountryInformationInterface
     */
    availableRegions?: Array<DirectoryDataRegionInformationInterface>;
    /**
     *
     * @type {DirectoryDataCountryInformationExtensionInterface}
     * @memberof DirectoryDataCountryInformationInterface
     */
    extensionAttributes?: DirectoryDataCountryInformationExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Directory\\Api\\Data\\CurrencyInformationInterface
 * @export
 * @interface DirectoryDataCurrencyInformationExtensionInterface
 */
export interface DirectoryDataCurrencyInformationExtensionInterface {
}

/**
 * Currency Information interface.
 * @export
 * @interface DirectoryDataCurrencyInformationInterface
 */
export interface DirectoryDataCurrencyInformationInterface {
    /**
     * The base currency code for the store.
     * @type {string}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    baseCurrencyCode: string;
    /**
     * The currency symbol of the base currency for the store.
     * @type {string}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    baseCurrencySymbol: string;
    /**
     * The default display currency code for the store.
     * @type {string}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    defaultDisplayCurrencyCode: string;
    /**
     * The currency symbol of the default display currency for the store.
     * @type {string}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    defaultDisplayCurrencySymbol: string;
    /**
     * The list of allowed currency codes for the store.
     * @type {Array<string>}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    availableCurrencyCodes: Array<string>;
    /**
     * The list of exchange rate information for the store.
     * @type {Array<DirectoryDataExchangeRateInterface>}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    exchangeRates: Array<DirectoryDataExchangeRateInterface>;
    /**
     *
     * @type {DirectoryDataCurrencyInformationExtensionInterface}
     * @memberof DirectoryDataCurrencyInformationInterface
     */
    extensionAttributes?: DirectoryDataCurrencyInformationExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Directory\\Api\\Data\\ExchangeRateInterface
 * @export
 * @interface DirectoryDataExchangeRateExtensionInterface
 */
export interface DirectoryDataExchangeRateExtensionInterface {
}

/**
 * Exchange Rate interface.
 * @export
 * @interface DirectoryDataExchangeRateInterface
 */
export interface DirectoryDataExchangeRateInterface {
    /**
     * The currency code associated with the exchange rate.
     * @type {string}
     * @memberof DirectoryDataExchangeRateInterface
     */
    currencyTo: string;
    /**
     * The exchange rate for the associated currency and the store's base currency.
     * @type {number}
     * @memberof DirectoryDataExchangeRateInterface
     */
    rate: number;
    /**
     *
     * @type {DirectoryDataExchangeRateExtensionInterface}
     * @memberof DirectoryDataExchangeRateInterface
     */
    extensionAttributes?: DirectoryDataExchangeRateExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Directory\\Api\\Data\\RegionInformationInterface
 * @export
 * @interface DirectoryDataRegionInformationExtensionInterface
 */
export interface DirectoryDataRegionInformationExtensionInterface {
}

/**
 * Region Information interface.
 * @export
 * @interface DirectoryDataRegionInformationInterface
 */
export interface DirectoryDataRegionInformationInterface {
    /**
     * Region id
     * @type {string}
     * @memberof DirectoryDataRegionInformationInterface
     */
    id: string;
    /**
     * Region code
     * @type {string}
     * @memberof DirectoryDataRegionInformationInterface
     */
    code: string;
    /**
     * Region name
     * @type {string}
     * @memberof DirectoryDataRegionInformationInterface
     */
    name: string;
    /**
     *
     * @type {DirectoryDataRegionInformationExtensionInterface}
     * @memberof DirectoryDataRegionInformationInterface
     */
    extensionAttributes?: DirectoryDataRegionInformationExtensionInterface;
}

/**
 * Downloadable Option
 * @export
 * @interface DownloadableDataDownloadableOptionInterface
 */
export interface DownloadableDataDownloadableOptionInterface {
    /**
     * The list of downloadable links
     * @type {Array<number>}
     * @memberof DownloadableDataDownloadableOptionInterface
     */
    downloadableLinks: Array<number>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Downloadable\\Api\\Data\\File\\ContentInterface
 * @export
 * @interface DownloadableDataFileContentExtensionInterface
 */
export interface DownloadableDataFileContentExtensionInterface {
}

/**
 *
 * @export
 * @interface DownloadableDataFileContentInterface
 */
export interface DownloadableDataFileContentInterface {
    /**
     * Data (base64 encoded content)
     * @type {string}
     * @memberof DownloadableDataFileContentInterface
     */
    fileData: string;
    /**
     * File name
     * @type {string}
     * @memberof DownloadableDataFileContentInterface
     */
    name: string;
    /**
     *
     * @type {DownloadableDataFileContentExtensionInterface}
     * @memberof DownloadableDataFileContentInterface
     */
    extensionAttributes?: DownloadableDataFileContentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Downloadable\\Api\\Data\\LinkInterface
 * @export
 * @interface DownloadableDataLinkExtensionInterface
 */
export interface DownloadableDataLinkExtensionInterface {
}

/**
 *
 * @export
 * @interface DownloadableDataLinkInterface
 */
export interface DownloadableDataLinkInterface {
    /**
     * Sample(or link) id
     * @type {number}
     * @memberof DownloadableDataLinkInterface
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    title?: string;
    /**
     *
     * @type {number}
     * @memberof DownloadableDataLinkInterface
     */
    sortOrder: number;
    /**
     * Shareable status
     * @type {number}
     * @memberof DownloadableDataLinkInterface
     */
    isShareable: number;
    /**
     * Price
     * @type {number}
     * @memberof DownloadableDataLinkInterface
     */
    price: number;
    /**
     * Of downloads per user
     * @type {number}
     * @memberof DownloadableDataLinkInterface
     */
    numberOfDownloads?: number;
    /**
     *
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    linkType: string;
    /**
     * relative file path
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    linkFile?: string;
    /**
     *
     * @type {DownloadableDataFileContentInterface}
     * @memberof DownloadableDataLinkInterface
     */
    linkFileContent?: DownloadableDataFileContentInterface;
    /**
     * Link url or null when type is 'file'
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    linkUrl?: string;
    /**
     *
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    sampleType: string;
    /**
     * relative file path
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    sampleFile?: string;
    /**
     *
     * @type {DownloadableDataFileContentInterface}
     * @memberof DownloadableDataLinkInterface
     */
    sampleFileContent?: DownloadableDataFileContentInterface;
    /**
     * file URL
     * @type {string}
     * @memberof DownloadableDataLinkInterface
     */
    sampleUrl?: string;
    /**
     *
     * @type {DownloadableDataLinkExtensionInterface}
     * @memberof DownloadableDataLinkInterface
     */
    extensionAttributes?: DownloadableDataLinkExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Downloadable\\Api\\Data\\SampleInterface
 * @export
 * @interface DownloadableDataSampleExtensionInterface
 */
export interface DownloadableDataSampleExtensionInterface {
}

/**
 *
 * @export
 * @interface DownloadableDataSampleInterface
 */
export interface DownloadableDataSampleInterface {
    /**
     * Sample(or link) id
     * @type {number}
     * @memberof DownloadableDataSampleInterface
     */
    id?: number;
    /**
     * Title
     * @type {string}
     * @memberof DownloadableDataSampleInterface
     */
    title: string;
    /**
     * Order index for sample
     * @type {number}
     * @memberof DownloadableDataSampleInterface
     */
    sortOrder: number;
    /**
     *
     * @type {string}
     * @memberof DownloadableDataSampleInterface
     */
    sampleType: string;
    /**
     * relative file path
     * @type {string}
     * @memberof DownloadableDataSampleInterface
     */
    sampleFile?: string;
    /**
     *
     * @type {DownloadableDataFileContentInterface}
     * @memberof DownloadableDataSampleInterface
     */
    sampleFileContent?: DownloadableDataFileContentInterface;
    /**
     * file URL
     * @type {string}
     * @memberof DownloadableDataSampleInterface
     */
    sampleUrl?: string;
    /**
     *
     * @type {DownloadableDataSampleExtensionInterface}
     * @memberof DownloadableDataSampleInterface
     */
    extensionAttributes?: DownloadableDataSampleExtensionInterface;
}

/**
 *
 * @export
 * @interface DownloadableLinkRepositoryV1SavePostBody
 */
export interface DownloadableLinkRepositoryV1SavePostBody {
    /**
     *
     * @type {DownloadableDataLinkInterface}
     * @memberof DownloadableLinkRepositoryV1SavePostBody
     */
    link: DownloadableDataLinkInterface;
    /**
     *
     * @type {boolean}
     * @memberof DownloadableLinkRepositoryV1SavePostBody
     */
    isGlobalScopeContent?: boolean;
}

/**
 *
 * @export
 * @interface DownloadableLinkRepositoryV1SavePutBody
 */
export interface DownloadableLinkRepositoryV1SavePutBody {
    /**
     *
     * @type {DownloadableDataLinkInterface}
     * @memberof DownloadableLinkRepositoryV1SavePutBody
     */
    link: DownloadableDataLinkInterface;
    /**
     *
     * @type {boolean}
     * @memberof DownloadableLinkRepositoryV1SavePutBody
     */
    isGlobalScopeContent?: boolean;
}

/**
 *
 * @export
 * @interface DownloadableSampleRepositoryV1SavePostBody
 */
export interface DownloadableSampleRepositoryV1SavePostBody {
    /**
     *
     * @type {DownloadableDataSampleInterface}
     * @memberof DownloadableSampleRepositoryV1SavePostBody
     */
    sample: DownloadableDataSampleInterface;
    /**
     *
     * @type {boolean}
     * @memberof DownloadableSampleRepositoryV1SavePostBody
     */
    isGlobalScopeContent?: boolean;
}

/**
 *
 * @export
 * @interface DownloadableSampleRepositoryV1SavePutBody
 */
export interface DownloadableSampleRepositoryV1SavePutBody {
    /**
     *
     * @type {DownloadableDataSampleInterface}
     * @memberof DownloadableSampleRepositoryV1SavePutBody
     */
    sample: DownloadableDataSampleInterface;
    /**
     *
     * @type {boolean}
     * @memberof DownloadableSampleRepositoryV1SavePutBody
     */
    isGlobalScopeContent?: boolean;
}

/**
 *
 * @export
 * @interface EavAttributeSetManagementV1CreatePostBody
 */
export interface EavAttributeSetManagementV1CreatePostBody {
    /**
     *
     * @type {string}
     * @memberof EavAttributeSetManagementV1CreatePostBody
     */
    entityTypeCode: string;
    /**
     *
     * @type {EavDataAttributeSetInterface}
     * @memberof EavAttributeSetManagementV1CreatePostBody
     */
    attributeSet: EavDataAttributeSetInterface;
    /**
     *
     * @type {number}
     * @memberof EavAttributeSetManagementV1CreatePostBody
     */
    skeletonId: number;
}

/**
 *
 * @export
 * @interface EavAttributeSetRepositoryV1SavePutBody
 */
export interface EavAttributeSetRepositoryV1SavePutBody {
    /**
     *
     * @type {EavDataAttributeSetInterface}
     * @memberof EavAttributeSetRepositoryV1SavePutBody
     */
    attributeSet: EavDataAttributeSetInterface;
}

/**
 * Interface AttributeFrontendLabelInterface
 * @export
 * @interface EavDataAttributeFrontendLabelInterface
 */
export interface EavDataAttributeFrontendLabelInterface {
    /**
     * Store id
     * @type {number}
     * @memberof EavDataAttributeFrontendLabelInterface
     */
    storeId?: number;
    /**
     * Option label
     * @type {string}
     * @memberof EavDataAttributeFrontendLabelInterface
     */
    label?: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Eav\\Api\\Data\\AttributeGroupInterface
 * @export
 * @interface EavDataAttributeGroupExtensionInterface
 */
export interface EavDataAttributeGroupExtensionInterface {
    /**
     *
     * @type {string}
     * @memberof EavDataAttributeGroupExtensionInterface
     */
    attributeGroupCode?: string;
    /**
     *
     * @type {string}
     * @memberof EavDataAttributeGroupExtensionInterface
     */
    sortOrder?: string;
}

/**
 * Interface AttributeGroupInterface
 * @export
 * @interface EavDataAttributeGroupInterface
 */
export interface EavDataAttributeGroupInterface {
    /**
     * Id
     * @type {string}
     * @memberof EavDataAttributeGroupInterface
     */
    attributeGroupId?: string;
    /**
     * Name
     * @type {string}
     * @memberof EavDataAttributeGroupInterface
     */
    attributeGroupName?: string;
    /**
     * Attribute set id
     * @type {number}
     * @memberof EavDataAttributeGroupInterface
     */
    attributeSetId?: number;
    /**
     *
     * @type {EavDataAttributeGroupExtensionInterface}
     * @memberof EavDataAttributeGroupInterface
     */
    extensionAttributes?: EavDataAttributeGroupExtensionInterface;
}

/**
 * Interface AttributeGroupSearchResultsInterface
 * @export
 * @interface EavDataAttributeGroupSearchResultsInterface
 */
export interface EavDataAttributeGroupSearchResultsInterface {
    /**
     * Attribute sets list.
     * @type {Array<EavDataAttributeGroupInterface>}
     * @memberof EavDataAttributeGroupSearchResultsInterface
     */
    items: Array<EavDataAttributeGroupInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof EavDataAttributeGroupSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof EavDataAttributeGroupSearchResultsInterface
     */
    totalCount: number;
}

/**
 * Created from:
 * @export
 * @interface EavDataAttributeOptionInterface
 */
export interface EavDataAttributeOptionInterface {
    /**
     * Option label
     * @type {string}
     * @memberof EavDataAttributeOptionInterface
     */
    label: string;
    /**
     * Option value
     * @type {string}
     * @memberof EavDataAttributeOptionInterface
     */
    value: string;
    /**
     * Option order
     * @type {number}
     * @memberof EavDataAttributeOptionInterface
     */
    sortOrder?: number;
    /**
     * Default
     * @type {boolean}
     * @memberof EavDataAttributeOptionInterface
     */
    isDefault?: boolean;
    /**
     * Option label for store scopes
     * @type {Array<EavDataAttributeOptionLabelInterface>}
     * @memberof EavDataAttributeOptionInterface
     */
    storeLabels?: Array<EavDataAttributeOptionLabelInterface>;
}

/**
 * Interface AttributeOptionLabelInterface
 * @export
 * @interface EavDataAttributeOptionLabelInterface
 */
export interface EavDataAttributeOptionLabelInterface {
    /**
     * Store id
     * @type {number}
     * @memberof EavDataAttributeOptionLabelInterface
     */
    storeId?: number;
    /**
     * Option label
     * @type {string}
     * @memberof EavDataAttributeOptionLabelInterface
     */
    label?: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Eav\\Api\\Data\\AttributeSetInterface
 * @export
 * @interface EavDataAttributeSetExtensionInterface
 */
export interface EavDataAttributeSetExtensionInterface {
}

/**
 * Interface AttributeSetInterface
 * @export
 * @interface EavDataAttributeSetInterface
 */
export interface EavDataAttributeSetInterface {
    /**
     * Attribute set ID
     * @type {number}
     * @memberof EavDataAttributeSetInterface
     */
    attributeSetId?: number;
    /**
     * Attribute set name
     * @type {string}
     * @memberof EavDataAttributeSetInterface
     */
    attributeSetName: string;
    /**
     * Attribute set sort order index
     * @type {number}
     * @memberof EavDataAttributeSetInterface
     */
    sortOrder: number;
    /**
     * Attribute set entity type id
     * @type {number}
     * @memberof EavDataAttributeSetInterface
     */
    entityTypeId?: number;
    /**
     *
     * @type {EavDataAttributeSetExtensionInterface}
     * @memberof EavDataAttributeSetInterface
     */
    extensionAttributes?: EavDataAttributeSetExtensionInterface;
}

/**
 * Interface AttributeSetSearchResultsInterface
 * @export
 * @interface EavDataAttributeSetSearchResultsInterface
 */
export interface EavDataAttributeSetSearchResultsInterface {
    /**
     * Attribute sets list.
     * @type {Array<EavDataAttributeSetInterface>}
     * @memberof EavDataAttributeSetSearchResultsInterface
     */
    items: Array<EavDataAttributeSetInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof EavDataAttributeSetSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof EavDataAttributeSetSearchResultsInterface
     */
    totalCount: number;
}

/**
 * Interface AttributeValidationRuleInterface
 * @export
 * @interface EavDataAttributeValidationRuleInterface
 */
export interface EavDataAttributeValidationRuleInterface {
    /**
     * Object key
     * @type {string}
     * @memberof EavDataAttributeValidationRuleInterface
     */
    key: string;
    /**
     * Object value
     * @type {string}
     * @memberof EavDataAttributeValidationRuleInterface
     */
    value: string;
}

/**
 * Errors list
 * @export
 * @interface ErrorErrors
 */
export interface ErrorErrors extends Array<ErrorErrorsItem> {
}

/**
 * Error details
 * @export
 * @interface ErrorErrorsItem
 */
export interface ErrorErrorsItem {
    /**
     * Error message
     * @type {string}
     * @memberof ErrorErrorsItem
     */
    message?: string;
    /**
     *
     * @type {ErrorParameters}
     * @memberof ErrorErrorsItem
     */
    parameters?: ErrorParameters;
}

/**
 * Error parameters list
 * @export
 * @interface ErrorParameters
 */
export interface ErrorParameters extends Array<ErrorParametersItem> {
}

/**
 * Error parameters item
 * @export
 * @interface ErrorParametersItem
 */
export interface ErrorParametersItem {
    /**
     * ACL resource
     * @type {string}
     * @memberof ErrorParametersItem
     */
    resources?: string;
    /**
     * Missing or invalid field name
     * @type {string}
     * @memberof ErrorParametersItem
     */
    fieldName?: string;
    /**
     * Incorrect field value
     * @type {string}
     * @memberof ErrorParametersItem
     */
    fieldValue?: string;
}

/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error message
     * @type {string}
     * @memberof ErrorResponse
     */
    message: string;
    /**
     *
     * @type {ErrorErrors}
     * @memberof ErrorResponse
     */
    errors?: ErrorErrors;
    /**
     * Error code
     * @type {number}
     * @memberof ErrorResponse
     */
    code?: number;
    /**
     *
     * @type {ErrorParameters}
     * @memberof ErrorResponse
     */
    parameters?: ErrorParameters;
    /**
     * Stack trace
     * @type {string}
     * @memberof ErrorResponse
     */
    trace?: string;
}

/**
 * Interface for custom attribute value.
 * @export
 * @interface FrameworkAttributeInterface
 */
export interface FrameworkAttributeInterface {
    /**
     * Attribute code
     * @type {string}
     * @memberof FrameworkAttributeInterface
     */
    attributeCode: string;
    /**
     * Attribute value
     * @type {string}
     * @memberof FrameworkAttributeInterface
     */
    value: string;
}

/**
 * Interface CriteriaInterface
 * @export
 * @interface FrameworkCriteriaInterface
 */
export interface FrameworkCriteriaInterface {
    /**
     * Associated Mapper Interface name
     * @type {string}
     * @memberof FrameworkCriteriaInterface
     */
    mapperInterfaceName: string;
    /**
     * Criteria objects added to current Composite Criteria
     * @type {Array<FrameworkCriteriaInterface>}
     * @memberof FrameworkCriteriaInterface
     */
    criteriaList: Array<FrameworkCriteriaInterface>;
    /**
     * List of filters
     * @type {Array<string>}
     * @memberof FrameworkCriteriaInterface
     */
    filters: Array<string>;
    /**
     * Ordering criteria
     * @type {Array<string>}
     * @memberof FrameworkCriteriaInterface
     */
    orders: Array<string>;
    /**
     * Limit
     * @type {Array<string>}
     * @memberof FrameworkCriteriaInterface
     */
    limit: Array<string>;
}

/**
 * Image Content data interface
 * @export
 * @interface FrameworkDataImageContentInterface
 */
export interface FrameworkDataImageContentInterface {
    /**
     * Media data (base64 encoded content)
     * @type {string}
     * @memberof FrameworkDataImageContentInterface
     */
    base64EncodedData: string;
    /**
     * MIME type
     * @type {string}
     * @memberof FrameworkDataImageContentInterface
     */
    type: string;
    /**
     * Image name
     * @type {string}
     * @memberof FrameworkDataImageContentInterface
     */
    name: string;
}

/**
 * Video Content data interface
 * @export
 * @interface FrameworkDataVideoContentInterface
 */
export interface FrameworkDataVideoContentInterface {
    /**
     * MIME type
     * @type {string}
     * @memberof FrameworkDataVideoContentInterface
     */
    mediaType: string;
    /**
     * Provider
     * @type {string}
     * @memberof FrameworkDataVideoContentInterface
     */
    videoProvider: string;
    /**
     * Video URL
     * @type {string}
     * @memberof FrameworkDataVideoContentInterface
     */
    videoUrl: string;
    /**
     * Title
     * @type {string}
     * @memberof FrameworkDataVideoContentInterface
     */
    videoTitle: string;
    /**
     * Video Description
     * @type {string}
     * @memberof FrameworkDataVideoContentInterface
     */
    videoDescription: string;
    /**
     * Metadata
     * @type {string}
     * @memberof FrameworkDataVideoContentInterface
     */
    videoMetadata: string;
}

/**
 * Filter which can be used by any methods from service layer.
 * @export
 * @interface FrameworkFilter
 */
export interface FrameworkFilter {
    /**
     * Field
     * @type {string}
     * @memberof FrameworkFilter
     */
    field: string;
    /**
     * Value
     * @type {string}
     * @memberof FrameworkFilter
     */
    value: string;
    /**
     * Condition type
     * @type {string}
     * @memberof FrameworkFilter
     */
    conditionType?: string;
}

/**
 * Provides metadata about an attribute.
 * @export
 * @interface FrameworkMetadataObjectInterface
 */
export interface FrameworkMetadataObjectInterface {
    /**
     * Code of the attribute.
     * @type {string}
     * @memberof FrameworkMetadataObjectInterface
     */
    attributeCode: string;
}

/**
 * Faceted data
 * @export
 * @interface FrameworkSearchAggregationInterface
 */
export interface FrameworkSearchAggregationInterface {
    /**
     * All Document fields
     * @type {Array<FrameworkSearchBucketInterface>}
     * @memberof FrameworkSearchAggregationInterface
     */
    buckets: Array<FrameworkSearchBucketInterface>;
    /**
     * Document field names
     * @type {Array<string>}
     * @memberof FrameworkSearchAggregationInterface
     */
    bucketNames: Array<string>;
}

/**
 * Interface \\Magento\\Framework\\Api\\Search\\AggregationValueInterface
 * @export
 * @interface FrameworkSearchAggregationValueInterface
 */
export interface FrameworkSearchAggregationValueInterface {
    /**
     * Aggregation
     * @type {string}
     * @memberof FrameworkSearchAggregationValueInterface
     */
    value: string;
    /**
     * Metrics
     * @type {Array<string>}
     * @memberof FrameworkSearchAggregationValueInterface
     */
    metrics: Array<string>;
}

/**
 * Facet Bucket
 * @export
 * @interface FrameworkSearchBucketInterface
 */
export interface FrameworkSearchBucketInterface {
    /**
     * Field name
     * @type {string}
     * @memberof FrameworkSearchBucketInterface
     */
    name: string;
    /**
     * Field values
     * @type {Array<FrameworkSearchAggregationValueInterface>}
     * @memberof FrameworkSearchBucketInterface
     */
    values: Array<FrameworkSearchAggregationValueInterface>;
}

/**
 * Search criteria interface.
 * @export
 * @interface FrameworkSearchCriteriaInterface
 */
export interface FrameworkSearchCriteriaInterface {
    /**
     * A list of filter groups.
     * @type {Array<FrameworkSearchFilterGroup>}
     * @memberof FrameworkSearchCriteriaInterface
     */
    filterGroups: Array<FrameworkSearchFilterGroup>;
    /**
     * Sort order.
     * @type {Array<FrameworkSortOrder>}
     * @memberof FrameworkSearchCriteriaInterface
     */
    sortOrders?: Array<FrameworkSortOrder>;
    /**
     * Page size.
     * @type {number}
     * @memberof FrameworkSearchCriteriaInterface
     */
    pageSize?: number;
    /**
     * Current page.
     * @type {number}
     * @memberof FrameworkSearchCriteriaInterface
     */
    currentPage?: number;
}

/**
 * Interface \\Magento\\Framework\\Api\\Search\\DocumentInterface
 * @export
 * @interface FrameworkSearchDocumentInterface
 */
export interface FrameworkSearchDocumentInterface {
    /**
     *
     * @type {number}
     * @memberof FrameworkSearchDocumentInterface
     */
    id: number;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof FrameworkSearchDocumentInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * Groups two or more filters together using a logical OR
 * @export
 * @interface FrameworkSearchFilterGroup
 */
export interface FrameworkSearchFilterGroup {
    /**
     * A list of filters in this group
     * @type {Array<FrameworkFilter>}
     * @memberof FrameworkSearchFilterGroup
     */
    filters?: Array<FrameworkFilter>;
}

/**
 * Interface SearchCriteriaInterface
 * @export
 * @interface FrameworkSearchSearchCriteriaInterface
 */
export interface FrameworkSearchSearchCriteriaInterface {
    /**
     *
     * @type {string}
     * @memberof FrameworkSearchSearchCriteriaInterface
     */
    requestName: string;
    /**
     * A list of filter groups.
     * @type {Array<FrameworkSearchFilterGroup>}
     * @memberof FrameworkSearchSearchCriteriaInterface
     */
    filterGroups: Array<FrameworkSearchFilterGroup>;
    /**
     * Sort order.
     * @type {Array<FrameworkSortOrder>}
     * @memberof FrameworkSearchSearchCriteriaInterface
     */
    sortOrders?: Array<FrameworkSortOrder>;
    /**
     * Page size.
     * @type {number}
     * @memberof FrameworkSearchSearchCriteriaInterface
     */
    pageSize?: number;
    /**
     * Current page.
     * @type {number}
     * @memberof FrameworkSearchSearchCriteriaInterface
     */
    currentPage?: number;
}

/**
 * Interface SearchResultInterface
 * @export
 * @interface FrameworkSearchSearchResultInterface
 */
export interface FrameworkSearchSearchResultInterface {
    /**
     *
     * @type {Array<FrameworkSearchDocumentInterface>}
     * @memberof FrameworkSearchSearchResultInterface
     */
    items: Array<FrameworkSearchDocumentInterface>;
    /**
     *
     * @type {FrameworkSearchAggregationInterface}
     * @memberof FrameworkSearchSearchResultInterface
     */
    aggregations: FrameworkSearchAggregationInterface;
    /**
     *
     * @type {FrameworkSearchSearchCriteriaInterface}
     * @memberof FrameworkSearchSearchResultInterface
     */
    searchCriteria: FrameworkSearchSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof FrameworkSearchSearchResultInterface
     */
    totalCount: number;
}

/**
 * Data object for sort order.
 * @export
 * @interface FrameworkSortOrder
 */
export interface FrameworkSortOrder {
    /**
     * Sorting field.
     * @type {string}
     * @memberof FrameworkSortOrder
     */
    field: string;
    /**
     * Sorting direction.
     * @type {string}
     * @memberof FrameworkSortOrder
     */
    direction: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\GiftCardAccount\\Api\\Data\\GiftCardAccountInterface
 * @export
 * @interface GiftCardAccountDataGiftCardAccountExtensionInterface
 */
export interface GiftCardAccountDataGiftCardAccountExtensionInterface {
}

/**
 * Gift Card Account data
 * @export
 * @interface GiftCardAccountDataGiftCardAccountInterface
 */
export interface GiftCardAccountDataGiftCardAccountInterface {
    /**
     * Cards codes
     * @type {Array<string>}
     * @memberof GiftCardAccountDataGiftCardAccountInterface
     */
    giftCards: Array<string>;
    /**
     * Cards amount in quote currency
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardAccountInterface
     */
    giftCardsAmount: number;
    /**
     * Cards amount in base currency
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardAccountInterface
     */
    baseGiftCardsAmount: number;
    /**
     * Cards amount used in quote currency
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardAccountInterface
     */
    giftCardsAmountUsed: number;
    /**
     * Cards amount used in base currency
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardAccountInterface
     */
    baseGiftCardsAmountUsed: number;
    /**
     *
     * @type {GiftCardAccountDataGiftCardAccountExtensionInterface}
     * @memberof GiftCardAccountDataGiftCardAccountInterface
     */
    extensionAttributes?: GiftCardAccountDataGiftCardAccountExtensionInterface;
}

/**
 * Gift Card data
 * @export
 * @interface GiftCardAccountDataGiftCardInterface
 */
export interface GiftCardAccountDataGiftCardInterface {
    /**
     * Id
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardInterface
     */
    id: number;
    /**
     * Code
     * @type {string}
     * @memberof GiftCardAccountDataGiftCardInterface
     */
    code: string;
    /**
     * Amount
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardInterface
     */
    amount: number;
    /**
     * Base Amount
     * @type {number}
     * @memberof GiftCardAccountDataGiftCardInterface
     */
    baseAmount: number;
}

/**
 *
 * @export
 * @interface GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody
 */
export interface GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody {
    /**
     *
     * @type {GiftCardAccountDataGiftCardAccountInterface}
     * @memberof GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody
     */
    giftCardAccountData: GiftCardAccountDataGiftCardAccountInterface;
}

/**
 *
 * @export
 * @interface GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody
 */
export interface GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody {
    /**
     *
     * @type {GiftCardAccountDataGiftCardAccountInterface}
     * @memberof GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody
     */
    giftCardAccountData: GiftCardAccountDataGiftCardAccountInterface;
}

/**
 *
 * @export
 * @interface GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody
 */
export interface GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody {
    /**
     *
     * @type {GiftCardAccountDataGiftCardAccountInterface}
     * @memberof GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody
     */
    giftCardAccountData: GiftCardAccountDataGiftCardAccountInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\GiftCard\\Api\\Data\\GiftCardOptionInterface
 * @export
 * @interface GiftCardDataGiftCardOptionExtensionInterface
 */
export interface GiftCardDataGiftCardOptionExtensionInterface {
}

/**
 * Interface GiftCardOptionInterface
 * @export
 * @interface GiftCardDataGiftCardOptionInterface
 */
export interface GiftCardDataGiftCardOptionInterface {
    /**
     * Gift card amount.
     * @type {string}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    giftcardAmount: string;
    /**
     * Gift card open amount value.
     * @type {number}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    customGiftcardAmount?: number;
    /**
     * Gift card sender name.
     * @type {string}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    giftcardSenderName: string;
    /**
     * Gift card recipient name.
     * @type {string}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    giftcardRecipientName: string;
    /**
     * Gift card sender email.
     * @type {string}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    giftcardSenderEmail: string;
    /**
     * Gift card recipient email.
     * @type {string}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    giftcardRecipientEmail: string;
    /**
     * Giftcard message.
     * @type {string}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    giftcardMessage?: string;
    /**
     *
     * @type {GiftCardDataGiftCardOptionExtensionInterface}
     * @memberof GiftCardDataGiftCardOptionInterface
     */
    extensionAttributes?: GiftCardDataGiftCardOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\GiftCard\\Api\\Data\\GiftcardAmountInterface
 * @export
 * @interface GiftCardDataGiftcardAmountExtensionInterface
 */
export interface GiftCardDataGiftcardAmountExtensionInterface {
}

/**
 * Interface GiftcardAmountInterface: this interface is used to serialize and deserialize EAV attribute giftcard_amounts
 * @export
 * @interface GiftCardDataGiftcardAmountInterface
 */
export interface GiftCardDataGiftcardAmountInterface {
    /**
     *
     * @type {number}
     * @memberof GiftCardDataGiftcardAmountInterface
     */
    attributeId: number;
    /**
     *
     * @type {number}
     * @memberof GiftCardDataGiftcardAmountInterface
     */
    websiteId: number;
    /**
     *
     * @type {number}
     * @memberof GiftCardDataGiftcardAmountInterface
     */
    value: number;
    /**
     *
     * @type {number}
     * @memberof GiftCardDataGiftcardAmountInterface
     */
    websiteValue: number;
    /**
     *
     * @type {GiftCardDataGiftcardAmountExtensionInterface}
     * @memberof GiftCardDataGiftcardAmountInterface
     */
    extensionAttributes?: GiftCardDataGiftcardAmountExtensionInterface;
}

/**
 *
 * @export
 * @interface GiftMessageCartRepositoryV1SavePostBody
 */
export interface GiftMessageCartRepositoryV1SavePostBody {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof GiftMessageCartRepositoryV1SavePostBody
     */
    giftMessage: GiftMessageDataMessageInterface;
}

/**
 *
 * @export
 * @interface GiftMessageCartRepositoryV1SavePostBody1
 */
export interface GiftMessageCartRepositoryV1SavePostBody1 {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof GiftMessageCartRepositoryV1SavePostBody1
     */
    giftMessage: GiftMessageDataMessageInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\GiftMessage\\Api\\Data\\MessageInterface
 * @export
 * @interface GiftMessageDataMessageExtensionInterface
 */
export interface GiftMessageDataMessageExtensionInterface {
    /**
     *
     * @type {string}
     * @memberof GiftMessageDataMessageExtensionInterface
     */
    entityId?: string;
    /**
     *
     * @type {string}
     * @memberof GiftMessageDataMessageExtensionInterface
     */
    entityType?: string;
    /**
     *
     * @type {number}
     * @memberof GiftMessageDataMessageExtensionInterface
     */
    wrappingId?: number;
    /**
     *
     * @type {boolean}
     * @memberof GiftMessageDataMessageExtensionInterface
     */
    wrappingAllowGiftReceipt?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GiftMessageDataMessageExtensionInterface
     */
    wrappingAddPrintedCard?: boolean;
}

/**
 * Interface MessageInterface
 * @export
 * @interface GiftMessageDataMessageInterface
 */
export interface GiftMessageDataMessageInterface {
    /**
     * Gift message ID. Otherwise, null.
     * @type {number}
     * @memberof GiftMessageDataMessageInterface
     */
    giftMessageId?: number;
    /**
     * Customer ID. Otherwise, null.
     * @type {number}
     * @memberof GiftMessageDataMessageInterface
     */
    customerId?: number;
    /**
     * Sender name.
     * @type {string}
     * @memberof GiftMessageDataMessageInterface
     */
    sender: string;
    /**
     * Recipient name.
     * @type {string}
     * @memberof GiftMessageDataMessageInterface
     */
    recipient: string;
    /**
     * Message text.
     * @type {string}
     * @memberof GiftMessageDataMessageInterface
     */
    message: string;
    /**
     *
     * @type {GiftMessageDataMessageExtensionInterface}
     * @memberof GiftMessageDataMessageInterface
     */
    extensionAttributes?: GiftMessageDataMessageExtensionInterface;
}

/**
 *
 * @export
 * @interface GiftMessageGuestCartRepositoryV1SavePostBody
 */
export interface GiftMessageGuestCartRepositoryV1SavePostBody {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof GiftMessageGuestCartRepositoryV1SavePostBody
     */
    giftMessage: GiftMessageDataMessageInterface;
}

/**
 *
 * @export
 * @interface GiftMessageGuestItemRepositoryV1SavePostBody
 */
export interface GiftMessageGuestItemRepositoryV1SavePostBody {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof GiftMessageGuestItemRepositoryV1SavePostBody
     */
    giftMessage: GiftMessageDataMessageInterface;
}

/**
 *
 * @export
 * @interface GiftMessageItemRepositoryV1SavePostBody
 */
export interface GiftMessageItemRepositoryV1SavePostBody {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof GiftMessageItemRepositoryV1SavePostBody
     */
    giftMessage: GiftMessageDataMessageInterface;
}

/**
 *
 * @export
 * @interface GiftMessageItemRepositoryV1SavePostBody1
 */
export interface GiftMessageItemRepositoryV1SavePostBody1 {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof GiftMessageItemRepositoryV1SavePostBody1
     */
    giftMessage: GiftMessageDataMessageInterface;
}

/**
 *
 * @export
 * @interface GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody
 */
export interface GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody {
    /**
     * The estimate registry id
     * @type {number}
     * @memberof GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody
     */
    registryId: number;
}

/**
 *
 * @export
 * @interface GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody
 */
export interface GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody {
    /**
     * The estimate registry id
     * @type {number}
     * @memberof GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody
     */
    registryId: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\GiftWrapping\\Api\\Data\\WrappingInterface
 * @export
 * @interface GiftWrappingDataWrappingExtensionInterface
 */
export interface GiftWrappingDataWrappingExtensionInterface {
}

/**
 * Interface WrappingInterface
 * @export
 * @interface GiftWrappingDataWrappingInterface
 */
export interface GiftWrappingDataWrappingInterface {
    /**
     *
     * @type {number}
     * @memberof GiftWrappingDataWrappingInterface
     */
    wrappingId?: number;
    /**
     *
     * @type {string}
     * @memberof GiftWrappingDataWrappingInterface
     */
    design: string;
    /**
     *
     * @type {number}
     * @memberof GiftWrappingDataWrappingInterface
     */
    status: number;
    /**
     *
     * @type {number}
     * @memberof GiftWrappingDataWrappingInterface
     */
    basePrice: number;
    /**
     *
     * @type {string}
     * @memberof GiftWrappingDataWrappingInterface
     */
    imageName?: string;
    /**
     *
     * @type {string}
     * @memberof GiftWrappingDataWrappingInterface
     */
    imageBase64Content?: string;
    /**
     *
     * @type {string}
     * @memberof GiftWrappingDataWrappingInterface
     */
    baseCurrencyCode?: string;
    /**
     *
     * @type {Array<number>}
     * @memberof GiftWrappingDataWrappingInterface
     */
    websiteIds?: Array<number>;
    /**
     * Wrapping image URL.
     * @type {string}
     * @memberof GiftWrappingDataWrappingInterface
     */
    imageUrl?: string;
    /**
     *
     * @type {GiftWrappingDataWrappingExtensionInterface}
     * @memberof GiftWrappingDataWrappingInterface
     */
    extensionAttributes?: GiftWrappingDataWrappingExtensionInterface;
}

/**
 * Interface WrappingSearchResultsInterface
 * @export
 * @interface GiftWrappingDataWrappingSearchResultsInterface
 */
export interface GiftWrappingDataWrappingSearchResultsInterface {
    /**
     * Items
     * @type {Array<GiftWrappingDataWrappingInterface>}
     * @memberof GiftWrappingDataWrappingSearchResultsInterface
     */
    items: Array<GiftWrappingDataWrappingInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof GiftWrappingDataWrappingSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof GiftWrappingDataWrappingSearchResultsInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface GiftWrappingWrappingRepositoryV1SavePostBody
 */
export interface GiftWrappingWrappingRepositoryV1SavePostBody {
    /**
     *
     * @type {GiftWrappingDataWrappingInterface}
     * @memberof GiftWrappingWrappingRepositoryV1SavePostBody
     */
    data: GiftWrappingDataWrappingInterface;
    /**
     *
     * @type {number}
     * @memberof GiftWrappingWrappingRepositoryV1SavePostBody
     */
    storeId?: number;
}

/**
 *
 * @export
 * @interface GiftWrappingWrappingRepositoryV1SavePutBody
 */
export interface GiftWrappingWrappingRepositoryV1SavePutBody {
    /**
     *
     * @type {GiftWrappingDataWrappingInterface}
     * @memberof GiftWrappingWrappingRepositoryV1SavePutBody
     */
    data: GiftWrappingDataWrappingInterface;
    /**
     *
     * @type {number}
     * @memberof GiftWrappingWrappingRepositoryV1SavePutBody
     */
    storeId?: number;
}

/**
 *
 * @export
 * @interface IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody
 */
export interface IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody {
    /**
     *
     * @type {string}
     * @memberof IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody
     */
    password: string;
}

/**
 *
 * @export
 * @interface IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody
 */
export interface IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody {
    /**
     *
     * @type {string}
     * @memberof IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody
     */
    password: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Msrp\\Api\\Data\\ProductRender\\MsrpPriceInfoInterface
 * @export
 * @interface MsrpDataProductRenderMsrpPriceInfoExtensionInterface
 */
export interface MsrpDataProductRenderMsrpPriceInfoExtensionInterface {
}

/**
 * Price interface.
 * @export
 * @interface MsrpDataProductRenderMsrpPriceInfoInterface
 */
export interface MsrpDataProductRenderMsrpPriceInfoInterface {
    /**
     *
     * @type {string}
     * @memberof MsrpDataProductRenderMsrpPriceInfoInterface
     */
    msrpPrice: string;
    /**
     *
     * @type {string}
     * @memberof MsrpDataProductRenderMsrpPriceInfoInterface
     */
    isApplicable: string;
    /**
     *
     * @type {string}
     * @memberof MsrpDataProductRenderMsrpPriceInfoInterface
     */
    isShownPriceOnGesture: string;
    /**
     *
     * @type {string}
     * @memberof MsrpDataProductRenderMsrpPriceInfoInterface
     */
    msrpMessage: string;
    /**
     *
     * @type {string}
     * @memberof MsrpDataProductRenderMsrpPriceInfoInterface
     */
    explanationMessage: string;
    /**
     *
     * @type {MsrpDataProductRenderMsrpPriceInfoExtensionInterface}
     * @memberof MsrpDataProductRenderMsrpPriceInfoInterface
     */
    extensionAttributes?: MsrpDataProductRenderMsrpPriceInfoExtensionInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuoteBillingAddressManagementV1AssignPostBody
 */
export interface NegotiableQuoteBillingAddressManagementV1AssignPostBody {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof NegotiableQuoteBillingAddressManagementV1AssignPostBody
     */
    address: QuoteDataAddressInterface;
    /**
     *
     * @type {boolean}
     * @memberof NegotiableQuoteBillingAddressManagementV1AssignPostBody
     */
    useForShipping?: boolean;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\AttachmentContentInterface
 * @export
 * @interface NegotiableQuoteDataAttachmentContentExtensionInterface
 */
export interface NegotiableQuoteDataAttachmentContentExtensionInterface {
}

/**
 * Attachment files content interface.
 * @export
 * @interface NegotiableQuoteDataAttachmentContentInterface
 */
export interface NegotiableQuoteDataAttachmentContentInterface {
    /**
     * Media data (base64 encoded content).
     * @type {string}
     * @memberof NegotiableQuoteDataAttachmentContentInterface
     */
    base64EncodedData: string;
    /**
     * MIME type.
     * @type {string}
     * @memberof NegotiableQuoteDataAttachmentContentInterface
     */
    type: string;
    /**
     * File name.
     * @type {string}
     * @memberof NegotiableQuoteDataAttachmentContentInterface
     */
    name: string;
    /**
     *
     * @type {NegotiableQuoteDataAttachmentContentExtensionInterface}
     * @memberof NegotiableQuoteDataAttachmentContentInterface
     */
    extensionAttributes?: NegotiableQuoteDataAttachmentContentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\CommentAttachmentInterface
 * @export
 * @interface NegotiableQuoteDataCommentAttachmentExtensionInterface
 */
export interface NegotiableQuoteDataCommentAttachmentExtensionInterface {
}

/**
 * Interface for quote comment attachment.
 * @export
 * @interface NegotiableQuoteDataCommentAttachmentInterface
 */
export interface NegotiableQuoteDataCommentAttachmentInterface {
    /**
     * Attachment ID.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentAttachmentInterface
     */
    attachmentId: number;
    /**
     * Comment ID.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentAttachmentInterface
     */
    commentId: number;
    /**
     * File name.
     * @type {string}
     * @memberof NegotiableQuoteDataCommentAttachmentInterface
     */
    fileName: string;
    /**
     * File path.
     * @type {string}
     * @memberof NegotiableQuoteDataCommentAttachmentInterface
     */
    filePath: string;
    /**
     * File type.
     * @type {string}
     * @memberof NegotiableQuoteDataCommentAttachmentInterface
     */
    fileType: string;
    /**
     *
     * @type {NegotiableQuoteDataCommentAttachmentExtensionInterface}
     * @memberof NegotiableQuoteDataCommentAttachmentInterface
     */
    extensionAttributes?: NegotiableQuoteDataCommentAttachmentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\CommentInterface
 * @export
 * @interface NegotiableQuoteDataCommentExtensionInterface
 */
export interface NegotiableQuoteDataCommentExtensionInterface {
}

/**
 * Interface CommentInterface
 * @export
 * @interface NegotiableQuoteDataCommentInterface
 */
export interface NegotiableQuoteDataCommentInterface {
    /**
     * Comment ID.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    entityId: number;
    /**
     * Negotiable quote ID, that this comment belongs to.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    parentId: number;
    /**
     * The comment creator type.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    creatorType: number;
    /**
     * Is quote was declined by seller.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    isDecline: number;
    /**
     * Is quote draft flag.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    isDraft: number;
    /**
     * Comment creator ID.
     * @type {number}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    creatorId: number;
    /**
     * Comment.
     * @type {string}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    comment: string;
    /**
     * Comment created at.
     * @type {string}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    createdAt: string;
    /**
     *
     * @type {NegotiableQuoteDataCommentExtensionInterface}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    extensionAttributes?: NegotiableQuoteDataCommentExtensionInterface;
    /**
     * Existing attachments.
     * @type {Array<NegotiableQuoteDataCommentAttachmentInterface>}
     * @memberof NegotiableQuoteDataCommentInterface
     */
    attachments: Array<NegotiableQuoteDataCommentAttachmentInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\CompanyQuoteConfigInterface
 * @export
 * @interface NegotiableQuoteDataCompanyQuoteConfigExtensionInterface
 */
export interface NegotiableQuoteDataCompanyQuoteConfigExtensionInterface {
}

/**
 * Interface CompanyQuoteConfigInterface
 * @export
 * @interface NegotiableQuoteDataCompanyQuoteConfigInterface
 */
export interface NegotiableQuoteDataCompanyQuoteConfigInterface {
    /**
     * Company id
     * @type {string}
     * @memberof NegotiableQuoteDataCompanyQuoteConfigInterface
     */
    companyId?: string;
    /**
     * Quote enabled for company
     * @type {boolean}
     * @memberof NegotiableQuoteDataCompanyQuoteConfigInterface
     */
    isQuoteEnabled: boolean;
    /**
     *
     * @type {NegotiableQuoteDataCompanyQuoteConfigExtensionInterface}
     * @memberof NegotiableQuoteDataCompanyQuoteConfigInterface
     */
    extensionAttributes?: NegotiableQuoteDataCompanyQuoteConfigExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\NegotiableQuoteInterface
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteExtensionInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteExtensionInterface {
}

/**
 * Interface NegotiableQuoteInterface
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteInterface {
    /**
     * Negotiable quote ID.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    quoteId: number;
    /**
     * Is regular quote.
     * @type {boolean}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    isRegularQuote: boolean;
    /**
     * Negotiable quote status.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    status: string;
    /**
     * Negotiated price type.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    negotiatedPriceType: number;
    /**
     * Negotiated price value.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    negotiatedPriceValue: number;
    /**
     * Proposed shipping price.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    shippingPrice: number;
    /**
     * Negotiable quote name.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    quoteName: string;
    /**
     * Expiration period.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    expirationPeriod: string;
    /**
     * Email notification status.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    emailNotificationStatus: number;
    /**
     * Has unconfirmed changes.
     * @type {boolean}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    hasUnconfirmedChanges: boolean;
    /**
     * Shipping tax changes.
     * @type {boolean}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    isShippingTaxChanged: boolean;
    /**
     * Customer price changes.
     * @type {boolean}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    isCustomerPriceChanged: boolean;
    /**
     * Quote notifications.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    notifications: number;
    /**
     * Quote rules.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    appliedRuleIds: string;
    /**
     * Is address draft.
     * @type {boolean}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    isAddressDraft: boolean;
    /**
     * Deleted products sku.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    deletedSku: string;
    /**
     * Quote creator id.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    creatorId: number;
    /**
     * Quote creator type.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    creatorType: number;
    /**
     * Quote original total price.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    originalTotalPrice?: number;
    /**
     * Quote original total price in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    baseOriginalTotalPrice?: number;
    /**
     * Quote negotiated total price.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    negotiatedTotalPrice?: number;
    /**
     * Quote negotiated total price in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    baseNegotiatedTotalPrice?: number;
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteExtensionInterface}
     * @memberof NegotiableQuoteDataNegotiableQuoteInterface
     */
    extensionAttributes?: NegotiableQuoteDataNegotiableQuoteExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\NegotiableQuoteItemInterface
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteItemExtensionInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteItemExtensionInterface {
}

/**
 * Interface CompanyQuoteConfigInterface
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteItemInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteItemInterface {
    /**
     * Quote item id
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemInterface
     */
    itemId: number;
    /**
     * Quote item original price
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemInterface
     */
    originalPrice: number;
    /**
     * Quote item original tax amount
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemInterface
     */
    originalTaxAmount: number;
    /**
     * Quote item original discount amount
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemInterface
     */
    originalDiscountAmount: number;
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteItemExtensionInterface}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemInterface
     */
    extensionAttributes?: NegotiableQuoteDataNegotiableQuoteItemExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\NegotiableQuote\\Api\\Data\\NegotiableQuoteItemTotalsInterface
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteItemTotalsExtensionInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteItemTotalsExtensionInterface {
}

/**
 * Extension attribute for quote item totals model.
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteItemTotalsInterface {
    /**
     * Cost for quote item.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    cost: number;
    /**
     * Catalog price for quote item.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    catalogPrice: number;
    /**
     * Catalog price for quote item in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    baseCatalogPrice: number;
    /**
     * Catalog price with included tax for quote item.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    catalogPriceInclTax: number;
    /**
     * Catalog price with included tax for quote item in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    baseCatalogPriceInclTax: number;
    /**
     * Cart price for quote item.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    cartPrice: number;
    /**
     * Cart price for quote item in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    baseCartPrice: number;
    /**
     * Tax from catalog price for quote item.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    cartTax: number;
    /**
     * Tax from catalog price for quote item in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    baseCartTax: number;
    /**
     * Cart price with included tax for quote item.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    cartPriceInclTax: number;
    /**
     * Cart price with included tax for quote item in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    baseCartPriceInclTax: number;
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteItemTotalsExtensionInterface}
     * @memberof NegotiableQuoteDataNegotiableQuoteItemTotalsInterface
     */
    extensionAttributes?: NegotiableQuoteDataNegotiableQuoteItemTotalsExtensionInterface;
}

/**
 * Extension attribute for quote totals model.
 * @export
 * @interface NegotiableQuoteDataNegotiableQuoteTotalsInterface
 */
export interface NegotiableQuoteDataNegotiableQuoteTotalsInterface {
    /**
     * The number of different items or products in the cart.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    itemsCount: number;
    /**
     * Negotiable quote status.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    quoteStatus: string;
    /**
     * The cart creation date and time.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    createdAt: string;
    /**
     * The cart last update date and time.
     * @type {string}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    updatedAt: string;
    /**
     * Customer group id.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    customerGroup: number;
    /**
     * Base currency to quote currency rate.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    baseToQuoteRate: number;
    /**
     * Total cost for quote.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    costTotal: number;
    /**
     * Total cost for quote in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    baseCostTotal: number;
    /**
     * Original quote total.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    originalTotal: number;
    /**
     * Original quote total in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    baseOriginalTotal: number;
    /**
     * Original tax amount for quote.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    originalTax: number;
    /**
     * Original tax amount for quote in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    baseOriginalTax: number;
    /**
     * Original price with included tax for quote.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    originalPriceInclTax: number;
    /**
     * Original price with included tax for quote in base currency.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    baseOriginalPriceInclTax: number;
    /**
     * Negotiable quote type.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    negotiatedPriceType: number;
    /**
     * Negotiable price value for quote.
     * @type {number}
     * @memberof NegotiableQuoteDataNegotiableQuoteTotalsInterface
     */
    negotiatedPriceValue: number;
}

/**
 *
 * @export
 * @interface NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody
 */
export interface NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody {
    /**
     *
     * @type {GiftCardAccountDataGiftCardAccountInterface}
     * @memberof NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody
     */
    giftCardAccountData: GiftCardAccountDataGiftCardAccountInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuoteNegotiableCartRepositoryV1SavePutBody
 */
export interface NegotiableQuoteNegotiableCartRepositoryV1SavePutBody {
    /**
     *
     * @type {QuoteDataCartInterface}
     * @memberof NegotiableQuoteNegotiableCartRepositoryV1SavePutBody
     */
    quote: QuoteDataCartInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody
 */
export interface NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody {
    /**
     *
     * @type {number}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody
     */
    quoteId: number;
    /**
     *
     * @type {string}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody
     */
    comment?: string;
    /**
     *
     * @type {Array<NegotiableQuoteDataAttachmentContentInterface>}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody
     */
    files?: Array<NegotiableQuoteDataAttachmentContentInterface>;
}

/**
 *
 * @export
 * @interface NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody
 */
export interface NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody {
    /**
     *
     * @type {number}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody
     */
    quoteId: number;
    /**
     *
     * @type {string}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody
     */
    quoteName: string;
    /**
     *
     * @type {string}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody
     */
    comment?: string;
    /**
     *
     * @type {Array<NegotiableQuoteDataAttachmentContentInterface>}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody
     */
    files?: Array<NegotiableQuoteDataAttachmentContentInterface>;
}

/**
 *
 * @export
 * @interface NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody
 */
export interface NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody {
    /**
     *
     * @type {number}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody
     */
    quoteId: number;
    /**
     *
     * @type {string}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody
     */
    reason: string;
}

/**
 *
 * @export
 * @interface NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody
 */
export interface NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody {
    /**
     *
     * @type {Array<number>}
     * @memberof NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody
     */
    quoteIds: Array<number>;
}

/**
 *
 * @export
 * @interface NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody
 */
export interface NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody {
    /**
     * The shipping method code.
     * @type {string}
     * @memberof NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody
     */
    shippingMethod: string;
}

/**
 *
 * @export
 * @interface NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
 */
export interface NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody
 */
export interface NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody
 */
export interface NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody
     */
    address: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody
 */
export interface NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody {
    /**
     *
     * @type {CheckoutDataShippingInformationInterface}
     * @memberof NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody
     */
    addressInformation: CheckoutDataShippingInformationInterface;
}

/**
 *
 * @export
 * @interface NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody
 */
export interface NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody {
    /**
     * The estimate address id
     * @type {number}
     * @memberof NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody
     */
    addressId: number;
}

/**
 *
 * @export
 * @interface QuoteBillingAddressManagementV1AssignPostBody
 */
export interface QuoteBillingAddressManagementV1AssignPostBody {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteBillingAddressManagementV1AssignPostBody
     */
    address: QuoteDataAddressInterface;
    /**
     *
     * @type {boolean}
     * @memberof QuoteBillingAddressManagementV1AssignPostBody
     */
    useForShipping?: boolean;
}

/**
 *
 * @export
 * @interface QuoteBillingAddressManagementV1AssignPostBody1
 */
export interface QuoteBillingAddressManagementV1AssignPostBody1 {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteBillingAddressManagementV1AssignPostBody1
     */
    address: QuoteDataAddressInterface;
    /**
     *
     * @type {boolean}
     * @memberof QuoteBillingAddressManagementV1AssignPostBody1
     */
    useForShipping?: boolean;
}

/**
 *
 * @export
 * @interface QuoteCartItemRepositoryV1SavePostBody
 */
export interface QuoteCartItemRepositoryV1SavePostBody {
    /**
     *
     * @type {QuoteDataCartItemInterface}
     * @memberof QuoteCartItemRepositoryV1SavePostBody
     */
    cartItem: QuoteDataCartItemInterface;
}

/**
 *
 * @export
 * @interface QuoteCartItemRepositoryV1SavePostBody1
 */
export interface QuoteCartItemRepositoryV1SavePostBody1 {
    /**
     *
     * @type {QuoteDataCartItemInterface}
     * @memberof QuoteCartItemRepositoryV1SavePostBody1
     */
    cartItem: QuoteDataCartItemInterface;
}

/**
 *
 * @export
 * @interface QuoteCartItemRepositoryV1SavePutBody
 */
export interface QuoteCartItemRepositoryV1SavePutBody {
    /**
     *
     * @type {QuoteDataCartItemInterface}
     * @memberof QuoteCartItemRepositoryV1SavePutBody
     */
    cartItem: QuoteDataCartItemInterface;
}

/**
 *
 * @export
 * @interface QuoteCartItemRepositoryV1SavePutBody1
 */
export interface QuoteCartItemRepositoryV1SavePutBody1 {
    /**
     *
     * @type {QuoteDataCartItemInterface}
     * @memberof QuoteCartItemRepositoryV1SavePutBody1
     */
    cartItem: QuoteDataCartItemInterface;
}

/**
 *
 * @export
 * @interface QuoteCartManagementV1AssignCustomerPutBody
 */
export interface QuoteCartManagementV1AssignCustomerPutBody {
    /**
     * The customer ID.
     * @type {number}
     * @memberof QuoteCartManagementV1AssignCustomerPutBody
     */
    customerId: number;
    /**
     *
     * @type {number}
     * @memberof QuoteCartManagementV1AssignCustomerPutBody
     */
    storeId: number;
}

/**
 *
 * @export
 * @interface QuoteCartManagementV1PlaceOrderPutBody
 */
export interface QuoteCartManagementV1PlaceOrderPutBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuoteCartManagementV1PlaceOrderPutBody
     */
    paymentMethod?: QuoteDataPaymentInterface;
}

/**
 *
 * @export
 * @interface QuoteCartManagementV1PlaceOrderPutBody1
 */
export interface QuoteCartManagementV1PlaceOrderPutBody1 {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuoteCartManagementV1PlaceOrderPutBody1
     */
    paymentMethod?: QuoteDataPaymentInterface;
}

/**
 *
 * @export
 * @interface QuoteCartRepositoryV1SavePutBody
 */
export interface QuoteCartRepositoryV1SavePutBody {
    /**
     *
     * @type {QuoteDataCartInterface}
     * @memberof QuoteCartRepositoryV1SavePutBody
     */
    quote: QuoteDataCartInterface;
}

/**
 *
 * @export
 * @interface QuoteCartTotalManagementV1CollectTotalsPutBody
 */
export interface QuoteCartTotalManagementV1CollectTotalsPutBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuoteCartTotalManagementV1CollectTotalsPutBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     * The carrier code.
     * @type {string}
     * @memberof QuoteCartTotalManagementV1CollectTotalsPutBody
     */
    shippingCarrierCode?: string;
    /**
     * The shipping method code.
     * @type {string}
     * @memberof QuoteCartTotalManagementV1CollectTotalsPutBody
     */
    shippingMethodCode?: string;
    /**
     *
     * @type {QuoteDataTotalsAdditionalDataInterface}
     * @memberof QuoteCartTotalManagementV1CollectTotalsPutBody
     */
    additionalData?: QuoteDataTotalsAdditionalDataInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\AddressInterface
 * @export
 * @interface QuoteDataAddressExtensionInterface
 */
export interface QuoteDataAddressExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof QuoteDataAddressExtensionInterface
     */
    giftRegistryId?: number;
}

/**
 * Interface AddressInterface
 * @export
 * @interface QuoteDataAddressInterface
 */
export interface QuoteDataAddressInterface {
    /**
     * Id
     * @type {number}
     * @memberof QuoteDataAddressInterface
     */
    id?: number;
    /**
     * Region name
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    region: string;
    /**
     * Region id
     * @type {number}
     * @memberof QuoteDataAddressInterface
     */
    regionId: number;
    /**
     * Region code
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    regionCode: string;
    /**
     * Country id
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    countryId: string;
    /**
     * Street
     * @type {Array<string>}
     * @memberof QuoteDataAddressInterface
     */
    street: Array<string>;
    /**
     * Company
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    company?: string;
    /**
     * Telephone number
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    telephone: string;
    /**
     * Fax number
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    fax?: string;
    /**
     * Postcode
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    postcode: string;
    /**
     * City name
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    city: string;
    /**
     * First name
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    firstname: string;
    /**
     * Last name
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    lastname: string;
    /**
     * Middle name
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    middlename?: string;
    /**
     * Prefix
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    prefix?: string;
    /**
     * Suffix
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    suffix?: string;
    /**
     * Vat id
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    vatId?: string;
    /**
     * Customer id
     * @type {number}
     * @memberof QuoteDataAddressInterface
     */
    customerId?: number;
    /**
     * Billing/shipping email
     * @type {string}
     * @memberof QuoteDataAddressInterface
     */
    email: string;
    /**
     * Same as billing flag
     * @type {number}
     * @memberof QuoteDataAddressInterface
     */
    sameAsBilling?: number;
    /**
     * Customer address id
     * @type {number}
     * @memberof QuoteDataAddressInterface
     */
    customerAddressId?: number;
    /**
     * Save in address book flag
     * @type {number}
     * @memberof QuoteDataAddressInterface
     */
    saveInAddressBook?: number;
    /**
     *
     * @type {QuoteDataAddressExtensionInterface}
     * @memberof QuoteDataAddressInterface
     */
    extensionAttributes?: QuoteDataAddressExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof QuoteDataAddressInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\CartInterface
 * @export
 * @interface QuoteDataCartExtensionInterface
 */
export interface QuoteDataCartExtensionInterface {
    /**
     *
     * @type {Array<QuoteDataShippingAssignmentInterface>}
     * @memberof QuoteDataCartExtensionInterface
     */
    shippingAssignments?: Array<QuoteDataShippingAssignmentInterface>;
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteInterface}
     * @memberof QuoteDataCartExtensionInterface
     */
    negotiableQuote?: NegotiableQuoteDataNegotiableQuoteInterface;
}

/**
 * Interface CartInterface
 * @export
 * @interface QuoteDataCartInterface
 */
export interface QuoteDataCartInterface {
    /**
     * Cart/quote ID.
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    id: number;
    /**
     * Cart creation date and time. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataCartInterface
     */
    createdAt?: string;
    /**
     * Cart last update date and time. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataCartInterface
     */
    updatedAt?: string;
    /**
     * Cart conversion date and time. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataCartInterface
     */
    convertedAt?: string;
    /**
     * Active status flag value. Otherwise, null.
     * @type {boolean}
     * @memberof QuoteDataCartInterface
     */
    isActive?: boolean;
    /**
     * Virtual flag value. Otherwise, null.
     * @type {boolean}
     * @memberof QuoteDataCartInterface
     */
    isVirtual?: boolean;
    /**
     * Array of items. Otherwise, null.
     * @type {Array<QuoteDataCartItemInterface>}
     * @memberof QuoteDataCartInterface
     */
    items?: Array<QuoteDataCartItemInterface>;
    /**
     * Number of different items or products in the cart. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    itemsCount?: number;
    /**
     * Total quantity of all cart items. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    itemsQty?: number;
    /**
     *
     * @type {CustomerDataCustomerInterface}
     * @memberof QuoteDataCartInterface
     */
    customer: CustomerDataCustomerInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteDataCartInterface
     */
    billingAddress?: QuoteDataAddressInterface;
    /**
     * Reserved order ID. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    reservedOrderId?: number;
    /**
     * Original order ID. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    origOrderId?: number;
    /**
     *
     * @type {QuoteDataCurrencyInterface}
     * @memberof QuoteDataCartInterface
     */
    currency?: QuoteDataCurrencyInterface;
    /**
     * For guest customers, false for logged in customers
     * @type {boolean}
     * @memberof QuoteDataCartInterface
     */
    customerIsGuest?: boolean;
    /**
     * Notice text
     * @type {string}
     * @memberof QuoteDataCartInterface
     */
    customerNote?: string;
    /**
     * Customer notification flag
     * @type {boolean}
     * @memberof QuoteDataCartInterface
     */
    customerNoteNotify?: boolean;
    /**
     * Customer tax class ID.
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    customerTaxClassId?: number;
    /**
     * Store identifier
     * @type {number}
     * @memberof QuoteDataCartInterface
     */
    storeId: number;
    /**
     *
     * @type {QuoteDataCartExtensionInterface}
     * @memberof QuoteDataCartInterface
     */
    extensionAttributes?: QuoteDataCartExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\CartItemInterface
 * @export
 * @interface QuoteDataCartItemExtensionInterface
 */
export interface QuoteDataCartItemExtensionInterface {
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteItemInterface}
     * @memberof QuoteDataCartItemExtensionInterface
     */
    negotiableQuoteItem?: NegotiableQuoteDataNegotiableQuoteItemInterface;
}

/**
 * Interface CartItemInterface
 * @export
 * @interface QuoteDataCartItemInterface
 */
export interface QuoteDataCartItemInterface {
    /**
     * Item ID. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataCartItemInterface
     */
    itemId?: number;
    /**
     * Product SKU. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataCartItemInterface
     */
    sku?: string;
    /**
     * Product quantity.
     * @type {number}
     * @memberof QuoteDataCartItemInterface
     */
    qty: number;
    /**
     * Product name. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataCartItemInterface
     */
    name?: string;
    /**
     * Product price. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataCartItemInterface
     */
    price?: number;
    /**
     * Product type. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataCartItemInterface
     */
    productType?: string;
    /**
     * Quote id.
     * @type {string}
     * @memberof QuoteDataCartItemInterface
     */
    quoteId: string;
    /**
     *
     * @type {QuoteDataProductOptionInterface}
     * @memberof QuoteDataCartItemInterface
     */
    productOption?: QuoteDataProductOptionInterface;
    /**
     *
     * @type {QuoteDataCartItemExtensionInterface}
     * @memberof QuoteDataCartItemInterface
     */
    extensionAttributes?: QuoteDataCartItemExtensionInterface;
}

/**
 * Interface CartSearchResultsInterface
 * @export
 * @interface QuoteDataCartSearchResultsInterface
 */
export interface QuoteDataCartSearchResultsInterface {
    /**
     * Carts list.
     * @type {Array<QuoteDataCartInterface>}
     * @memberof QuoteDataCartSearchResultsInterface
     */
    items: Array<QuoteDataCartInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof QuoteDataCartSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof QuoteDataCartSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\CurrencyInterface
 * @export
 * @interface QuoteDataCurrencyExtensionInterface
 */
export interface QuoteDataCurrencyExtensionInterface {
}

/**
 * Interface CurrencyInterface
 * @export
 * @interface QuoteDataCurrencyInterface
 */
export interface QuoteDataCurrencyInterface {
    /**
     * Global currency code
     * @type {string}
     * @memberof QuoteDataCurrencyInterface
     */
    globalCurrencyCode?: string;
    /**
     * Base currency code
     * @type {string}
     * @memberof QuoteDataCurrencyInterface
     */
    baseCurrencyCode?: string;
    /**
     * Store currency code
     * @type {string}
     * @memberof QuoteDataCurrencyInterface
     */
    storeCurrencyCode?: string;
    /**
     * Quote currency code
     * @type {string}
     * @memberof QuoteDataCurrencyInterface
     */
    quoteCurrencyCode?: string;
    /**
     * Store currency to base currency rate
     * @type {number}
     * @memberof QuoteDataCurrencyInterface
     */
    storeToBaseRate?: number;
    /**
     * Store currency to quote currency rate
     * @type {number}
     * @memberof QuoteDataCurrencyInterface
     */
    storeToQuoteRate?: number;
    /**
     * Base currency to global currency rate
     * @type {number}
     * @memberof QuoteDataCurrencyInterface
     */
    baseToGlobalRate?: number;
    /**
     * Base currency to quote currency rate
     * @type {number}
     * @memberof QuoteDataCurrencyInterface
     */
    baseToQuoteRate?: number;
    /**
     *
     * @type {QuoteDataCurrencyExtensionInterface}
     * @memberof QuoteDataCurrencyInterface
     */
    extensionAttributes?: QuoteDataCurrencyExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\PaymentInterface
 * @export
 * @interface QuoteDataPaymentExtensionInterface
 */
export interface QuoteDataPaymentExtensionInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof QuoteDataPaymentExtensionInterface
     */
    agreementIds?: Array<string>;
}

/**
 * Interface PaymentInterface
 * @export
 * @interface QuoteDataPaymentInterface
 */
export interface QuoteDataPaymentInterface {
    /**
     * Purchase order number
     * @type {string}
     * @memberof QuoteDataPaymentInterface
     */
    poNumber?: string;
    /**
     * Payment method code
     * @type {string}
     * @memberof QuoteDataPaymentInterface
     */
    method: string;
    /**
     * Payment additional details
     * @type {Array<string>}
     * @memberof QuoteDataPaymentInterface
     */
    additionalData?: Array<string>;
    /**
     *
     * @type {QuoteDataPaymentExtensionInterface}
     * @memberof QuoteDataPaymentInterface
     */
    extensionAttributes?: QuoteDataPaymentExtensionInterface;
}

/**
 * Interface PaymentMethodInterface
 * @export
 * @interface QuoteDataPaymentMethodInterface
 */
export interface QuoteDataPaymentMethodInterface {
    /**
     * Payment method code
     * @type {string}
     * @memberof QuoteDataPaymentMethodInterface
     */
    code: string;
    /**
     * Payment method title
     * @type {string}
     * @memberof QuoteDataPaymentMethodInterface
     */
    title: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\ProductOptionInterface
 * @export
 * @interface QuoteDataProductOptionExtensionInterface
 */
export interface QuoteDataProductOptionExtensionInterface {
    /**
     *
     * @type {Array<CatalogDataCustomOptionInterface>}
     * @memberof QuoteDataProductOptionExtensionInterface
     */
    customOptions?: Array<CatalogDataCustomOptionInterface>;
    /**
     *
     * @type {Array<BundleDataBundleOptionInterface>}
     * @memberof QuoteDataProductOptionExtensionInterface
     */
    bundleOptions?: Array<BundleDataBundleOptionInterface>;
    /**
     *
     * @type {Array<ConfigurableProductDataConfigurableItemOptionValueInterface>}
     * @memberof QuoteDataProductOptionExtensionInterface
     */
    configurableItemOptions?: Array<ConfigurableProductDataConfigurableItemOptionValueInterface>;
    /**
     *
     * @type {DownloadableDataDownloadableOptionInterface}
     * @memberof QuoteDataProductOptionExtensionInterface
     */
    downloadableOption?: DownloadableDataDownloadableOptionInterface;
    /**
     *
     * @type {GiftCardDataGiftCardOptionInterface}
     * @memberof QuoteDataProductOptionExtensionInterface
     */
    giftcardItemOption?: GiftCardDataGiftCardOptionInterface;
}

/**
 * Product option interface
 * @export
 * @interface QuoteDataProductOptionInterface
 */
export interface QuoteDataProductOptionInterface {
    /**
     *
     * @type {QuoteDataProductOptionExtensionInterface}
     * @memberof QuoteDataProductOptionInterface
     */
    extensionAttributes?: QuoteDataProductOptionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\ShippingAssignmentInterface
 * @export
 * @interface QuoteDataShippingAssignmentExtensionInterface
 */
export interface QuoteDataShippingAssignmentExtensionInterface {
}

/**
 * Interface ShippingAssignmentInterface
 * @export
 * @interface QuoteDataShippingAssignmentInterface
 */
export interface QuoteDataShippingAssignmentInterface {
    /**
     *
     * @type {QuoteDataShippingInterface}
     * @memberof QuoteDataShippingAssignmentInterface
     */
    shipping: QuoteDataShippingInterface;
    /**
     *
     * @type {Array<QuoteDataCartItemInterface>}
     * @memberof QuoteDataShippingAssignmentInterface
     */
    items: Array<QuoteDataCartItemInterface>;
    /**
     *
     * @type {QuoteDataShippingAssignmentExtensionInterface}
     * @memberof QuoteDataShippingAssignmentInterface
     */
    extensionAttributes?: QuoteDataShippingAssignmentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\ShippingInterface
 * @export
 * @interface QuoteDataShippingExtensionInterface
 */
export interface QuoteDataShippingExtensionInterface {
}

/**
 * Interface ShippingInterface
 * @export
 * @interface QuoteDataShippingInterface
 */
export interface QuoteDataShippingInterface {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteDataShippingInterface
     */
    address: QuoteDataAddressInterface;
    /**
     * Shipping method
     * @type {string}
     * @memberof QuoteDataShippingInterface
     */
    method: string;
    /**
     *
     * @type {QuoteDataShippingExtensionInterface}
     * @memberof QuoteDataShippingInterface
     */
    extensionAttributes?: QuoteDataShippingExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\ShippingMethodInterface
 * @export
 * @interface QuoteDataShippingMethodExtensionInterface
 */
export interface QuoteDataShippingMethodExtensionInterface {
}

/**
 * Interface ShippingMethodInterface
 * @export
 * @interface QuoteDataShippingMethodInterface
 */
export interface QuoteDataShippingMethodInterface {
    /**
     * Shipping carrier code.
     * @type {string}
     * @memberof QuoteDataShippingMethodInterface
     */
    carrierCode: string;
    /**
     * Shipping method code.
     * @type {string}
     * @memberof QuoteDataShippingMethodInterface
     */
    methodCode: string;
    /**
     * Shipping carrier title. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataShippingMethodInterface
     */
    carrierTitle?: string;
    /**
     * Shipping method title. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataShippingMethodInterface
     */
    methodTitle?: string;
    /**
     * Shipping amount in store currency.
     * @type {number}
     * @memberof QuoteDataShippingMethodInterface
     */
    amount: number;
    /**
     * Shipping amount in base currency.
     * @type {number}
     * @memberof QuoteDataShippingMethodInterface
     */
    baseAmount: number;
    /**
     * The value of the availability flag for the current shipping method.
     * @type {boolean}
     * @memberof QuoteDataShippingMethodInterface
     */
    available: boolean;
    /**
     *
     * @type {QuoteDataShippingMethodExtensionInterface}
     * @memberof QuoteDataShippingMethodInterface
     */
    extensionAttributes?: QuoteDataShippingMethodExtensionInterface;
    /**
     * Shipping Error message.
     * @type {string}
     * @memberof QuoteDataShippingMethodInterface
     */
    errorMessage: string;
    /**
     * Shipping price excl tax.
     * @type {number}
     * @memberof QuoteDataShippingMethodInterface
     */
    priceExclTax: number;
    /**
     * Shipping price incl tax.
     * @type {number}
     * @memberof QuoteDataShippingMethodInterface
     */
    priceInclTax: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\TotalSegmentInterface
 * @export
 * @interface QuoteDataTotalSegmentExtensionInterface
 */
export interface QuoteDataTotalSegmentExtensionInterface {
    /**
     *
     * @type {Array<TaxDataGrandTotalDetailsInterface>}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    taxGrandtotalDetails?: Array<TaxDataGrandTotalDetailsInterface>;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    giftCards?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwOrderId?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemIds?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwAllowGiftReceipt?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwAddCard?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwPrice?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemsPrice?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemsBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwCardPrice?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwCardBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemsBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemsTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwCardBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwCardTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwPriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwBasePriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwCardPriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwCardBasePriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemsPriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalSegmentExtensionInterface
     */
    gwItemsBasePriceInclTax?: string;
}

/**
 * Interface TotalsInterface
 * @export
 * @interface QuoteDataTotalSegmentInterface
 */
export interface QuoteDataTotalSegmentInterface {
    /**
     * Code
     * @type {string}
     * @memberof QuoteDataTotalSegmentInterface
     */
    code: string;
    /**
     * Total title
     * @type {string}
     * @memberof QuoteDataTotalSegmentInterface
     */
    title?: string;
    /**
     * Total value
     * @type {number}
     * @memberof QuoteDataTotalSegmentInterface
     */
    value: number;
    /**
     * Display area code.
     * @type {string}
     * @memberof QuoteDataTotalSegmentInterface
     */
    area?: string;
    /**
     *
     * @type {QuoteDataTotalSegmentExtensionInterface}
     * @memberof QuoteDataTotalSegmentInterface
     */
    extensionAttributes?: QuoteDataTotalSegmentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\TotalsAdditionalDataInterface
 * @export
 * @interface QuoteDataTotalsAdditionalDataExtensionInterface
 */
export interface QuoteDataTotalsAdditionalDataExtensionInterface {
    /**
     *
     * @type {Array<GiftMessageDataMessageInterface>}
     * @memberof QuoteDataTotalsAdditionalDataExtensionInterface
     */
    giftMessages?: Array<GiftMessageDataMessageInterface>;
}

/**
 * Additional data for totals collection.
 * @export
 * @interface QuoteDataTotalsAdditionalDataInterface
 */
export interface QuoteDataTotalsAdditionalDataInterface {
    /**
     *
     * @type {QuoteDataTotalsAdditionalDataExtensionInterface}
     * @memberof QuoteDataTotalsAdditionalDataInterface
     */
    extensionAttributes?: QuoteDataTotalsAdditionalDataExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof QuoteDataTotalsAdditionalDataInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\TotalsInterface
 * @export
 * @interface QuoteDataTotalsExtensionInterface
 */
export interface QuoteDataTotalsExtensionInterface {
    /**
     *
     * @type {string}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    couponLabel?: string;
    /**
     *
     * @type {number}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    baseCustomerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    customerBalanceAmount?: number;
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteTotalsInterface}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    negotiableQuoteTotals?: NegotiableQuoteDataNegotiableQuoteTotalsInterface;
    /**
     *
     * @type {number}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    rewardPointsBalance?: number;
    /**
     *
     * @type {number}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    rewardCurrencyAmount?: number;
    /**
     *
     * @type {number}
     * @memberof QuoteDataTotalsExtensionInterface
     */
    baseRewardCurrencyAmount?: number;
}

/**
 * Interface TotalsInterface
 * @export
 * @interface QuoteDataTotalsInterface
 */
export interface QuoteDataTotalsInterface {
    /**
     * Grand total in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    grandTotal?: number;
    /**
     * Grand total in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseGrandTotal?: number;
    /**
     * Subtotal in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    subtotal?: number;
    /**
     * Subtotal in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseSubtotal?: number;
    /**
     * Discount amount in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    discountAmount?: number;
    /**
     * Discount amount in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseDiscountAmount?: number;
    /**
     * Subtotal in quote currency with applied discount
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    subtotalWithDiscount?: number;
    /**
     * Subtotal in base currency with applied discount
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseSubtotalWithDiscount?: number;
    /**
     * Shipping amount in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    shippingAmount?: number;
    /**
     * Shipping amount in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseShippingAmount?: number;
    /**
     * Shipping discount amount in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    shippingDiscountAmount?: number;
    /**
     * Shipping discount amount in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseShippingDiscountAmount?: number;
    /**
     * Tax amount in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    taxAmount?: number;
    /**
     * Tax amount in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseTaxAmount?: number;
    /**
     * Item weee tax applied amount in quote currency.
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    weeeTaxAppliedAmount: number;
    /**
     * Shipping tax amount in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    shippingTaxAmount?: number;
    /**
     * Shipping tax amount in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseShippingTaxAmount?: number;
    /**
     * Subtotal including tax in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    subtotalInclTax?: number;
    /**
     * Subtotal including tax in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseSubtotalInclTax?: number;
    /**
     * Shipping including tax in quote currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    shippingInclTax?: number;
    /**
     * Shipping including tax in base currency
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    baseShippingInclTax?: number;
    /**
     * Base currency code
     * @type {string}
     * @memberof QuoteDataTotalsInterface
     */
    baseCurrencyCode?: string;
    /**
     * Quote currency code
     * @type {string}
     * @memberof QuoteDataTotalsInterface
     */
    quoteCurrencyCode?: string;
    /**
     * Applied coupon code
     * @type {string}
     * @memberof QuoteDataTotalsInterface
     */
    couponCode?: string;
    /**
     * Items qty
     * @type {number}
     * @memberof QuoteDataTotalsInterface
     */
    itemsQty?: number;
    /**
     * Totals by items
     * @type {Array<QuoteDataTotalsItemInterface>}
     * @memberof QuoteDataTotalsInterface
     */
    items?: Array<QuoteDataTotalsItemInterface>;
    /**
     * Dynamically calculated totals
     * @type {Array<QuoteDataTotalSegmentInterface>}
     * @memberof QuoteDataTotalsInterface
     */
    totalSegments: Array<QuoteDataTotalSegmentInterface>;
    /**
     *
     * @type {QuoteDataTotalsExtensionInterface}
     * @memberof QuoteDataTotalsInterface
     */
    extensionAttributes?: QuoteDataTotalsExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Quote\\Api\\Data\\TotalsItemInterface
 * @export
 * @interface QuoteDataTotalsItemExtensionInterface
 */
export interface QuoteDataTotalsItemExtensionInterface {
    /**
     *
     * @type {NegotiableQuoteDataNegotiableQuoteItemTotalsInterface}
     * @memberof QuoteDataTotalsItemExtensionInterface
     */
    negotiableQuoteItemTotals?: NegotiableQuoteDataNegotiableQuoteItemTotalsInterface;
}

/**
 * Interface TotalsItemInterface
 * @export
 * @interface QuoteDataTotalsItemInterface
 */
export interface QuoteDataTotalsItemInterface {
    /**
     * Item id
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    itemId: number;
    /**
     * Item price in quote currency.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    price: number;
    /**
     * Item price in base currency.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    basePrice: number;
    /**
     * Item quantity.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    qty: number;
    /**
     * Row total in quote currency.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    rowTotal: number;
    /**
     * Row total in base currency.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    baseRowTotal: number;
    /**
     * Row total with discount in quote currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    rowTotalWithDiscount?: number;
    /**
     * Tax amount in quote currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    taxAmount?: number;
    /**
     * Tax amount in base currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    baseTaxAmount?: number;
    /**
     * Tax percent. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    taxPercent?: number;
    /**
     * Discount amount in quote currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    discountAmount?: number;
    /**
     * Discount amount in base currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    baseDiscountAmount?: number;
    /**
     * Discount percent. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    discountPercent?: number;
    /**
     * Price including tax in quote currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    priceInclTax?: number;
    /**
     * Price including tax in base currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    basePriceInclTax?: number;
    /**
     * Row total including tax in quote currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    rowTotalInclTax?: number;
    /**
     * Row total including tax in base currency. Otherwise, null.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    baseRowTotalInclTax?: number;
    /**
     * Item price in quote currency.
     * @type {string}
     * @memberof QuoteDataTotalsItemInterface
     */
    options: string;
    /**
     * Item weee tax applied amount in quote currency.
     * @type {number}
     * @memberof QuoteDataTotalsItemInterface
     */
    weeeTaxAppliedAmount: number;
    /**
     * Item weee tax applied in quote currency.
     * @type {string}
     * @memberof QuoteDataTotalsItemInterface
     */
    weeeTaxApplied: string;
    /**
     *
     * @type {QuoteDataTotalsItemExtensionInterface}
     * @memberof QuoteDataTotalsItemInterface
     */
    extensionAttributes?: QuoteDataTotalsItemExtensionInterface;
    /**
     * Product name. Otherwise, null.
     * @type {string}
     * @memberof QuoteDataTotalsItemInterface
     */
    name?: string;
}

/**
 *
 * @export
 * @interface QuoteGuestBillingAddressManagementV1AssignPostBody
 */
export interface QuoteGuestBillingAddressManagementV1AssignPostBody {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteGuestBillingAddressManagementV1AssignPostBody
     */
    address: QuoteDataAddressInterface;
    /**
     *
     * @type {boolean}
     * @memberof QuoteGuestBillingAddressManagementV1AssignPostBody
     */
    useForShipping?: boolean;
}

/**
 *
 * @export
 * @interface QuoteGuestCartItemRepositoryV1SavePostBody
 */
export interface QuoteGuestCartItemRepositoryV1SavePostBody {
    /**
     *
     * @type {QuoteDataCartItemInterface}
     * @memberof QuoteGuestCartItemRepositoryV1SavePostBody
     */
    cartItem: QuoteDataCartItemInterface;
}

/**
 *
 * @export
 * @interface QuoteGuestCartItemRepositoryV1SavePutBody
 */
export interface QuoteGuestCartItemRepositoryV1SavePutBody {
    /**
     *
     * @type {QuoteDataCartItemInterface}
     * @memberof QuoteGuestCartItemRepositoryV1SavePutBody
     */
    cartItem: QuoteDataCartItemInterface;
}

/**
 *
 * @export
 * @interface QuoteGuestCartManagementV1AssignCustomerPutBody
 */
export interface QuoteGuestCartManagementV1AssignCustomerPutBody {
    /**
     * The customer ID.
     * @type {number}
     * @memberof QuoteGuestCartManagementV1AssignCustomerPutBody
     */
    customerId: number;
    /**
     *
     * @type {number}
     * @memberof QuoteGuestCartManagementV1AssignCustomerPutBody
     */
    storeId: number;
}

/**
 *
 * @export
 * @interface QuoteGuestCartManagementV1PlaceOrderPutBody
 */
export interface QuoteGuestCartManagementV1PlaceOrderPutBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuoteGuestCartManagementV1PlaceOrderPutBody
     */
    paymentMethod?: QuoteDataPaymentInterface;
}

/**
 *
 * @export
 * @interface QuoteGuestCartTotalManagementV1CollectTotalsPutBody
 */
export interface QuoteGuestCartTotalManagementV1CollectTotalsPutBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuoteGuestCartTotalManagementV1CollectTotalsPutBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     * The carrier code.
     * @type {string}
     * @memberof QuoteGuestCartTotalManagementV1CollectTotalsPutBody
     */
    shippingCarrierCode?: string;
    /**
     * The shipping method code.
     * @type {string}
     * @memberof QuoteGuestCartTotalManagementV1CollectTotalsPutBody
     */
    shippingMethodCode?: string;
    /**
     *
     * @type {QuoteDataTotalsAdditionalDataInterface}
     * @memberof QuoteGuestCartTotalManagementV1CollectTotalsPutBody
     */
    additionalData?: QuoteDataTotalsAdditionalDataInterface;
}

/**
 *
 * @export
 * @interface QuoteGuestPaymentMethodManagementV1SetPutBody
 */
export interface QuoteGuestPaymentMethodManagementV1SetPutBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuoteGuestPaymentMethodManagementV1SetPutBody
     */
    method: QuoteDataPaymentInterface;
}

/**
 *
 * @export
 * @interface QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody
 */
export interface QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody
     */
    address: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface QuotePaymentMethodManagementV1SetPutBody
 */
export interface QuotePaymentMethodManagementV1SetPutBody {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuotePaymentMethodManagementV1SetPutBody
     */
    method: QuoteDataPaymentInterface;
}

/**
 *
 * @export
 * @interface QuotePaymentMethodManagementV1SetPutBody1
 */
export interface QuotePaymentMethodManagementV1SetPutBody1 {
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof QuotePaymentMethodManagementV1SetPutBody1
     */
    method: QuoteDataPaymentInterface;
}

/**
 *
 * @export
 * @interface QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody
 */
export interface QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody
     */
    address: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1
 */
export interface QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1 {
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1
     */
    address: QuoteDataAddressInterface;
}

/**
 *
 * @export
 * @interface QuoteShippingMethodManagementV1EstimateByAddressIdPostBody
 */
export interface QuoteShippingMethodManagementV1EstimateByAddressIdPostBody {
    /**
     * The estimate address id
     * @type {number}
     * @memberof QuoteShippingMethodManagementV1EstimateByAddressIdPostBody
     */
    addressId: number;
}

/**
 *
 * @export
 * @interface QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1
 */
export interface QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1 {
    /**
     * The estimate address id
     * @type {number}
     * @memberof QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1
     */
    addressId: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\RequisitionList\\Api\\Data\\RequisitionListInterface
 * @export
 * @interface RequisitionListDataRequisitionListExtensionInterface
 */
export interface RequisitionListDataRequisitionListExtensionInterface {
}

/**
 * Interface RequisitionListInterface
 * @export
 * @interface RequisitionListDataRequisitionListInterface
 */
export interface RequisitionListDataRequisitionListInterface {
    /**
     * Requisition List ID
     * @type {number}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    id: number;
    /**
     * Customer ID
     * @type {number}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    customerId: number;
    /**
     * Requisition List Name
     * @type {string}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    name: string;
    /**
     * Requisition List Update Time
     * @type {string}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    updatedAt: string;
    /**
     * Requisition List Description
     * @type {string}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    description: string;
    /**
     * Requisition List Items
     * @type {Array<RequisitionListDataRequisitionListItemInterface>}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    items: Array<RequisitionListDataRequisitionListItemInterface>;
    /**
     *
     * @type {RequisitionListDataRequisitionListExtensionInterface}
     * @memberof RequisitionListDataRequisitionListInterface
     */
    extensionAttributes?: RequisitionListDataRequisitionListExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\RequisitionList\\Api\\Data\\RequisitionListItemInterface
 * @export
 * @interface RequisitionListDataRequisitionListItemExtensionInterface
 */
export interface RequisitionListDataRequisitionListItemExtensionInterface {
}

/**
 * Interface RequisitionListItemInterface
 * @export
 * @interface RequisitionListDataRequisitionListItemInterface
 */
export interface RequisitionListDataRequisitionListItemInterface {
    /**
     * Requisition List ID.
     * @type {number}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    id: number;
    /**
     * Product SKU.
     * @type {number}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    sku: number;
    /**
     * Requisition List ID.
     * @type {number}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    requisitionListId: number;
    /**
     * Product Qty.
     * @type {number}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    qty: number;
    /**
     * Requisition list item options.
     * @type {Array<string>}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    options: Array<string>;
    /**
     * Store ID.
     * @type {number}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    storeId: number;
    /**
     * Added_at value.
     * @type {string}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    addedAt: string;
    /**
     *
     * @type {RequisitionListDataRequisitionListItemExtensionInterface}
     * @memberof RequisitionListDataRequisitionListItemInterface
     */
    extensionAttributes?: RequisitionListDataRequisitionListItemExtensionInterface;
}

/**
 *
 * @export
 * @interface RequisitionListRequisitionListRepositoryV1SavePostBody
 */
export interface RequisitionListRequisitionListRepositoryV1SavePostBody {
    /**
     *
     * @type {RequisitionListDataRequisitionListInterface}
     * @memberof RequisitionListRequisitionListRepositoryV1SavePostBody
     */
    requisitionList: RequisitionListDataRequisitionListInterface;
}

/**
 *
 * @export
 * @interface RmaCommentManagementV1AddCommentPostBody
 */
export interface RmaCommentManagementV1AddCommentPostBody {
    /**
     *
     * @type {RmaDataCommentInterface}
     * @memberof RmaCommentManagementV1AddCommentPostBody
     */
    data: RmaDataCommentInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Rma\\Api\\Data\\CommentInterface
 * @export
 * @interface RmaDataCommentExtensionInterface
 */
export interface RmaDataCommentExtensionInterface {
}

/**
 * Interface CommentInterface
 * @export
 * @interface RmaDataCommentInterface
 */
export interface RmaDataCommentInterface {
    /**
     * Comment
     * @type {string}
     * @memberof RmaDataCommentInterface
     */
    comment: string;
    /**
     * Rma Id
     * @type {number}
     * @memberof RmaDataCommentInterface
     */
    rmaEntityId: number;
    /**
     * Created_at
     * @type {string}
     * @memberof RmaDataCommentInterface
     */
    createdAt: string;
    /**
     * Entity_id
     * @type {number}
     * @memberof RmaDataCommentInterface
     */
    entityId: number;
    /**
     * Is_customer_notified
     * @type {boolean}
     * @memberof RmaDataCommentInterface
     */
    customerNotified: boolean;
    /**
     * Is_visible_on_front
     * @type {boolean}
     * @memberof RmaDataCommentInterface
     */
    visibleOnFront: boolean;
    /**
     * Status
     * @type {string}
     * @memberof RmaDataCommentInterface
     */
    status: string;
    /**
     * Is_admin
     * @type {boolean}
     * @memberof RmaDataCommentInterface
     */
    admin: boolean;
    /**
     *
     * @type {RmaDataCommentExtensionInterface}
     * @memberof RmaDataCommentInterface
     */
    extensionAttributes?: RmaDataCommentExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof RmaDataCommentInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * Interface CommentSearchResultInterface
 * @export
 * @interface RmaDataCommentSearchResultInterface
 */
export interface RmaDataCommentSearchResultInterface {
    /**
     * Rma Status History list
     * @type {Array<RmaDataCommentInterface>}
     * @memberof RmaDataCommentSearchResultInterface
     */
    items: Array<RmaDataCommentInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof RmaDataCommentSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof RmaDataCommentSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Rma\\Api\\Data\\ItemInterface
 * @export
 * @interface RmaDataItemExtensionInterface
 */
export interface RmaDataItemExtensionInterface {
}

/**
 * Interface CategoryInterface
 * @export
 * @interface RmaDataItemInterface
 */
export interface RmaDataItemInterface {
    /**
     * Id
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    entityId: number;
    /**
     * RMA id
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    rmaEntityId: number;
    /**
     * Order_item_id
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    orderItemId: number;
    /**
     * Qty_requested
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    qtyRequested: number;
    /**
     * Qty_authorized
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    qtyAuthorized: number;
    /**
     * Qty_approved
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    qtyApproved: number;
    /**
     * Qty_returned
     * @type {number}
     * @memberof RmaDataItemInterface
     */
    qtyReturned: number;
    /**
     * Reason
     * @type {string}
     * @memberof RmaDataItemInterface
     */
    reason: string;
    /**
     * Condition
     * @type {string}
     * @memberof RmaDataItemInterface
     */
    condition: string;
    /**
     * Resolution
     * @type {string}
     * @memberof RmaDataItemInterface
     */
    resolution: string;
    /**
     * Status
     * @type {string}
     * @memberof RmaDataItemInterface
     */
    status: string;
    /**
     *
     * @type {RmaDataItemExtensionInterface}
     * @memberof RmaDataItemInterface
     */
    extensionAttributes?: RmaDataItemExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Rma\\Api\\Data\\RmaInterface
 * @export
 * @interface RmaDataRmaExtensionInterface
 */
export interface RmaDataRmaExtensionInterface {
}

/**
 * Interface RmaInterface
 * @export
 * @interface RmaDataRmaInterface
 */
export interface RmaDataRmaInterface {
    /**
     * Entity_id
     * @type {string}
     * @memberof RmaDataRmaInterface
     */
    incrementId: string;
    /**
     * Entity_id
     * @type {number}
     * @memberof RmaDataRmaInterface
     */
    entityId: number;
    /**
     * Order_id
     * @type {number}
     * @memberof RmaDataRmaInterface
     */
    orderId: number;
    /**
     * Order_increment_id
     * @type {string}
     * @memberof RmaDataRmaInterface
     */
    orderIncrementId: string;
    /**
     * Store_id
     * @type {number}
     * @memberof RmaDataRmaInterface
     */
    storeId: number;
    /**
     * Customer_id
     * @type {number}
     * @memberof RmaDataRmaInterface
     */
    customerId: number;
    /**
     * Date_requested
     * @type {string}
     * @memberof RmaDataRmaInterface
     */
    dateRequested: string;
    /**
     * Customer_custom_email
     * @type {string}
     * @memberof RmaDataRmaInterface
     */
    customerCustomEmail: string;
    /**
     * Items
     * @type {Array<RmaDataItemInterface>}
     * @memberof RmaDataRmaInterface
     */
    items: Array<RmaDataItemInterface>;
    /**
     * Status
     * @type {string}
     * @memberof RmaDataRmaInterface
     */
    status: string;
    /**
     * Comments list
     * @type {Array<RmaDataCommentInterface>}
     * @memberof RmaDataRmaInterface
     */
    comments: Array<RmaDataCommentInterface>;
    /**
     * Tracks list
     * @type {Array<RmaDataTrackInterface>}
     * @memberof RmaDataRmaInterface
     */
    tracks: Array<RmaDataTrackInterface>;
    /**
     *
     * @type {RmaDataRmaExtensionInterface}
     * @memberof RmaDataRmaInterface
     */
    extensionAttributes?: RmaDataRmaExtensionInterface;
    /**
     * Custom attributes values.
     * @type {Array<FrameworkAttributeInterface>}
     * @memberof RmaDataRmaInterface
     */
    customAttributes?: Array<FrameworkAttributeInterface>;
}

/**
 * Interface RmaSearchResultInterface
 * @export
 * @interface RmaDataRmaSearchResultInterface
 */
export interface RmaDataRmaSearchResultInterface {
    /**
     * Rma list
     * @type {Array<RmaDataRmaInterface>}
     * @memberof RmaDataRmaSearchResultInterface
     */
    items: Array<RmaDataRmaInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof RmaDataRmaSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof RmaDataRmaSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Rma\\Api\\Data\\TrackInterface
 * @export
 * @interface RmaDataTrackExtensionInterface
 */
export interface RmaDataTrackExtensionInterface {
}

/**
 * Interface TrackInterface
 * @export
 * @interface RmaDataTrackInterface
 */
export interface RmaDataTrackInterface {
    /**
     * Entity id
     * @type {number}
     * @memberof RmaDataTrackInterface
     */
    entityId: number;
    /**
     * Rma entity id
     * @type {number}
     * @memberof RmaDataTrackInterface
     */
    rmaEntityId: number;
    /**
     * Track number
     * @type {string}
     * @memberof RmaDataTrackInterface
     */
    trackNumber: string;
    /**
     * Carrier title
     * @type {string}
     * @memberof RmaDataTrackInterface
     */
    carrierTitle: string;
    /**
     * Carrier code
     * @type {string}
     * @memberof RmaDataTrackInterface
     */
    carrierCode: string;
    /**
     *
     * @type {RmaDataTrackExtensionInterface}
     * @memberof RmaDataTrackInterface
     */
    extensionAttributes?: RmaDataTrackExtensionInterface;
}

/**
 * Interface TrackSearchResultInterface
 * @export
 * @interface RmaDataTrackSearchResultInterface
 */
export interface RmaDataTrackSearchResultInterface {
    /**
     * Rma list
     * @type {Array<RmaDataTrackInterface>}
     * @memberof RmaDataTrackSearchResultInterface
     */
    items: Array<RmaDataTrackInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof RmaDataTrackSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof RmaDataTrackSearchResultInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface RmaRmaManagementV1SaveRmaPostBody
 */
export interface RmaRmaManagementV1SaveRmaPostBody {
    /**
     *
     * @type {RmaDataRmaInterface}
     * @memberof RmaRmaManagementV1SaveRmaPostBody
     */
    rmaDataObject: RmaDataRmaInterface;
}

/**
 *
 * @export
 * @interface RmaRmaManagementV1SaveRmaPutBody
 */
export interface RmaRmaManagementV1SaveRmaPutBody {
    /**
     *
     * @type {RmaDataRmaInterface}
     * @memberof RmaRmaManagementV1SaveRmaPutBody
     */
    rmaDataObject: RmaDataRmaInterface;
}

/**
 *
 * @export
 * @interface RmaRmaRepositoryV1DeleteDeleteBody
 */
export interface RmaRmaRepositoryV1DeleteDeleteBody {
    /**
     *
     * @type {RmaDataRmaInterface}
     * @memberof RmaRmaRepositoryV1DeleteDeleteBody
     */
    rmaDataObject: RmaDataRmaInterface;
}

/**
 *
 * @export
 * @interface RmaTrackManagementV1AddTrackPostBody
 */
export interface RmaTrackManagementV1AddTrackPostBody {
    /**
     *
     * @type {RmaDataTrackInterface}
     * @memberof RmaTrackManagementV1AddTrackPostBody
     */
    track: RmaDataTrackInterface;
}

/**
 *
 * @export
 * @interface SalesCreditmemoCommentRepositoryV1SavePostBody
 */
export interface SalesCreditmemoCommentRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataCreditmemoCommentInterface}
     * @memberof SalesCreditmemoCommentRepositoryV1SavePostBody
     */
    entity: SalesDataCreditmemoCommentInterface;
}

/**
 *
 * @export
 * @interface SalesCreditmemoManagementV1RefundPostBody
 */
export interface SalesCreditmemoManagementV1RefundPostBody {
    /**
     *
     * @type {SalesDataCreditmemoInterface}
     * @memberof SalesCreditmemoManagementV1RefundPostBody
     */
    creditmemo: SalesDataCreditmemoInterface;
    /**
     *
     * @type {boolean}
     * @memberof SalesCreditmemoManagementV1RefundPostBody
     */
    offlineRequested?: boolean;
}

/**
 *
 * @export
 * @interface SalesCreditmemoRepositoryV1SavePostBody
 */
export interface SalesCreditmemoRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataCreditmemoInterface}
     * @memberof SalesCreditmemoRepositoryV1SavePostBody
     */
    entity: SalesDataCreditmemoInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\CreditmemoCommentCreationInterface
 * @export
 * @interface SalesDataCreditmemoCommentCreationExtensionInterface
 */
export interface SalesDataCreditmemoCommentCreationExtensionInterface {
}

/**
 * Interface CreditmemoCommentCreationInterface
 * @export
 * @interface SalesDataCreditmemoCommentCreationInterface
 */
export interface SalesDataCreditmemoCommentCreationInterface {
    /**
     *
     * @type {SalesDataCreditmemoCommentCreationExtensionInterface}
     * @memberof SalesDataCreditmemoCommentCreationInterface
     */
    extensionAttributes?: SalesDataCreditmemoCommentCreationExtensionInterface;
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataCreditmemoCommentCreationInterface
     */
    comment: string;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataCreditmemoCommentCreationInterface
     */
    isVisibleOnFront: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\CreditmemoCommentInterface
 * @export
 * @interface SalesDataCreditmemoCommentExtensionInterface
 */
export interface SalesDataCreditmemoCommentExtensionInterface {
}

/**
 * Credit memo comment interface. After a customer places and pays for an order and an invoice has been issued, the merchant can create a credit memo to refund all or part of the amount paid for any returned or undelivered items. The memo restores funds to the customer account so that the customer can make future purchases. A credit memo usually includes comments that detail why the credit memo amount was credited to the customer.
 * @export
 * @interface SalesDataCreditmemoCommentInterface
 */
export interface SalesDataCreditmemoCommentInterface {
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    comment: string;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    createdAt?: string;
    /**
     * Credit memo ID.
     * @type {number}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    entityId?: number;
    /**
     * Is-customer-notified flag value.
     * @type {number}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    isCustomerNotified: number;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    isVisibleOnFront: number;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    parentId: number;
    /**
     *
     * @type {SalesDataCreditmemoCommentExtensionInterface}
     * @memberof SalesDataCreditmemoCommentInterface
     */
    extensionAttributes?: SalesDataCreditmemoCommentExtensionInterface;
}

/**
 * Credit memo comment search result interface. After a customer places and pays for an order and an invoice has been issued, the merchant can create a credit memo to refund all or part of the amount paid for any returned or undelivered items. The memo restores funds to the customer account so that the customer can make future purchases. A credit memo usually includes comments that detail why the credit memo amount was credited to the customer.
 * @export
 * @interface SalesDataCreditmemoCommentSearchResultInterface
 */
export interface SalesDataCreditmemoCommentSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataCreditmemoCommentInterface>}
     * @memberof SalesDataCreditmemoCommentSearchResultInterface
     */
    items: Array<SalesDataCreditmemoCommentInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataCreditmemoCommentSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataCreditmemoCommentSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\CreditmemoCreationArgumentsInterface
 * @export
 * @interface SalesDataCreditmemoCreationArgumentsExtensionInterface
 */
export interface SalesDataCreditmemoCreationArgumentsExtensionInterface {
    /**
     *
     * @type {Array<number>}
     * @memberof SalesDataCreditmemoCreationArgumentsExtensionInterface
     */
    returnToStockItems?: Array<number>;
}

/**
 * Interface CreditmemoCreationArgumentsInterface
 * @export
 * @interface SalesDataCreditmemoCreationArgumentsInterface
 */
export interface SalesDataCreditmemoCreationArgumentsInterface {
    /**
     * Credit memo shipping amount.
     * @type {number}
     * @memberof SalesDataCreditmemoCreationArgumentsInterface
     */
    shippingAmount?: number;
    /**
     * Credit memo positive adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoCreationArgumentsInterface
     */
    adjustmentPositive?: number;
    /**
     * Credit memo negative adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoCreationArgumentsInterface
     */
    adjustmentNegative?: number;
    /**
     *
     * @type {SalesDataCreditmemoCreationArgumentsExtensionInterface}
     * @memberof SalesDataCreditmemoCreationArgumentsInterface
     */
    extensionAttributes?: SalesDataCreditmemoCreationArgumentsExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\CreditmemoInterface
 * @export
 * @interface SalesDataCreditmemoExtensionInterface
 */
export interface SalesDataCreditmemoExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    baseCustomerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    customerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    baseGiftCardsAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    giftCardsAmount?: number;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwItemsBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwItemsPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwCardBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwCardPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwItemsBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwItemsTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwCardBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataCreditmemoExtensionInterface
     */
    gwCardTaxAmount?: string;
}

/**
 * Credit memo interface. After a customer places and pays for an order and an invoice has been issued, the merchant can create a credit memo to refund all or part of the amount paid for any returned or undelivered items. The memo restores funds to the customer account so that the customer can make future purchases.
 * @export
 * @interface SalesDataCreditmemoInterface
 */
export interface SalesDataCreditmemoInterface {
    /**
     * Credit memo adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    adjustment?: number;
    /**
     * Credit memo negative adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    adjustmentNegative?: number;
    /**
     * Credit memo positive adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    adjustmentPositive?: number;
    /**
     * Credit memo base adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseAdjustment?: number;
    /**
     * Credit memo negative base adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseAdjustmentNegative?: number;
    /**
     * Credit memo positive base adjustment.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseAdjustmentPositive?: number;
    /**
     * Credit memo base currency code.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    baseCurrencyCode?: string;
    /**
     * Credit memo base discount amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseDiscountAmount?: number;
    /**
     * Credit memo base grand total.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseGrandTotal?: number;
    /**
     * Credit memo base discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseDiscountTaxCompensationAmount?: number;
    /**
     * Credit memo base shipping amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseShippingAmount?: number;
    /**
     * Credit memo base shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseShippingDiscountTaxCompensationAmnt?: number;
    /**
     * Credit memo base shipping including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseShippingInclTax?: number;
    /**
     * Credit memo base shipping tax amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseShippingTaxAmount?: number;
    /**
     * Credit memo base subtotal.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseSubtotal?: number;
    /**
     * Credit memo base subtotal including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseSubtotalInclTax?: number;
    /**
     * Credit memo base tax amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseTaxAmount?: number;
    /**
     * Credit memo base-to-global rate.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseToGlobalRate?: number;
    /**
     * Credit memo base-to-order rate.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    baseToOrderRate?: number;
    /**
     * Credit memo billing address ID.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    billingAddressId?: number;
    /**
     * Credit memo created-at timestamp.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    createdAt?: string;
    /**
     * Credit memo status.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    creditmemoStatus?: number;
    /**
     * Credit memo discount amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    discountAmount?: number;
    /**
     * Credit memo discount description.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    discountDescription?: string;
    /**
     * Credit memo email sent flag value.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    emailSent?: number;
    /**
     * Credit memo ID.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    entityId?: number;
    /**
     * Credit memo global currency code.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    globalCurrencyCode?: string;
    /**
     * Credit memo grand total.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    grandTotal?: number;
    /**
     * Credit memo discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    discountTaxCompensationAmount?: number;
    /**
     * Credit memo increment ID.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    incrementId?: string;
    /**
     * Credit memo invoice ID.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    invoiceId?: number;
    /**
     * Credit memo order currency code.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    orderCurrencyCode?: string;
    /**
     * Credit memo order ID.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    orderId: number;
    /**
     * Credit memo shipping address ID.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    shippingAddressId?: number;
    /**
     * Credit memo shipping amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    shippingAmount?: number;
    /**
     * Credit memo shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    shippingDiscountTaxCompensationAmount?: number;
    /**
     * Credit memo shipping including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    shippingInclTax?: number;
    /**
     * Credit memo shipping tax amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    shippingTaxAmount?: number;
    /**
     * Credit memo state.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    state?: number;
    /**
     * Credit memo store currency code.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    storeCurrencyCode?: string;
    /**
     * Credit memo store ID.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    storeId?: number;
    /**
     * Credit memo store-to-base rate.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    storeToBaseRate?: number;
    /**
     * Credit memo store-to-order rate.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    storeToOrderRate?: number;
    /**
     * Credit memo subtotal.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    subtotal?: number;
    /**
     * Credit memo subtotal including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    subtotalInclTax?: number;
    /**
     * Credit memo tax amount.
     * @type {number}
     * @memberof SalesDataCreditmemoInterface
     */
    taxAmount?: number;
    /**
     * Credit memo transaction ID.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    transactionId?: string;
    /**
     * Credit memo updated-at timestamp.
     * @type {string}
     * @memberof SalesDataCreditmemoInterface
     */
    updatedAt?: string;
    /**
     * Array of credit memo items.
     * @type {Array<SalesDataCreditmemoItemInterface>}
     * @memberof SalesDataCreditmemoInterface
     */
    items: Array<SalesDataCreditmemoItemInterface>;
    /**
     * Array of any credit memo comments. Otherwise, null.
     * @type {Array<SalesDataCreditmemoCommentInterface>}
     * @memberof SalesDataCreditmemoInterface
     */
    comments?: Array<SalesDataCreditmemoCommentInterface>;
    /**
     *
     * @type {SalesDataCreditmemoExtensionInterface}
     * @memberof SalesDataCreditmemoInterface
     */
    extensionAttributes?: SalesDataCreditmemoExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\CreditmemoItemCreationInterface
 * @export
 * @interface SalesDataCreditmemoItemCreationExtensionInterface
 */
export interface SalesDataCreditmemoItemCreationExtensionInterface {
}

/**
 * Interface CreditmemoItemCreationInterface
 * @export
 * @interface SalesDataCreditmemoItemCreationInterface
 */
export interface SalesDataCreditmemoItemCreationInterface {
    /**
     *
     * @type {SalesDataCreditmemoItemCreationExtensionInterface}
     * @memberof SalesDataCreditmemoItemCreationInterface
     */
    extensionAttributes?: SalesDataCreditmemoItemCreationExtensionInterface;
    /**
     * Order item ID.
     * @type {number}
     * @memberof SalesDataCreditmemoItemCreationInterface
     */
    orderItemId: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataCreditmemoItemCreationInterface
     */
    qty: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\CreditmemoItemInterface
 * @export
 * @interface SalesDataCreditmemoItemExtensionInterface
 */
export interface SalesDataCreditmemoItemExtensionInterface {
}

/**
 * Credit memo item interface. After a customer places and pays for an order and an invoice has been issued, the merchant can create a credit memo to refund all or part of the amount paid for any returned or undelivered items. The memo restores funds to the customer account so that the customer can make future purchases. A credit memo item is an invoiced item for which a merchant creates a credit memo.
 * @export
 * @interface SalesDataCreditmemoItemInterface
 */
export interface SalesDataCreditmemoItemInterface {
    /**
     * Additional data.
     * @type {string}
     * @memberof SalesDataCreditmemoItemInterface
     */
    additionalData?: string;
    /**
     * The base cost for a credit memo item.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseCost: number;
    /**
     * The base discount amount for a credit memo item.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseDiscountAmount?: number;
    /**
     * The base discount tax compensation amount for a credit memo item.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseDiscountTaxCompensationAmount?: number;
    /**
     * The base price for a credit memo item.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    basePrice: number;
    /**
     * Base price including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    basePriceInclTax?: number;
    /**
     * Base row total.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseRowTotal?: number;
    /**
     * Base row total including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseRowTotalInclTax?: number;
    /**
     * Base tax amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseTaxAmount?: number;
    /**
     * Base WEEE tax applied amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseWeeeTaxAppliedAmount?: number;
    /**
     * Base WEEE tax applied row amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseWeeeTaxAppliedRowAmnt?: number;
    /**
     * Base WEEE tax disposition.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseWeeeTaxDisposition?: number;
    /**
     * Base WEEE tax row disposition.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    baseWeeeTaxRowDisposition?: number;
    /**
     * Description.
     * @type {string}
     * @memberof SalesDataCreditmemoItemInterface
     */
    description?: string;
    /**
     * Discount amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    discountAmount?: number;
    /**
     * Credit memo item ID.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    entityId: number;
    /**
     * Discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    discountTaxCompensationAmount?: number;
    /**
     * Name.
     * @type {string}
     * @memberof SalesDataCreditmemoItemInterface
     */
    name?: string;
    /**
     * Order item ID.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    orderItemId: number;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    parentId?: number;
    /**
     * Price.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    price?: number;
    /**
     * Price including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    priceInclTax?: number;
    /**
     * Product ID.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    productId?: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    qty: number;
    /**
     * Row total.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    rowTotal?: number;
    /**
     * Row total including tax.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    rowTotalInclTax?: number;
    /**
     * SKU.
     * @type {string}
     * @memberof SalesDataCreditmemoItemInterface
     */
    sku?: string;
    /**
     * Tax amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    taxAmount?: number;
    /**
     * WEEE tax applied.
     * @type {string}
     * @memberof SalesDataCreditmemoItemInterface
     */
    weeeTaxApplied?: string;
    /**
     * WEEE tax applied amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    weeeTaxAppliedAmount?: number;
    /**
     * WEEE tax applied row amount.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    weeeTaxAppliedRowAmount?: number;
    /**
     * WEEE tax disposition.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    weeeTaxDisposition?: number;
    /**
     * WEEE tax row disposition.
     * @type {number}
     * @memberof SalesDataCreditmemoItemInterface
     */
    weeeTaxRowDisposition?: number;
    /**
     *
     * @type {SalesDataCreditmemoItemExtensionInterface}
     * @memberof SalesDataCreditmemoItemInterface
     */
    extensionAttributes?: SalesDataCreditmemoItemExtensionInterface;
}

/**
 * Credit memo search result interface. After a customer places and pays for an order and an invoice has been issued, the merchant can create a credit memo to refund all or part of the amount paid for any returned or undelivered items. The memo restores funds to the customer account so that the customer can make future purchases.
 * @export
 * @interface SalesDataCreditmemoSearchResultInterface
 */
export interface SalesDataCreditmemoSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataCreditmemoInterface>}
     * @memberof SalesDataCreditmemoSearchResultInterface
     */
    items: Array<SalesDataCreditmemoInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataCreditmemoSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataCreditmemoSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\InvoiceCommentCreationInterface
 * @export
 * @interface SalesDataInvoiceCommentCreationExtensionInterface
 */
export interface SalesDataInvoiceCommentCreationExtensionInterface {
}

/**
 * Interface InvoiceCommentCreationInterface
 * @export
 * @interface SalesDataInvoiceCommentCreationInterface
 */
export interface SalesDataInvoiceCommentCreationInterface {
    /**
     *
     * @type {SalesDataInvoiceCommentCreationExtensionInterface}
     * @memberof SalesDataInvoiceCommentCreationInterface
     */
    extensionAttributes?: SalesDataInvoiceCommentCreationExtensionInterface;
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataInvoiceCommentCreationInterface
     */
    comment: string;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataInvoiceCommentCreationInterface
     */
    isVisibleOnFront: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\InvoiceCommentInterface
 * @export
 * @interface SalesDataInvoiceCommentExtensionInterface
 */
export interface SalesDataInvoiceCommentExtensionInterface {
}

/**
 * Invoice comment interface. An invoice is a record of the receipt of payment for an order. An invoice can include comments that detail the invoice history.
 * @export
 * @interface SalesDataInvoiceCommentInterface
 */
export interface SalesDataInvoiceCommentInterface {
    /**
     * Is-customer-notified flag value.
     * @type {number}
     * @memberof SalesDataInvoiceCommentInterface
     */
    isCustomerNotified: number;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataInvoiceCommentInterface
     */
    parentId: number;
    /**
     *
     * @type {SalesDataInvoiceCommentExtensionInterface}
     * @memberof SalesDataInvoiceCommentInterface
     */
    extensionAttributes?: SalesDataInvoiceCommentExtensionInterface;
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataInvoiceCommentInterface
     */
    comment: string;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataInvoiceCommentInterface
     */
    isVisibleOnFront: number;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataInvoiceCommentInterface
     */
    createdAt?: string;
    /**
     * Invoice ID.
     * @type {number}
     * @memberof SalesDataInvoiceCommentInterface
     */
    entityId?: number;
}

/**
 * Invoice comment search result interface. An invoice is a record of the receipt of payment for an order. An invoice can include comments that detail the invoice history.
 * @export
 * @interface SalesDataInvoiceCommentSearchResultInterface
 */
export interface SalesDataInvoiceCommentSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataInvoiceCommentInterface>}
     * @memberof SalesDataInvoiceCommentSearchResultInterface
     */
    items: Array<SalesDataInvoiceCommentInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataInvoiceCommentSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataInvoiceCommentSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\InvoiceCreationArgumentsInterface
 * @export
 * @interface SalesDataInvoiceCreationArgumentsExtensionInterface
 */
export interface SalesDataInvoiceCreationArgumentsExtensionInterface {
}

/**
 * Interface for creation arguments for Invoice.
 * @export
 * @interface SalesDataInvoiceCreationArgumentsInterface
 */
export interface SalesDataInvoiceCreationArgumentsInterface {
    /**
     *
     * @type {SalesDataInvoiceCreationArgumentsExtensionInterface}
     * @memberof SalesDataInvoiceCreationArgumentsInterface
     */
    extensionAttributes?: SalesDataInvoiceCreationArgumentsExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\InvoiceInterface
 * @export
 * @interface SalesDataInvoiceExtensionInterface
 */
export interface SalesDataInvoiceExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    baseCustomerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    customerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    baseGiftCardsAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    giftCardsAmount?: number;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwItemsBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwItemsPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwCardBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwCardPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwItemsBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwItemsTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwCardBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataInvoiceExtensionInterface
     */
    gwCardTaxAmount?: string;
}

/**
 * Invoice interface. An invoice is a record of the receipt of payment for an order.
 * @export
 * @interface SalesDataInvoiceInterface
 */
export interface SalesDataInvoiceInterface {
    /**
     * Base currency code.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    baseCurrencyCode?: string;
    /**
     * Base discount amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseDiscountAmount?: number;
    /**
     * Base grand total.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseGrandTotal?: number;
    /**
     * Base discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseDiscountTaxCompensationAmount?: number;
    /**
     * Base shipping amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseShippingAmount?: number;
    /**
     * Base shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseShippingDiscountTaxCompensationAmnt?: number;
    /**
     * Base shipping including tax.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseShippingInclTax?: number;
    /**
     * Base shipping tax amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseShippingTaxAmount?: number;
    /**
     * Base subtotal.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseSubtotal?: number;
    /**
     * Base subtotal including tax.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseSubtotalInclTax?: number;
    /**
     * Base tax amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseTaxAmount?: number;
    /**
     * Base total refunded.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseTotalRefunded?: number;
    /**
     * Base-to-global rate.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseToGlobalRate?: number;
    /**
     * Base-to-order rate.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    baseToOrderRate?: number;
    /**
     * Billing address ID.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    billingAddressId?: number;
    /**
     * Can void flag value.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    canVoidFlag?: number;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    createdAt?: string;
    /**
     * Discount amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    discountAmount?: number;
    /**
     * Discount description.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    discountDescription?: string;
    /**
     * Email-sent flag value.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    emailSent?: number;
    /**
     * Invoice ID.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    entityId?: number;
    /**
     * Global currency code.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    globalCurrencyCode?: string;
    /**
     * Grand total.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    grandTotal?: number;
    /**
     * Discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    discountTaxCompensationAmount?: number;
    /**
     * Increment ID.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    incrementId?: string;
    /**
     * Is-used-for-refund flag value.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    isUsedForRefund?: number;
    /**
     * Order currency code.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    orderCurrencyCode?: string;
    /**
     * Order ID.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    orderId: number;
    /**
     * Shipping address ID.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    shippingAddressId?: number;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    shippingAmount?: number;
    /**
     * Shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    shippingDiscountTaxCompensationAmount?: number;
    /**
     * Shipping including tax.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    shippingInclTax?: number;
    /**
     * Shipping tax amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    shippingTaxAmount?: number;
    /**
     * State.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    state?: number;
    /**
     * Store currency code.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    storeCurrencyCode?: string;
    /**
     * Store ID.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    storeId?: number;
    /**
     * Store-to-base rate.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    storeToBaseRate?: number;
    /**
     * Store-to-order rate.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    storeToOrderRate?: number;
    /**
     * Subtotal.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    subtotal?: number;
    /**
     * Subtotal including tax.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    subtotalInclTax?: number;
    /**
     * Tax amount.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    taxAmount?: number;
    /**
     * Total quantity.
     * @type {number}
     * @memberof SalesDataInvoiceInterface
     */
    totalQty: number;
    /**
     * Transaction ID.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    transactionId?: string;
    /**
     * Updated-at timestamp.
     * @type {string}
     * @memberof SalesDataInvoiceInterface
     */
    updatedAt?: string;
    /**
     * Array of invoice items.
     * @type {Array<SalesDataInvoiceItemInterface>}
     * @memberof SalesDataInvoiceInterface
     */
    items: Array<SalesDataInvoiceItemInterface>;
    /**
     * Array of any invoice comments. Otherwise, null.
     * @type {Array<SalesDataInvoiceCommentInterface>}
     * @memberof SalesDataInvoiceInterface
     */
    comments?: Array<SalesDataInvoiceCommentInterface>;
    /**
     *
     * @type {SalesDataInvoiceExtensionInterface}
     * @memberof SalesDataInvoiceInterface
     */
    extensionAttributes?: SalesDataInvoiceExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\InvoiceItemCreationInterface
 * @export
 * @interface SalesDataInvoiceItemCreationExtensionInterface
 */
export interface SalesDataInvoiceItemCreationExtensionInterface {
}

/**
 * Input argument for invoice creation Interface InvoiceItemCreationInterface
 * @export
 * @interface SalesDataInvoiceItemCreationInterface
 */
export interface SalesDataInvoiceItemCreationInterface {
    /**
     *
     * @type {SalesDataInvoiceItemCreationExtensionInterface}
     * @memberof SalesDataInvoiceItemCreationInterface
     */
    extensionAttributes?: SalesDataInvoiceItemCreationExtensionInterface;
    /**
     * Order item ID.
     * @type {number}
     * @memberof SalesDataInvoiceItemCreationInterface
     */
    orderItemId: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataInvoiceItemCreationInterface
     */
    qty: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\InvoiceItemInterface
 * @export
 * @interface SalesDataInvoiceItemExtensionInterface
 */
export interface SalesDataInvoiceItemExtensionInterface {
}

/**
 * Invoice item interface. An invoice is a record of the receipt of payment for an order. An invoice item is a purchased item in an invoice.
 * @export
 * @interface SalesDataInvoiceItemInterface
 */
export interface SalesDataInvoiceItemInterface {
    /**
     * Additional data.
     * @type {string}
     * @memberof SalesDataInvoiceItemInterface
     */
    additionalData?: string;
    /**
     * Base cost.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    baseCost?: number;
    /**
     * Base discount amount.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    baseDiscountAmount?: number;
    /**
     * Base discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    baseDiscountTaxCompensationAmount?: number;
    /**
     * Base price.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    basePrice?: number;
    /**
     * Base price including tax.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    basePriceInclTax?: number;
    /**
     * Base row total.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    baseRowTotal?: number;
    /**
     * Base row total including tax.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    baseRowTotalInclTax?: number;
    /**
     * Base tax amount.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    baseTaxAmount?: number;
    /**
     * Description.
     * @type {string}
     * @memberof SalesDataInvoiceItemInterface
     */
    description?: string;
    /**
     * Discount amount.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    discountAmount?: number;
    /**
     * Invoice item ID.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    entityId?: number;
    /**
     * Discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    discountTaxCompensationAmount?: number;
    /**
     * Name.
     * @type {string}
     * @memberof SalesDataInvoiceItemInterface
     */
    name?: string;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    parentId?: number;
    /**
     * Price.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    price?: number;
    /**
     * Price including tax.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    priceInclTax?: number;
    /**
     * Product ID.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    productId?: number;
    /**
     * Row total.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    rowTotal?: number;
    /**
     * Row total including tax.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    rowTotalInclTax?: number;
    /**
     * SKU.
     * @type {string}
     * @memberof SalesDataInvoiceItemInterface
     */
    sku: string;
    /**
     * Tax amount.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    taxAmount?: number;
    /**
     *
     * @type {SalesDataInvoiceItemExtensionInterface}
     * @memberof SalesDataInvoiceItemInterface
     */
    extensionAttributes?: SalesDataInvoiceItemExtensionInterface;
    /**
     * Order item ID.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    orderItemId: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataInvoiceItemInterface
     */
    qty: number;
}

/**
 * Invoice search result interface. An invoice is a record of the receipt of payment for an order.
 * @export
 * @interface SalesDataInvoiceSearchResultInterface
 */
export interface SalesDataInvoiceSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataInvoiceInterface>}
     * @memberof SalesDataInvoiceSearchResultInterface
     */
    items: Array<SalesDataInvoiceInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataInvoiceSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataInvoiceSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\OrderAddressInterface
 * @export
 * @interface SalesDataOrderAddressExtensionInterface
 */
export interface SalesDataOrderAddressExtensionInterface {
}

/**
 * Order address interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderAddressInterface
 */
export interface SalesDataOrderAddressInterface {
    /**
     * Address type.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    addressType: string;
    /**
     * City.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    city: string;
    /**
     * Company.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    company?: string;
    /**
     * Country ID.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    countryId: string;
    /**
     * Country address ID.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    customerAddressId?: number;
    /**
     * Customer ID.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    customerId?: number;
    /**
     * Email address.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    email?: string;
    /**
     * Order address ID.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    entityId?: number;
    /**
     * Fax number.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    fax?: string;
    /**
     * First name.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    firstname: string;
    /**
     * Last name.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    lastname: string;
    /**
     * Middle name.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    middlename?: string;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    parentId?: number;
    /**
     * Postal code.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    postcode: string;
    /**
     * Prefix.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    prefix?: string;
    /**
     * Region.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    region?: string;
    /**
     * Region code.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    regionCode?: string;
    /**
     * Region ID.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    regionId?: number;
    /**
     * Array of any street values. Otherwise, null.
     * @type {Array<string>}
     * @memberof SalesDataOrderAddressInterface
     */
    street?: Array<string>;
    /**
     * Suffix.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    suffix?: string;
    /**
     * Telephone number.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    telephone: string;
    /**
     * VAT ID.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    vatId?: string;
    /**
     * VAT-is-valid flag value.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    vatIsValid?: number;
    /**
     * VAT request date.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    vatRequestDate?: string;
    /**
     * VAT request ID.
     * @type {string}
     * @memberof SalesDataOrderAddressInterface
     */
    vatRequestId?: string;
    /**
     * VAT-request-success flag value.
     * @type {number}
     * @memberof SalesDataOrderAddressInterface
     */
    vatRequestSuccess?: number;
    /**
     *
     * @type {SalesDataOrderAddressExtensionInterface}
     * @memberof SalesDataOrderAddressInterface
     */
    extensionAttributes?: SalesDataOrderAddressExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\OrderInterface
 * @export
 * @interface SalesDataOrderExtensionInterface
 */
export interface SalesDataOrderExtensionInterface {
    /**
     *
     * @type {Array<SalesDataShippingAssignmentInterface>}
     * @memberof SalesDataOrderExtensionInterface
     */
    shippingAssignments?: Array<SalesDataShippingAssignmentInterface>;
    /**
     *
     * @type {Array<TaxDataOrderTaxDetailsAppliedTaxInterface>}
     * @memberof SalesDataOrderExtensionInterface
     */
    appliedTaxes?: Array<TaxDataOrderTaxDetailsAppliedTaxInterface>;
    /**
     *
     * @type {Array<TaxDataOrderTaxDetailsItemInterface>}
     * @memberof SalesDataOrderExtensionInterface
     */
    itemAppliedTaxes?: Array<TaxDataOrderTaxDetailsItemInterface>;
    /**
     *
     * @type {boolean}
     * @memberof SalesDataOrderExtensionInterface
     */
    convertingFromQuote?: boolean;
    /**
     *
     * @type {CompanyDataCompanyOrderInterface}
     * @memberof SalesDataOrderExtensionInterface
     */
    companyOrderAttributes?: CompanyDataCompanyOrderInterface;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseCustomerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    customerBalanceAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseCustomerBalanceInvoiced?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    customerBalanceInvoiced?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseCustomerBalanceRefunded?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    customerBalanceRefunded?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseCustomerBalanceTotalRefunded?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    customerBalanceTotalRefunded?: number;
    /**
     *
     * @type {Array<GiftCardAccountDataGiftCardInterface>}
     * @memberof SalesDataOrderExtensionInterface
     */
    giftCards?: Array<GiftCardAccountDataGiftCardInterface>;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseGiftCardsAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    giftCardsAmount?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseGiftCardsInvoiced?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    giftCardsInvoiced?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    baseGiftCardsRefunded?: number;
    /**
     *
     * @type {number}
     * @memberof SalesDataOrderExtensionInterface
     */
    giftCardsRefunded?: number;
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof SalesDataOrderExtensionInterface
     */
    giftMessage?: GiftMessageDataMessageInterface;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwId?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwAllowGiftReceipt?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwAddCard?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBasePriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwPriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBasePriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsPriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBasePriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardPriceInclTax?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBasePriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwPriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBasePriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsPriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBasePriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardPriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBaseTaxAmountInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwTaxAmountInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBaseTaxInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsTaxInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBaseTaxInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardTaxInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBasePriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwPriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBasePriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsPriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBasePriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardPriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwBaseTaxAmountRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwTaxAmountRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsBaseTaxRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwItemsTaxRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardBaseTaxRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderExtensionInterface
     */
    gwCardTaxRefunded?: string;
}

/**
 * Order interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderInterface
 */
export interface SalesDataOrderInterface {
    /**
     * Negative adjustment value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    adjustmentNegative?: number;
    /**
     * Positive adjustment value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    adjustmentPositive?: number;
    /**
     * Applied rule IDs.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    appliedRuleIds?: string;
    /**
     * Base negative adjustment value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseAdjustmentNegative?: number;
    /**
     * Base positive adjustment value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseAdjustmentPositive?: number;
    /**
     * Base currency code.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    baseCurrencyCode?: string;
    /**
     * Base discount amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountAmount?: number;
    /**
     * Base discount canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountCanceled?: number;
    /**
     * Base discount invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountInvoiced?: number;
    /**
     * Base discount refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountRefunded?: number;
    /**
     * Base grand total.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseGrandTotal: number;
    /**
     * Base discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountTaxCompensationAmount?: number;
    /**
     * Base discount tax compensation invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountTaxCompensationInvoiced?: number;
    /**
     * Base discount tax compensation refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseDiscountTaxCompensationRefunded?: number;
    /**
     * Base shipping amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingAmount?: number;
    /**
     * Base shipping canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingCanceled?: number;
    /**
     * Base shipping discount amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingDiscountAmount?: number;
    /**
     * Base shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingDiscountTaxCompensationAmnt?: number;
    /**
     * Base shipping including tax.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingInclTax?: number;
    /**
     * Base shipping invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingInvoiced?: number;
    /**
     * Base shipping refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingRefunded?: number;
    /**
     * Base shipping tax amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingTaxAmount?: number;
    /**
     * Base shipping tax refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseShippingTaxRefunded?: number;
    /**
     * Base subtotal.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseSubtotal?: number;
    /**
     * Base subtotal canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseSubtotalCanceled?: number;
    /**
     * Base subtotal including tax.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseSubtotalInclTax?: number;
    /**
     * Base subtotal invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseSubtotalInvoiced?: number;
    /**
     * Base subtotal refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseSubtotalRefunded?: number;
    /**
     * Base tax amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTaxAmount?: number;
    /**
     * Base tax canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTaxCanceled?: number;
    /**
     * Base tax invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTaxInvoiced?: number;
    /**
     * Base tax refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTaxRefunded?: number;
    /**
     * Base total canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalCanceled?: number;
    /**
     * Base total due.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalDue?: number;
    /**
     * Base total invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalInvoiced?: number;
    /**
     * Base total invoiced cost.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalInvoicedCost?: number;
    /**
     * Base total offline refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalOfflineRefunded?: number;
    /**
     * Base total online refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalOnlineRefunded?: number;
    /**
     * Base total paid.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalPaid?: number;
    /**
     * Base total quantity ordered.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalQtyOrdered?: number;
    /**
     * Base total refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseTotalRefunded?: number;
    /**
     * Base-to-global rate.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseToGlobalRate?: number;
    /**
     * Base-to-order rate.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    baseToOrderRate?: number;
    /**
     * Billing address ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    billingAddressId?: number;
    /**
     * Can-ship-partially flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    canShipPartially?: number;
    /**
     * Can-ship-partially-item flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    canShipPartiallyItem?: number;
    /**
     * Coupon code.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    couponCode?: string;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    createdAt?: string;
    /**
     * Customer date-of-birth (DOB).
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerDob?: string;
    /**
     * Customer email address.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerEmail: string;
    /**
     * Customer first name.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerFirstname?: string;
    /**
     * Customer gender.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    customerGender?: number;
    /**
     * Customer group ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    customerGroupId?: number;
    /**
     * Customer ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    customerId?: number;
    /**
     * Customer-is-guest flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    customerIsGuest?: number;
    /**
     * Customer last name.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerLastname?: string;
    /**
     * Customer middle name.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerMiddlename?: string;
    /**
     * Customer note.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerNote?: string;
    /**
     * Customer-note-notify flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    customerNoteNotify?: number;
    /**
     * Customer prefix.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerPrefix?: string;
    /**
     * Customer suffix.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerSuffix?: string;
    /**
     * Customer value-added tax (VAT).
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    customerTaxvat?: string;
    /**
     * Discount amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountAmount?: number;
    /**
     * Discount canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountCanceled?: number;
    /**
     * Discount description.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    discountDescription?: string;
    /**
     * Discount invoiced.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountInvoiced?: number;
    /**
     * Discount refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountRefunded?: number;
    /**
     * Edit increment value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    editIncrement?: number;
    /**
     * Email-sent flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    emailSent?: number;
    /**
     * Order ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    entityId?: number;
    /**
     * External customer ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    extCustomerId?: string;
    /**
     * External order ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    extOrderId?: string;
    /**
     * Forced-shipment-with-invoice flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    forcedShipmentWithInvoice?: number;
    /**
     * Global currency code.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    globalCurrencyCode?: string;
    /**
     * Grand total.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    grandTotal: number;
    /**
     * Discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountTaxCompensationAmount?: number;
    /**
     * Discount tax compensation invoiced amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountTaxCompensationInvoiced?: number;
    /**
     * Discount tax compensation refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    discountTaxCompensationRefunded?: number;
    /**
     * Hold before state.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    holdBeforeState?: string;
    /**
     * Hold before status.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    holdBeforeStatus?: string;
    /**
     * Increment ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    incrementId?: string;
    /**
     * Is-virtual flag value.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    isVirtual?: number;
    /**
     * Order currency code.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    orderCurrencyCode?: string;
    /**
     * Original increment ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    originalIncrementId?: string;
    /**
     * Payment authorization amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    paymentAuthorizationAmount?: number;
    /**
     * Payment authorization expiration date.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    paymentAuthExpiration?: number;
    /**
     * Protect code.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    protectCode?: string;
    /**
     * Quote address ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    quoteAddressId?: number;
    /**
     * Quote ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    quoteId?: number;
    /**
     * Relation child ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    relationChildId?: string;
    /**
     * Relation child real ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    relationChildRealId?: string;
    /**
     * Relation parent ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    relationParentId?: string;
    /**
     * Relation parent real ID.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    relationParentRealId?: string;
    /**
     * Remote IP address.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    remoteIp?: string;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingAmount?: number;
    /**
     * Shipping canceled amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingCanceled?: number;
    /**
     * Shipping description.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    shippingDescription?: string;
    /**
     * Shipping discount amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingDiscountAmount?: number;
    /**
     * Shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingDiscountTaxCompensationAmount?: number;
    /**
     * Shipping including tax amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingInclTax?: number;
    /**
     * Shipping invoiced amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingInvoiced?: number;
    /**
     * Shipping refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingRefunded?: number;
    /**
     * Shipping tax amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingTaxAmount?: number;
    /**
     * Shipping tax refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    shippingTaxRefunded?: number;
    /**
     * State.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    state?: string;
    /**
     * Status.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    status?: string;
    /**
     * Store currency code.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    storeCurrencyCode?: string;
    /**
     * Store ID.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    storeId?: number;
    /**
     * Store name.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    storeName?: string;
    /**
     * Store-to-base rate.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    storeToBaseRate?: number;
    /**
     * Store-to-order rate.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    storeToOrderRate?: number;
    /**
     * Subtotal.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    subtotal?: number;
    /**
     * Subtotal canceled amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    subtotalCanceled?: number;
    /**
     * Subtotal including tax amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    subtotalInclTax?: number;
    /**
     * Subtotal invoiced amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    subtotalInvoiced?: number;
    /**
     * Subtotal refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    subtotalRefunded?: number;
    /**
     * Tax amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    taxAmount?: number;
    /**
     * Tax canceled amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    taxCanceled?: number;
    /**
     * Tax invoiced amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    taxInvoiced?: number;
    /**
     * Tax refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    taxRefunded?: number;
    /**
     * Total canceled.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalCanceled?: number;
    /**
     * Total due.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalDue?: number;
    /**
     * Total invoiced amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalInvoiced?: number;
    /**
     * Total item count.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalItemCount?: number;
    /**
     * Total offline refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalOfflineRefunded?: number;
    /**
     * Total online refunded amount.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalOnlineRefunded?: number;
    /**
     * Total paid.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalPaid?: number;
    /**
     * Total quantity ordered.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalQtyOrdered?: number;
    /**
     * Total amount refunded.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    totalRefunded?: number;
    /**
     * Updated-at timestamp.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    updatedAt?: string;
    /**
     * Weight.
     * @type {number}
     * @memberof SalesDataOrderInterface
     */
    weight?: number;
    /**
     * X-Forwarded-For field value.
     * @type {string}
     * @memberof SalesDataOrderInterface
     */
    xForwardedFor?: string;
    /**
     * Array of items.
     * @type {Array<SalesDataOrderItemInterface>}
     * @memberof SalesDataOrderInterface
     */
    items: Array<SalesDataOrderItemInterface>;
    /**
     *
     * @type {SalesDataOrderAddressInterface}
     * @memberof SalesDataOrderInterface
     */
    billingAddress?: SalesDataOrderAddressInterface;
    /**
     *
     * @type {SalesDataOrderPaymentInterface}
     * @memberof SalesDataOrderInterface
     */
    payment?: SalesDataOrderPaymentInterface;
    /**
     * Array of status histories.
     * @type {Array<SalesDataOrderStatusHistoryInterface>}
     * @memberof SalesDataOrderInterface
     */
    statusHistories?: Array<SalesDataOrderStatusHistoryInterface>;
    /**
     *
     * @type {SalesDataOrderExtensionInterface}
     * @memberof SalesDataOrderInterface
     */
    extensionAttributes?: SalesDataOrderExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\OrderItemInterface
 * @export
 * @interface SalesDataOrderItemExtensionInterface
 */
export interface SalesDataOrderItemExtensionInterface {
    /**
     *
     * @type {GiftMessageDataMessageInterface}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    giftMessage?: GiftMessageDataMessageInterface;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwId?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwBasePrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwPrice?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwBaseTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwTaxAmount?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwBasePriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwPriceInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwBaseTaxAmountInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwTaxAmountInvoiced?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwBasePriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwPriceRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwBaseTaxAmountRefunded?: string;
    /**
     *
     * @type {string}
     * @memberof SalesDataOrderItemExtensionInterface
     */
    gwTaxAmountRefunded?: string;
}

/**
 * Order item interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderItemInterface
 */
export interface SalesDataOrderItemInterface {
    /**
     * Additional data.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    additionalData?: string;
    /**
     * Amount refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    amountRefunded?: number;
    /**
     * Applied rule IDs.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    appliedRuleIds?: string;
    /**
     * Base amount refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseAmountRefunded?: number;
    /**
     * Base cost.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseCost?: number;
    /**
     * Base discount amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseDiscountAmount?: number;
    /**
     * Base discount invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseDiscountInvoiced?: number;
    /**
     * Base discount refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseDiscountRefunded?: number;
    /**
     * Base discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseDiscountTaxCompensationAmount?: number;
    /**
     * Base discount tax compensation invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseDiscountTaxCompensationInvoiced?: number;
    /**
     * Base discount tax compensation refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseDiscountTaxCompensationRefunded?: number;
    /**
     * Base original price.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseOriginalPrice?: number;
    /**
     * Base price.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    basePrice?: number;
    /**
     * Base price including tax.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    basePriceInclTax?: number;
    /**
     * Base row invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseRowInvoiced?: number;
    /**
     * Base row total.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseRowTotal?: number;
    /**
     * Base row total including tax.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseRowTotalInclTax?: number;
    /**
     * Base tax amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseTaxAmount?: number;
    /**
     * Base tax before discount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseTaxBeforeDiscount?: number;
    /**
     * Base tax invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseTaxInvoiced?: number;
    /**
     * Base tax refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseTaxRefunded?: number;
    /**
     * Base WEEE tax applied amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseWeeeTaxAppliedAmount?: number;
    /**
     * Base WEEE tax applied row amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseWeeeTaxAppliedRowAmnt?: number;
    /**
     * Base WEEE tax disposition.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseWeeeTaxDisposition?: number;
    /**
     * Base WEEE tax row disposition.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    baseWeeeTaxRowDisposition?: number;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    createdAt?: string;
    /**
     * Description.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    description?: string;
    /**
     * Discount amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountAmount?: number;
    /**
     * Discount invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountInvoiced?: number;
    /**
     * Discount percent.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountPercent?: number;
    /**
     * Discount refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountRefunded?: number;
    /**
     * Event ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    eventId?: number;
    /**
     * External order item ID.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    extOrderItemId?: string;
    /**
     * Free-shipping flag value.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    freeShipping?: number;
    /**
     * GW base price.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwBasePrice?: number;
    /**
     * GW base price invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwBasePriceInvoiced?: number;
    /**
     * GW base price refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwBasePriceRefunded?: number;
    /**
     * GW base tax amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwBaseTaxAmount?: number;
    /**
     * GW base tax amount invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwBaseTaxAmountInvoiced?: number;
    /**
     * GW base tax amount refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwBaseTaxAmountRefunded?: number;
    /**
     * GW ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwId?: number;
    /**
     * GW price.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwPrice?: number;
    /**
     * GW price invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwPriceInvoiced?: number;
    /**
     * GW price refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwPriceRefunded?: number;
    /**
     * GW tax amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwTaxAmount?: number;
    /**
     * GW tax amount invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwTaxAmountInvoiced?: number;
    /**
     * GW tax amount refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    gwTaxAmountRefunded?: number;
    /**
     * Discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountTaxCompensationAmount?: number;
    /**
     * Discount tax compensation canceled.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountTaxCompensationCanceled?: number;
    /**
     * Discount tax compensation invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountTaxCompensationInvoiced?: number;
    /**
     * Discount tax compensation refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    discountTaxCompensationRefunded?: number;
    /**
     * Is-quantity-decimal flag value.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    isQtyDecimal?: number;
    /**
     * Is-virtual flag value.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    isVirtual?: number;
    /**
     * Item ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    itemId?: number;
    /**
     * Locked DO invoice flag value.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    lockedDoInvoice?: number;
    /**
     * Locked DO ship flag value.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    lockedDoShip?: number;
    /**
     * Name.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    name?: string;
    /**
     * No-discount flag value.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    noDiscount?: number;
    /**
     * Order ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    orderId?: number;
    /**
     * Original price.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    originalPrice?: number;
    /**
     * Parent item ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    parentItemId?: number;
    /**
     * Price.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    price?: number;
    /**
     * Price including tax.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    priceInclTax?: number;
    /**
     * Product ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    productId?: number;
    /**
     * Product type.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    productType?: string;
    /**
     * Quantity backordered.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyBackordered?: number;
    /**
     * Quantity canceled.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyCanceled?: number;
    /**
     * Quantity invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyInvoiced?: number;
    /**
     * Quantity ordered.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyOrdered?: number;
    /**
     * Quantity refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyRefunded?: number;
    /**
     * Quantity returned.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyReturned?: number;
    /**
     * Quantity shipped.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    qtyShipped?: number;
    /**
     * Quote item ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    quoteItemId?: number;
    /**
     * Row invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    rowInvoiced?: number;
    /**
     * Row total.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    rowTotal?: number;
    /**
     * Row total including tax.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    rowTotalInclTax?: number;
    /**
     * Row weight.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    rowWeight?: number;
    /**
     * SKU.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    sku: string;
    /**
     * Store ID.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    storeId?: number;
    /**
     * Tax amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    taxAmount?: number;
    /**
     * Tax before discount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    taxBeforeDiscount?: number;
    /**
     * Tax canceled.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    taxCanceled?: number;
    /**
     * Tax invoiced.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    taxInvoiced?: number;
    /**
     * Tax percent.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    taxPercent?: number;
    /**
     * Tax refunded.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    taxRefunded?: number;
    /**
     * Updated-at timestamp.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    updatedAt?: string;
    /**
     * WEEE tax applied.
     * @type {string}
     * @memberof SalesDataOrderItemInterface
     */
    weeeTaxApplied?: string;
    /**
     * WEEE tax applied amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    weeeTaxAppliedAmount?: number;
    /**
     * WEEE tax applied row amount.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    weeeTaxAppliedRowAmount?: number;
    /**
     * WEEE tax disposition.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    weeeTaxDisposition?: number;
    /**
     * WEEE tax row disposition.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    weeeTaxRowDisposition?: number;
    /**
     * Weight.
     * @type {number}
     * @memberof SalesDataOrderItemInterface
     */
    weight?: number;
    /**
     *
     * @type {SalesDataOrderItemInterface}
     * @memberof SalesDataOrderItemInterface
     */
    parentItem?: SalesDataOrderItemInterface;
    /**
     *
     * @type {CatalogDataProductOptionInterface}
     * @memberof SalesDataOrderItemInterface
     */
    productOption?: CatalogDataProductOptionInterface;
    /**
     *
     * @type {SalesDataOrderItemExtensionInterface}
     * @memberof SalesDataOrderItemInterface
     */
    extensionAttributes?: SalesDataOrderItemExtensionInterface;
}

/**
 * Order item search result interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderItemSearchResultInterface
 */
export interface SalesDataOrderItemSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataOrderItemInterface>}
     * @memberof SalesDataOrderItemSearchResultInterface
     */
    items: Array<SalesDataOrderItemInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataOrderItemSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataOrderItemSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\OrderPaymentInterface
 * @export
 * @interface SalesDataOrderPaymentExtensionInterface
 */
export interface SalesDataOrderPaymentExtensionInterface {
    /**
     *
     * @type {VaultDataPaymentTokenInterface}
     * @memberof SalesDataOrderPaymentExtensionInterface
     */
    vaultPaymentToken?: VaultDataPaymentTokenInterface;
}

/**
 * Order payment interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderPaymentInterface
 */
export interface SalesDataOrderPaymentInterface {
    /**
     * Account status.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    accountStatus: string;
    /**
     * Additional data.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    additionalData?: string;
    /**
     * Array of additional information.
     * @type {Array<string>}
     * @memberof SalesDataOrderPaymentInterface
     */
    additionalInformation: Array<string>;
    /**
     * Address status.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    addressStatus?: string;
    /**
     * Amount authorized.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    amountAuthorized?: number;
    /**
     * Amount canceled.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    amountCanceled?: number;
    /**
     * Amount ordered.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    amountOrdered?: number;
    /**
     * Amount paid.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    amountPaid?: number;
    /**
     * Amount refunded.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    amountRefunded?: number;
    /**
     * Anet transaction method.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    anetTransMethod?: string;
    /**
     * Base amount authorized.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountAuthorized?: number;
    /**
     * Base amount canceled.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountCanceled?: number;
    /**
     * Base amount ordered.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountOrdered?: number;
    /**
     * Base amount paid.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountPaid?: number;
    /**
     * Base amount paid online.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountPaidOnline?: number;
    /**
     * Base amount refunded.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountRefunded?: number;
    /**
     * Base amount refunded online.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseAmountRefundedOnline?: number;
    /**
     * Base shipping amount.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseShippingAmount?: number;
    /**
     * Base shipping captured amount.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseShippingCaptured?: number;
    /**
     * Base shipping refunded amount.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    baseShippingRefunded?: number;
    /**
     * Credit card approval.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccApproval?: string;
    /**
     * Credit card avs status.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccAvsStatus?: string;
    /**
     * Credit card CID status.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccCidStatus?: string;
    /**
     * Credit card debug request body.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccDebugRequestBody?: string;
    /**
     * Credit card debug response body.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccDebugResponseBody?: string;
    /**
     * Credit card debug response serialized.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccDebugResponseSerialized?: string;
    /**
     * Credit card expiration month.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccExpMonth?: string;
    /**
     * Credit card expiration year.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccExpYear?: string;
    /**
     * Last four digits of the credit card.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccLast4: string;
    /**
     * Encrypted credit card number.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccNumberEnc?: string;
    /**
     * Credit card number.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccOwner?: string;
    /**
     * Credit card secure verify.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccSecureVerify?: string;
    /**
     * Credit card SS issue.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccSsIssue?: string;
    /**
     * Credit card SS start month.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccSsStartMonth?: string;
    /**
     * Credit card SS start year.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccSsStartYear?: string;
    /**
     * Credit card status.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccStatus?: string;
    /**
     * Credit card status description.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccStatusDescription?: string;
    /**
     * Credit card transaction ID.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccTransId?: string;
    /**
     * Credit card type.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    ccType?: string;
    /**
     * eCheck account name.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    echeckAccountName?: string;
    /**
     * eCheck account type.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    echeckAccountType?: string;
    /**
     * eCheck bank name.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    echeckBankName?: string;
    /**
     * eCheck routing number.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    echeckRoutingNumber?: string;
    /**
     * eCheck type.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    echeckType?: string;
    /**
     * Entity ID.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    entityId?: number;
    /**
     * Last transaction ID.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    lastTransId?: string;
    /**
     * Method.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    method: string;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    parentId?: number;
    /**
     * PO number.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    poNumber?: string;
    /**
     * Protection eligibility.
     * @type {string}
     * @memberof SalesDataOrderPaymentInterface
     */
    protectionEligibility?: string;
    /**
     * Quote payment ID.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    quotePaymentId?: number;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    shippingAmount?: number;
    /**
     * Shipping captured.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    shippingCaptured?: number;
    /**
     * Shipping refunded.
     * @type {number}
     * @memberof SalesDataOrderPaymentInterface
     */
    shippingRefunded?: number;
    /**
     *
     * @type {SalesDataOrderPaymentExtensionInterface}
     * @memberof SalesDataOrderPaymentInterface
     */
    extensionAttributes?: SalesDataOrderPaymentExtensionInterface;
}

/**
 * Order search result interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderSearchResultInterface
 */
export interface SalesDataOrderSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataOrderInterface>}
     * @memberof SalesDataOrderSearchResultInterface
     */
    items: Array<SalesDataOrderInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataOrderSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataOrderSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\OrderStatusHistoryInterface
 * @export
 * @interface SalesDataOrderStatusHistoryExtensionInterface
 */
export interface SalesDataOrderStatusHistoryExtensionInterface {
}

/**
 * Order status history interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderStatusHistoryInterface
 */
export interface SalesDataOrderStatusHistoryInterface {
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    comment: string;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    createdAt?: string;
    /**
     * Order status history ID.
     * @type {number}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    entityId?: number;
    /**
     * Entity name.
     * @type {string}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    entityName?: string;
    /**
     * Is-customer-notified flag value.
     * @type {number}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    isCustomerNotified: number;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    isVisibleOnFront: number;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    parentId: number;
    /**
     * Status.
     * @type {string}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    status?: string;
    /**
     *
     * @type {SalesDataOrderStatusHistoryExtensionInterface}
     * @memberof SalesDataOrderStatusHistoryInterface
     */
    extensionAttributes?: SalesDataOrderStatusHistoryExtensionInterface;
}

/**
 * Order status history search result interface. An order is a document that a web store issues to a customer. Magento generates a sales order that lists the product items, billing and shipping addresses, and shipping and payment methods. A corresponding external document, known as a purchase order, is emailed to the customer.
 * @export
 * @interface SalesDataOrderStatusHistorySearchResultInterface
 */
export interface SalesDataOrderStatusHistorySearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataOrderStatusHistoryInterface>}
     * @memberof SalesDataOrderStatusHistorySearchResultInterface
     */
    items: Array<SalesDataOrderStatusHistoryInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataOrderStatusHistorySearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataOrderStatusHistorySearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentCommentCreationInterface
 * @export
 * @interface SalesDataShipmentCommentCreationExtensionInterface
 */
export interface SalesDataShipmentCommentCreationExtensionInterface {
}

/**
 * Interface ShipmentCommentCreationInterface
 * @export
 * @interface SalesDataShipmentCommentCreationInterface
 */
export interface SalesDataShipmentCommentCreationInterface {
    /**
     *
     * @type {SalesDataShipmentCommentCreationExtensionInterface}
     * @memberof SalesDataShipmentCommentCreationInterface
     */
    extensionAttributes?: SalesDataShipmentCommentCreationExtensionInterface;
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataShipmentCommentCreationInterface
     */
    comment: string;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataShipmentCommentCreationInterface
     */
    isVisibleOnFront: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentCommentInterface
 * @export
 * @interface SalesDataShipmentCommentExtensionInterface
 */
export interface SalesDataShipmentCommentExtensionInterface {
}

/**
 * Shipment comment interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package. A shipment document can contain comments.
 * @export
 * @interface SalesDataShipmentCommentInterface
 */
export interface SalesDataShipmentCommentInterface {
    /**
     * Is-customer-notified flag value.
     * @type {number}
     * @memberof SalesDataShipmentCommentInterface
     */
    isCustomerNotified: number;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataShipmentCommentInterface
     */
    parentId: number;
    /**
     *
     * @type {SalesDataShipmentCommentExtensionInterface}
     * @memberof SalesDataShipmentCommentInterface
     */
    extensionAttributes?: SalesDataShipmentCommentExtensionInterface;
    /**
     * Comment.
     * @type {string}
     * @memberof SalesDataShipmentCommentInterface
     */
    comment: string;
    /**
     * Is-visible-on-storefront flag value.
     * @type {number}
     * @memberof SalesDataShipmentCommentInterface
     */
    isVisibleOnFront: number;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataShipmentCommentInterface
     */
    createdAt?: string;
    /**
     * Invoice ID.
     * @type {number}
     * @memberof SalesDataShipmentCommentInterface
     */
    entityId?: number;
}

/**
 * Shipment comment search result interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package. A shipment document can contain comments.
 * @export
 * @interface SalesDataShipmentCommentSearchResultInterface
 */
export interface SalesDataShipmentCommentSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataShipmentCommentInterface>}
     * @memberof SalesDataShipmentCommentSearchResultInterface
     */
    items: Array<SalesDataShipmentCommentInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataShipmentCommentSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataShipmentCommentSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentCreationArgumentsInterface
 * @export
 * @interface SalesDataShipmentCreationArgumentsExtensionInterface
 */
export interface SalesDataShipmentCreationArgumentsExtensionInterface {
}

/**
 * Interface for creation arguments for Shipment.
 * @export
 * @interface SalesDataShipmentCreationArgumentsInterface
 */
export interface SalesDataShipmentCreationArgumentsInterface {
    /**
     *
     * @type {SalesDataShipmentCreationArgumentsExtensionInterface}
     * @memberof SalesDataShipmentCreationArgumentsInterface
     */
    extensionAttributes?: SalesDataShipmentCreationArgumentsExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentInterface
 * @export
 * @interface SalesDataShipmentExtensionInterface
 */
export interface SalesDataShipmentExtensionInterface {
}

/**
 * Shipment interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package.
 * @export
 * @interface SalesDataShipmentInterface
 */
export interface SalesDataShipmentInterface {
    /**
     * Billing address ID.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    billingAddressId?: number;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataShipmentInterface
     */
    createdAt?: string;
    /**
     * Customer ID.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    customerId?: number;
    /**
     * Email-sent flag value.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    emailSent?: number;
    /**
     * Shipment ID.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    entityId?: number;
    /**
     * Increment ID.
     * @type {string}
     * @memberof SalesDataShipmentInterface
     */
    incrementId?: string;
    /**
     * Order ID.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    orderId: number;
    /**
     * Array of packages, if any. Otherwise, null.
     * @type {Array<SalesDataShipmentPackageInterface>}
     * @memberof SalesDataShipmentInterface
     */
    packages?: Array<SalesDataShipmentPackageInterface>;
    /**
     * Shipment status.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    shipmentStatus?: number;
    /**
     * Shipping address ID.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    shippingAddressId?: number;
    /**
     * Shipping label.
     * @type {string}
     * @memberof SalesDataShipmentInterface
     */
    shippingLabel?: string;
    /**
     * Store ID.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    storeId?: number;
    /**
     * Total quantity.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    totalQty?: number;
    /**
     * Total weight.
     * @type {number}
     * @memberof SalesDataShipmentInterface
     */
    totalWeight?: number;
    /**
     * Updated-at timestamp.
     * @type {string}
     * @memberof SalesDataShipmentInterface
     */
    updatedAt?: string;
    /**
     * Array of items.
     * @type {Array<SalesDataShipmentItemInterface>}
     * @memberof SalesDataShipmentInterface
     */
    items: Array<SalesDataShipmentItemInterface>;
    /**
     * Array of tracks.
     * @type {Array<SalesDataShipmentTrackInterface>}
     * @memberof SalesDataShipmentInterface
     */
    tracks: Array<SalesDataShipmentTrackInterface>;
    /**
     * Array of comments.
     * @type {Array<SalesDataShipmentCommentInterface>}
     * @memberof SalesDataShipmentInterface
     */
    comments: Array<SalesDataShipmentCommentInterface>;
    /**
     *
     * @type {SalesDataShipmentExtensionInterface}
     * @memberof SalesDataShipmentInterface
     */
    extensionAttributes?: SalesDataShipmentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentItemCreationInterface
 * @export
 * @interface SalesDataShipmentItemCreationExtensionInterface
 */
export interface SalesDataShipmentItemCreationExtensionInterface {
}

/**
 * Input argument for shipment item creation Interface ShipmentItemCreationInterface
 * @export
 * @interface SalesDataShipmentItemCreationInterface
 */
export interface SalesDataShipmentItemCreationInterface {
    /**
     *
     * @type {SalesDataShipmentItemCreationExtensionInterface}
     * @memberof SalesDataShipmentItemCreationInterface
     */
    extensionAttributes?: SalesDataShipmentItemCreationExtensionInterface;
    /**
     * Order item ID.
     * @type {number}
     * @memberof SalesDataShipmentItemCreationInterface
     */
    orderItemId: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataShipmentItemCreationInterface
     */
    qty: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentItemInterface
 * @export
 * @interface SalesDataShipmentItemExtensionInterface
 */
export interface SalesDataShipmentItemExtensionInterface {
}

/**
 * Shipment item interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package. A product is an item in a shipment.
 * @export
 * @interface SalesDataShipmentItemInterface
 */
export interface SalesDataShipmentItemInterface {
    /**
     * Additional data.
     * @type {string}
     * @memberof SalesDataShipmentItemInterface
     */
    additionalData?: string;
    /**
     * Description.
     * @type {string}
     * @memberof SalesDataShipmentItemInterface
     */
    description?: string;
    /**
     * Shipment item ID.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    entityId?: number;
    /**
     * Name.
     * @type {string}
     * @memberof SalesDataShipmentItemInterface
     */
    name?: string;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    parentId?: number;
    /**
     * Price.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    price?: number;
    /**
     * Product ID.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    productId?: number;
    /**
     * Row total.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    rowTotal?: number;
    /**
     * SKU.
     * @type {string}
     * @memberof SalesDataShipmentItemInterface
     */
    sku?: string;
    /**
     * Weight.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    weight?: number;
    /**
     *
     * @type {SalesDataShipmentItemExtensionInterface}
     * @memberof SalesDataShipmentItemInterface
     */
    extensionAttributes?: SalesDataShipmentItemExtensionInterface;
    /**
     * Order item ID.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    orderItemId: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataShipmentItemInterface
     */
    qty: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentPackageCreationInterface
 * @export
 * @interface SalesDataShipmentPackageCreationExtensionInterface
 */
export interface SalesDataShipmentPackageCreationExtensionInterface {
}

/**
 * Shipment package interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package.
 * @export
 * @interface SalesDataShipmentPackageCreationInterface
 */
export interface SalesDataShipmentPackageCreationInterface {
    /**
     *
     * @type {SalesDataShipmentPackageCreationExtensionInterface}
     * @memberof SalesDataShipmentPackageCreationInterface
     */
    extensionAttributes?: SalesDataShipmentPackageCreationExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentPackageInterface
 * @export
 * @interface SalesDataShipmentPackageExtensionInterface
 */
export interface SalesDataShipmentPackageExtensionInterface {
}

/**
 * Shipment package interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package.
 * @export
 * @interface SalesDataShipmentPackageInterface
 */
export interface SalesDataShipmentPackageInterface {
    /**
     *
     * @type {SalesDataShipmentPackageExtensionInterface}
     * @memberof SalesDataShipmentPackageInterface
     */
    extensionAttributes?: SalesDataShipmentPackageExtensionInterface;
}

/**
 * Shipment search result interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package.
 * @export
 * @interface SalesDataShipmentSearchResultInterface
 */
export interface SalesDataShipmentSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataShipmentInterface>}
     * @memberof SalesDataShipmentSearchResultInterface
     */
    items: Array<SalesDataShipmentInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataShipmentSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataShipmentSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentTrackCreationInterface
 * @export
 * @interface SalesDataShipmentTrackCreationExtensionInterface
 */
export interface SalesDataShipmentTrackCreationExtensionInterface {
}

/**
 * Shipment Track Creation interface.
 * @export
 * @interface SalesDataShipmentTrackCreationInterface
 */
export interface SalesDataShipmentTrackCreationInterface {
    /**
     *
     * @type {SalesDataShipmentTrackCreationExtensionInterface}
     * @memberof SalesDataShipmentTrackCreationInterface
     */
    extensionAttributes?: SalesDataShipmentTrackCreationExtensionInterface;
    /**
     * Track number.
     * @type {string}
     * @memberof SalesDataShipmentTrackCreationInterface
     */
    trackNumber: string;
    /**
     * Title.
     * @type {string}
     * @memberof SalesDataShipmentTrackCreationInterface
     */
    title: string;
    /**
     * Carrier code.
     * @type {string}
     * @memberof SalesDataShipmentTrackCreationInterface
     */
    carrierCode: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShipmentTrackInterface
 * @export
 * @interface SalesDataShipmentTrackExtensionInterface
 */
export interface SalesDataShipmentTrackExtensionInterface {
}

/**
 * Shipment track interface. A shipment is a delivery package that contains products. A shipment document accompanies the shipment. This document lists the products and their quantities in the delivery package. Merchants and customers can track shipments.
 * @export
 * @interface SalesDataShipmentTrackInterface
 */
export interface SalesDataShipmentTrackInterface {
    /**
     * The order_id for the shipment package.
     * @type {number}
     * @memberof SalesDataShipmentTrackInterface
     */
    orderId: number;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataShipmentTrackInterface
     */
    createdAt?: string;
    /**
     * Shipment package ID.
     * @type {number}
     * @memberof SalesDataShipmentTrackInterface
     */
    entityId?: number;
    /**
     * Parent ID.
     * @type {number}
     * @memberof SalesDataShipmentTrackInterface
     */
    parentId: number;
    /**
     * Updated-at timestamp.
     * @type {string}
     * @memberof SalesDataShipmentTrackInterface
     */
    updatedAt?: string;
    /**
     * Weight.
     * @type {number}
     * @memberof SalesDataShipmentTrackInterface
     */
    weight: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof SalesDataShipmentTrackInterface
     */
    qty: number;
    /**
     * Description.
     * @type {string}
     * @memberof SalesDataShipmentTrackInterface
     */
    description: string;
    /**
     *
     * @type {SalesDataShipmentTrackExtensionInterface}
     * @memberof SalesDataShipmentTrackInterface
     */
    extensionAttributes?: SalesDataShipmentTrackExtensionInterface;
    /**
     * Track number.
     * @type {string}
     * @memberof SalesDataShipmentTrackInterface
     */
    trackNumber: string;
    /**
     * Title.
     * @type {string}
     * @memberof SalesDataShipmentTrackInterface
     */
    title: string;
    /**
     * Carrier code.
     * @type {string}
     * @memberof SalesDataShipmentTrackInterface
     */
    carrierCode: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShippingAssignmentInterface
 * @export
 * @interface SalesDataShippingAssignmentExtensionInterface
 */
export interface SalesDataShippingAssignmentExtensionInterface {
}

/**
 * Interface ShippingAssignmentInterface
 * @export
 * @interface SalesDataShippingAssignmentInterface
 */
export interface SalesDataShippingAssignmentInterface {
    /**
     *
     * @type {SalesDataShippingInterface}
     * @memberof SalesDataShippingAssignmentInterface
     */
    shipping: SalesDataShippingInterface;
    /**
     * Order items of shipping assignment
     * @type {Array<SalesDataOrderItemInterface>}
     * @memberof SalesDataShippingAssignmentInterface
     */
    items: Array<SalesDataOrderItemInterface>;
    /**
     * Stock id
     * @type {number}
     * @memberof SalesDataShippingAssignmentInterface
     */
    stockId?: number;
    /**
     *
     * @type {SalesDataShippingAssignmentExtensionInterface}
     * @memberof SalesDataShippingAssignmentInterface
     */
    extensionAttributes?: SalesDataShippingAssignmentExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\ShippingInterface
 * @export
 * @interface SalesDataShippingExtensionInterface
 */
export interface SalesDataShippingExtensionInterface {
}

/**
 * Interface ShippingInterface
 * @export
 * @interface SalesDataShippingInterface
 */
export interface SalesDataShippingInterface {
    /**
     *
     * @type {SalesDataOrderAddressInterface}
     * @memberof SalesDataShippingInterface
     */
    address?: SalesDataOrderAddressInterface;
    /**
     * Shipping method
     * @type {string}
     * @memberof SalesDataShippingInterface
     */
    method?: string;
    /**
     *
     * @type {SalesDataTotalInterface}
     * @memberof SalesDataShippingInterface
     */
    total?: SalesDataTotalInterface;
    /**
     *
     * @type {SalesDataShippingExtensionInterface}
     * @memberof SalesDataShippingInterface
     */
    extensionAttributes?: SalesDataShippingExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\TotalInterface
 * @export
 * @interface SalesDataTotalExtensionInterface
 */
export interface SalesDataTotalExtensionInterface {
}

/**
 * Interface TotalInterface
 * @export
 * @interface SalesDataTotalInterface
 */
export interface SalesDataTotalInterface {
    /**
     * Base shipping amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingAmount?: number;
    /**
     * Base shipping canceled.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingCanceled?: number;
    /**
     * Base shipping discount amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingDiscountAmount?: number;
    /**
     * Base shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingDiscountTaxCompensationAmnt?: number;
    /**
     * Base shipping including tax.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingInclTax?: number;
    /**
     * Base shipping invoiced.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingInvoiced?: number;
    /**
     * Base shipping refunded.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingRefunded?: number;
    /**
     * Base shipping tax amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingTaxAmount?: number;
    /**
     * Base shipping tax refunded.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    baseShippingTaxRefunded?: number;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingAmount?: number;
    /**
     * Shipping canceled amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingCanceled?: number;
    /**
     * Shipping discount amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingDiscountAmount?: number;
    /**
     * Shipping discount tax compensation amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingDiscountTaxCompensationAmount?: number;
    /**
     * Shipping including tax amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingInclTax?: number;
    /**
     * Shipping invoiced amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingInvoiced?: number;
    /**
     * Shipping refunded amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingRefunded?: number;
    /**
     * Shipping tax amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingTaxAmount?: number;
    /**
     * Shipping tax refunded amount.
     * @type {number}
     * @memberof SalesDataTotalInterface
     */
    shippingTaxRefunded?: number;
    /**
     *
     * @type {SalesDataTotalExtensionInterface}
     * @memberof SalesDataTotalInterface
     */
    extensionAttributes?: SalesDataTotalExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Sales\\Api\\Data\\TransactionInterface
 * @export
 * @interface SalesDataTransactionExtensionInterface
 */
export interface SalesDataTransactionExtensionInterface {
}

/**
 * Transaction interface. A transaction is an interaction between a merchant and a customer such as a purchase, a credit, a refund, and so on.
 * @export
 * @interface SalesDataTransactionInterface
 */
export interface SalesDataTransactionInterface {
    /**
     * Transaction ID.
     * @type {number}
     * @memberof SalesDataTransactionInterface
     */
    transactionId: number;
    /**
     * The parent ID for the transaction. Otherwise, null.
     * @type {number}
     * @memberof SalesDataTransactionInterface
     */
    parentId?: number;
    /**
     * Order ID.
     * @type {number}
     * @memberof SalesDataTransactionInterface
     */
    orderId: number;
    /**
     * Payment ID.
     * @type {number}
     * @memberof SalesDataTransactionInterface
     */
    paymentId: number;
    /**
     * Transaction business ID.
     * @type {string}
     * @memberof SalesDataTransactionInterface
     */
    txnId: string;
    /**
     * Parent transaction business ID.
     * @type {string}
     * @memberof SalesDataTransactionInterface
     */
    parentTxnId: string;
    /**
     * Transaction type.
     * @type {string}
     * @memberof SalesDataTransactionInterface
     */
    txnType: string;
    /**
     * Is-closed flag value.
     * @type {number}
     * @memberof SalesDataTransactionInterface
     */
    isClosed: number;
    /**
     * Array of additional information. Otherwise, null.
     * @type {Array<string>}
     * @memberof SalesDataTransactionInterface
     */
    additionalInformation?: Array<string>;
    /**
     * Created-at timestamp.
     * @type {string}
     * @memberof SalesDataTransactionInterface
     */
    createdAt: string;
    /**
     * Array of child transactions.
     * @type {Array<SalesDataTransactionInterface>}
     * @memberof SalesDataTransactionInterface
     */
    childTransactions: Array<SalesDataTransactionInterface>;
    /**
     *
     * @type {SalesDataTransactionExtensionInterface}
     * @memberof SalesDataTransactionInterface
     */
    extensionAttributes?: SalesDataTransactionExtensionInterface;
}

/**
 * Transaction search result interface. A transaction is an interaction between a merchant and a customer such as a purchase, a credit, a refund, and so on.
 * @export
 * @interface SalesDataTransactionSearchResultInterface
 */
export interface SalesDataTransactionSearchResultInterface {
    /**
     * Array of collection items.
     * @type {Array<SalesDataTransactionInterface>}
     * @memberof SalesDataTransactionSearchResultInterface
     */
    items: Array<SalesDataTransactionInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesDataTransactionSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesDataTransactionSearchResultInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface SalesInvoiceCommentRepositoryV1SavePostBody
 */
export interface SalesInvoiceCommentRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataInvoiceCommentInterface}
     * @memberof SalesInvoiceCommentRepositoryV1SavePostBody
     */
    entity: SalesDataInvoiceCommentInterface;
}

/**
 *
 * @export
 * @interface SalesInvoiceOrderV1ExecutePostBody
 */
export interface SalesInvoiceOrderV1ExecutePostBody {
    /**
     *
     * @type {boolean}
     * @memberof SalesInvoiceOrderV1ExecutePostBody
     */
    capture?: boolean;
    /**
     *
     * @type {Array<SalesDataInvoiceItemCreationInterface>}
     * @memberof SalesInvoiceOrderV1ExecutePostBody
     */
    items?: Array<SalesDataInvoiceItemCreationInterface>;
    /**
     *
     * @type {boolean}
     * @memberof SalesInvoiceOrderV1ExecutePostBody
     */
    notify?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SalesInvoiceOrderV1ExecutePostBody
     */
    appendComment?: boolean;
    /**
     *
     * @type {SalesDataInvoiceCommentCreationInterface}
     * @memberof SalesInvoiceOrderV1ExecutePostBody
     */
    comment?: SalesDataInvoiceCommentCreationInterface;
    /**
     *
     * @type {SalesDataInvoiceCreationArgumentsInterface}
     * @memberof SalesInvoiceOrderV1ExecutePostBody
     */
    arguments?: SalesDataInvoiceCreationArgumentsInterface;
}

/**
 *
 * @export
 * @interface SalesInvoiceRepositoryV1SavePostBody
 */
export interface SalesInvoiceRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataInvoiceInterface}
     * @memberof SalesInvoiceRepositoryV1SavePostBody
     */
    entity: SalesDataInvoiceInterface;
}

/**
 *
 * @export
 * @interface SalesOrderAddressRepositoryV1SavePutBody
 */
export interface SalesOrderAddressRepositoryV1SavePutBody {
    /**
     *
     * @type {SalesDataOrderAddressInterface}
     * @memberof SalesOrderAddressRepositoryV1SavePutBody
     */
    entity: SalesDataOrderAddressInterface;
}

/**
 *
 * @export
 * @interface SalesOrderManagementV1AddCommentPostBody
 */
export interface SalesOrderManagementV1AddCommentPostBody {
    /**
     *
     * @type {SalesDataOrderStatusHistoryInterface}
     * @memberof SalesOrderManagementV1AddCommentPostBody
     */
    statusHistory: SalesDataOrderStatusHistoryInterface;
}

/**
 *
 * @export
 * @interface SalesOrderRepositoryV1SavePostBody
 */
export interface SalesOrderRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataOrderInterface}
     * @memberof SalesOrderRepositoryV1SavePostBody
     */
    entity: SalesDataOrderInterface;
}

/**
 *
 * @export
 * @interface SalesOrderRepositoryV1SavePutBody
 */
export interface SalesOrderRepositoryV1SavePutBody {
    /**
     *
     * @type {SalesDataOrderInterface}
     * @memberof SalesOrderRepositoryV1SavePutBody
     */
    entity: SalesDataOrderInterface;
}

/**
 *
 * @export
 * @interface SalesRefundInvoiceV1ExecutePostBody
 */
export interface SalesRefundInvoiceV1ExecutePostBody {
    /**
     *
     * @type {Array<SalesDataCreditmemoItemCreationInterface>}
     * @memberof SalesRefundInvoiceV1ExecutePostBody
     */
    items?: Array<SalesDataCreditmemoItemCreationInterface>;
    /**
     *
     * @type {boolean}
     * @memberof SalesRefundInvoiceV1ExecutePostBody
     */
    isOnline?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SalesRefundInvoiceV1ExecutePostBody
     */
    notify?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SalesRefundInvoiceV1ExecutePostBody
     */
    appendComment?: boolean;
    /**
     *
     * @type {SalesDataCreditmemoCommentCreationInterface}
     * @memberof SalesRefundInvoiceV1ExecutePostBody
     */
    comment?: SalesDataCreditmemoCommentCreationInterface;
    /**
     *
     * @type {SalesDataCreditmemoCreationArgumentsInterface}
     * @memberof SalesRefundInvoiceV1ExecutePostBody
     */
    arguments?: SalesDataCreditmemoCreationArgumentsInterface;
}

/**
 *
 * @export
 * @interface SalesRefundOrderV1ExecutePostBody
 */
export interface SalesRefundOrderV1ExecutePostBody {
    /**
     *
     * @type {Array<SalesDataCreditmemoItemCreationInterface>}
     * @memberof SalesRefundOrderV1ExecutePostBody
     */
    items?: Array<SalesDataCreditmemoItemCreationInterface>;
    /**
     *
     * @type {boolean}
     * @memberof SalesRefundOrderV1ExecutePostBody
     */
    notify?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SalesRefundOrderV1ExecutePostBody
     */
    appendComment?: boolean;
    /**
     *
     * @type {SalesDataCreditmemoCommentCreationInterface}
     * @memberof SalesRefundOrderV1ExecutePostBody
     */
    comment?: SalesDataCreditmemoCommentCreationInterface;
    /**
     *
     * @type {SalesDataCreditmemoCreationArgumentsInterface}
     * @memberof SalesRefundOrderV1ExecutePostBody
     */
    arguments?: SalesDataCreditmemoCreationArgumentsInterface;
}

/**
 *
 * @export
 * @interface SalesRuleCouponManagementV1DeleteByCodesPostBody
 */
export interface SalesRuleCouponManagementV1DeleteByCodesPostBody {
    /**
     *
     * @type {Array<string>}
     * @memberof SalesRuleCouponManagementV1DeleteByCodesPostBody
     */
    codes: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof SalesRuleCouponManagementV1DeleteByCodesPostBody
     */
    ignoreInvalidCoupons?: boolean;
}

/**
 *
 * @export
 * @interface SalesRuleCouponManagementV1DeleteByIdsPostBody
 */
export interface SalesRuleCouponManagementV1DeleteByIdsPostBody {
    /**
     *
     * @type {Array<number>}
     * @memberof SalesRuleCouponManagementV1DeleteByIdsPostBody
     */
    ids: Array<number>;
    /**
     *
     * @type {boolean}
     * @memberof SalesRuleCouponManagementV1DeleteByIdsPostBody
     */
    ignoreInvalidCoupons?: boolean;
}

/**
 *
 * @export
 * @interface SalesRuleCouponManagementV1GeneratePostBody
 */
export interface SalesRuleCouponManagementV1GeneratePostBody {
    /**
     *
     * @type {SalesRuleDataCouponGenerationSpecInterface}
     * @memberof SalesRuleCouponManagementV1GeneratePostBody
     */
    couponSpec: SalesRuleDataCouponGenerationSpecInterface;
}

/**
 *
 * @export
 * @interface SalesRuleCouponRepositoryV1SavePostBody
 */
export interface SalesRuleCouponRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesRuleDataCouponInterface}
     * @memberof SalesRuleCouponRepositoryV1SavePostBody
     */
    coupon: SalesRuleDataCouponInterface;
}

/**
 *
 * @export
 * @interface SalesRuleCouponRepositoryV1SavePutBody
 */
export interface SalesRuleCouponRepositoryV1SavePutBody {
    /**
     *
     * @type {SalesRuleDataCouponInterface}
     * @memberof SalesRuleCouponRepositoryV1SavePutBody
     */
    coupon: SalesRuleDataCouponInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\SalesRule\\Api\\Data\\ConditionInterface
 * @export
 * @interface SalesRuleDataConditionExtensionInterface
 */
export interface SalesRuleDataConditionExtensionInterface {
}

/**
 * Interface ConditionInterface
 * @export
 * @interface SalesRuleDataConditionInterface
 */
export interface SalesRuleDataConditionInterface {
    /**
     * Condition type
     * @type {string}
     * @memberof SalesRuleDataConditionInterface
     */
    conditionType: string;
    /**
     * List of conditions
     * @type {Array<SalesRuleDataConditionInterface>}
     * @memberof SalesRuleDataConditionInterface
     */
    conditions?: Array<SalesRuleDataConditionInterface>;
    /**
     * The aggregator type
     * @type {string}
     * @memberof SalesRuleDataConditionInterface
     */
    aggregatorType?: string;
    /**
     * The operator of the condition
     * @type {string}
     * @memberof SalesRuleDataConditionInterface
     */
    operator: string;
    /**
     * The attribute name of the condition
     * @type {string}
     * @memberof SalesRuleDataConditionInterface
     */
    attributeName?: string;
    /**
     * The value of the condition
     * @type {string}
     * @memberof SalesRuleDataConditionInterface
     */
    value: string;
    /**
     *
     * @type {SalesRuleDataConditionExtensionInterface}
     * @memberof SalesRuleDataConditionInterface
     */
    extensionAttributes?: SalesRuleDataConditionExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\SalesRule\\Api\\Data\\CouponInterface
 * @export
 * @interface SalesRuleDataCouponExtensionInterface
 */
export interface SalesRuleDataCouponExtensionInterface {
}

/**
 * ExtensionInterface class for @see \\Magento\\SalesRule\\Api\\Data\\CouponGenerationSpecInterface
 * @export
 * @interface SalesRuleDataCouponGenerationSpecExtensionInterface
 */
export interface SalesRuleDataCouponGenerationSpecExtensionInterface {
}

/**
 * CouponGenerationSpecInterface
 * @export
 * @interface SalesRuleDataCouponGenerationSpecInterface
 */
export interface SalesRuleDataCouponGenerationSpecInterface {
    /**
     * The id of the rule associated with the coupon
     * @type {number}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    ruleId: number;
    /**
     * Format of generated coupon code
     * @type {string}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    format: string;
    /**
     * Of coupons to generate
     * @type {number}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    quantity: number;
    /**
     * Length of coupon code
     * @type {number}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    length: number;
    /**
     * The prefix
     * @type {string}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    prefix?: string;
    /**
     * The suffix
     * @type {string}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    suffix?: string;
    /**
     * The spacing where the delimiter should exist
     * @type {number}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    delimiterAtEvery?: number;
    /**
     * The delimiter
     * @type {string}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    delimiter?: string;
    /**
     *
     * @type {SalesRuleDataCouponGenerationSpecExtensionInterface}
     * @memberof SalesRuleDataCouponGenerationSpecInterface
     */
    extensionAttributes?: SalesRuleDataCouponGenerationSpecExtensionInterface;
}

/**
 * Interface CouponInterface
 * @export
 * @interface SalesRuleDataCouponInterface
 */
export interface SalesRuleDataCouponInterface {
    /**
     * Coupon id
     * @type {number}
     * @memberof SalesRuleDataCouponInterface
     */
    couponId?: number;
    /**
     * The id of the rule associated with the coupon
     * @type {number}
     * @memberof SalesRuleDataCouponInterface
     */
    ruleId: number;
    /**
     * Coupon code
     * @type {string}
     * @memberof SalesRuleDataCouponInterface
     */
    code?: string;
    /**
     * Usage limit
     * @type {number}
     * @memberof SalesRuleDataCouponInterface
     */
    usageLimit?: number;
    /**
     * Usage limit per customer
     * @type {number}
     * @memberof SalesRuleDataCouponInterface
     */
    usagePerCustomer?: number;
    /**
     * The number of times the coupon has been used
     * @type {number}
     * @memberof SalesRuleDataCouponInterface
     */
    timesUsed: number;
    /**
     * Expiration date
     * @type {string}
     * @memberof SalesRuleDataCouponInterface
     */
    expirationDate?: string;
    /**
     * The coupon is primary coupon for the rule that it's associated with
     * @type {boolean}
     * @memberof SalesRuleDataCouponInterface
     */
    isPrimary: boolean;
    /**
     * When the coupon is created
     * @type {string}
     * @memberof SalesRuleDataCouponInterface
     */
    createdAt?: string;
    /**
     * Of coupon
     * @type {number}
     * @memberof SalesRuleDataCouponInterface
     */
    type?: number;
    /**
     *
     * @type {SalesRuleDataCouponExtensionInterface}
     * @memberof SalesRuleDataCouponInterface
     */
    extensionAttributes?: SalesRuleDataCouponExtensionInterface;
}

/**
 * Coupon mass delete results interface.
 * @export
 * @interface SalesRuleDataCouponMassDeleteResultInterface
 */
export interface SalesRuleDataCouponMassDeleteResultInterface {
    /**
     * List of failed items.
     * @type {Array<string>}
     * @memberof SalesRuleDataCouponMassDeleteResultInterface
     */
    failedItems: Array<string>;
    /**
     * List of missing items.
     * @type {Array<string>}
     * @memberof SalesRuleDataCouponMassDeleteResultInterface
     */
    missingItems: Array<string>;
}

/**
 *
 * @export
 * @interface SalesRuleDataCouponSearchResultInterface
 */
export interface SalesRuleDataCouponSearchResultInterface {
    /**
     * Rules.
     * @type {Array<SalesRuleDataCouponInterface>}
     * @memberof SalesRuleDataCouponSearchResultInterface
     */
    items: Array<SalesRuleDataCouponInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesRuleDataCouponSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesRuleDataCouponSearchResultInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\SalesRule\\Api\\Data\\RuleInterface
 * @export
 * @interface SalesRuleDataRuleExtensionInterface
 */
export interface SalesRuleDataRuleExtensionInterface {
    /**
     *
     * @type {number}
     * @memberof SalesRuleDataRuleExtensionInterface
     */
    rewardPointsDelta?: number;
}

/**
 * Interface RuleInterface
 * @export
 * @interface SalesRuleDataRuleInterface
 */
export interface SalesRuleDataRuleInterface {
    /**
     * Rule id
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    ruleId?: number;
    /**
     * Rule name
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    name?: string;
    /**
     * Display label
     * @type {Array<SalesRuleDataRuleLabelInterface>}
     * @memberof SalesRuleDataRuleInterface
     */
    storeLabels?: Array<SalesRuleDataRuleLabelInterface>;
    /**
     * Description
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    description?: string;
    /**
     * A list of websites the rule applies to
     * @type {Array<number>}
     * @memberof SalesRuleDataRuleInterface
     */
    websiteIds: Array<number>;
    /**
     * Ids of customer groups that the rule applies to
     * @type {Array<number>}
     * @memberof SalesRuleDataRuleInterface
     */
    customerGroupIds: Array<number>;
    /**
     * The start date when the coupon is active
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    fromDate?: string;
    /**
     * The end date when the coupon is active
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    toDate?: string;
    /**
     * Number of uses per customer
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    usesPerCustomer: number;
    /**
     * The coupon is active
     * @type {boolean}
     * @memberof SalesRuleDataRuleInterface
     */
    isActive: boolean;
    /**
     *
     * @type {SalesRuleDataConditionInterface}
     * @memberof SalesRuleDataRuleInterface
     */
    condition?: SalesRuleDataConditionInterface;
    /**
     *
     * @type {SalesRuleDataConditionInterface}
     * @memberof SalesRuleDataRuleInterface
     */
    actionCondition?: SalesRuleDataConditionInterface;
    /**
     * To stop rule processing
     * @type {boolean}
     * @memberof SalesRuleDataRuleInterface
     */
    stopRulesProcessing: boolean;
    /**
     * Is this field needed
     * @type {boolean}
     * @memberof SalesRuleDataRuleInterface
     */
    isAdvanced: boolean;
    /**
     * Product ids
     * @type {Array<number>}
     * @memberof SalesRuleDataRuleInterface
     */
    productIds?: Array<number>;
    /**
     * Sort order
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    sortOrder: number;
    /**
     * Simple action of the rule
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    simpleAction?: string;
    /**
     * Discount amount
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    discountAmount: number;
    /**
     * Maximum qty discount is applied
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    discountQty?: number;
    /**
     * Discount step
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    discountStep: number;
    /**
     * The rule applies to shipping
     * @type {boolean}
     * @memberof SalesRuleDataRuleInterface
     */
    applyToShipping: boolean;
    /**
     * How many times the rule has been used
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    timesUsed: number;
    /**
     * Whether the rule is in RSS
     * @type {boolean}
     * @memberof SalesRuleDataRuleInterface
     */
    isRss: boolean;
    /**
     * Coupon type
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    couponType: string;
    /**
     * To auto generate coupon
     * @type {boolean}
     * @memberof SalesRuleDataRuleInterface
     */
    useAutoGeneration: boolean;
    /**
     * Limit of uses per coupon
     * @type {number}
     * @memberof SalesRuleDataRuleInterface
     */
    usesPerCoupon: number;
    /**
     * To grant free shipping
     * @type {string}
     * @memberof SalesRuleDataRuleInterface
     */
    simpleFreeShipping?: string;
    /**
     *
     * @type {SalesRuleDataRuleExtensionInterface}
     * @memberof SalesRuleDataRuleInterface
     */
    extensionAttributes?: SalesRuleDataRuleExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\SalesRule\\Api\\Data\\RuleLabelInterface
 * @export
 * @interface SalesRuleDataRuleLabelExtensionInterface
 */
export interface SalesRuleDataRuleLabelExtensionInterface {
}

/**
 * Interface RuleLabelInterface
 * @export
 * @interface SalesRuleDataRuleLabelInterface
 */
export interface SalesRuleDataRuleLabelInterface {
    /**
     * StoreId
     * @type {number}
     * @memberof SalesRuleDataRuleLabelInterface
     */
    storeId: number;
    /**
     * The label for the store
     * @type {string}
     * @memberof SalesRuleDataRuleLabelInterface
     */
    storeLabel: string;
    /**
     *
     * @type {SalesRuleDataRuleLabelExtensionInterface}
     * @memberof SalesRuleDataRuleLabelInterface
     */
    extensionAttributes?: SalesRuleDataRuleLabelExtensionInterface;
}

/**
 *
 * @export
 * @interface SalesRuleDataRuleSearchResultInterface
 */
export interface SalesRuleDataRuleSearchResultInterface {
    /**
     * Rules.
     * @type {Array<SalesRuleDataRuleInterface>}
     * @memberof SalesRuleDataRuleSearchResultInterface
     */
    items: Array<SalesRuleDataRuleInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SalesRuleDataRuleSearchResultInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SalesRuleDataRuleSearchResultInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface SalesRuleRuleRepositoryV1SavePostBody
 */
export interface SalesRuleRuleRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesRuleDataRuleInterface}
     * @memberof SalesRuleRuleRepositoryV1SavePostBody
     */
    rule: SalesRuleDataRuleInterface;
}

/**
 *
 * @export
 * @interface SalesRuleRuleRepositoryV1SavePutBody
 */
export interface SalesRuleRuleRepositoryV1SavePutBody {
    /**
     *
     * @type {SalesRuleDataRuleInterface}
     * @memberof SalesRuleRuleRepositoryV1SavePutBody
     */
    rule: SalesRuleDataRuleInterface;
}

/**
 *
 * @export
 * @interface SalesShipOrderV1ExecutePostBody
 */
export interface SalesShipOrderV1ExecutePostBody {
    /**
     *
     * @type {Array<SalesDataShipmentItemCreationInterface>}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    items?: Array<SalesDataShipmentItemCreationInterface>;
    /**
     *
     * @type {boolean}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    notify?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    appendComment?: boolean;
    /**
     *
     * @type {SalesDataShipmentCommentCreationInterface}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    comment?: SalesDataShipmentCommentCreationInterface;
    /**
     *
     * @type {Array<SalesDataShipmentTrackCreationInterface>}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    tracks?: Array<SalesDataShipmentTrackCreationInterface>;
    /**
     *
     * @type {Array<SalesDataShipmentPackageCreationInterface>}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    packages?: Array<SalesDataShipmentPackageCreationInterface>;
    /**
     *
     * @type {SalesDataShipmentCreationArgumentsInterface}
     * @memberof SalesShipOrderV1ExecutePostBody
     */
    arguments?: SalesDataShipmentCreationArgumentsInterface;
}

/**
 *
 * @export
 * @interface SalesShipmentCommentRepositoryV1SavePostBody
 */
export interface SalesShipmentCommentRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataShipmentCommentInterface}
     * @memberof SalesShipmentCommentRepositoryV1SavePostBody
     */
    entity: SalesDataShipmentCommentInterface;
}

/**
 *
 * @export
 * @interface SalesShipmentRepositoryV1SavePostBody
 */
export interface SalesShipmentRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataShipmentInterface}
     * @memberof SalesShipmentRepositoryV1SavePostBody
     */
    entity: SalesDataShipmentInterface;
}

/**
 *
 * @export
 * @interface SalesShipmentTrackRepositoryV1SavePostBody
 */
export interface SalesShipmentTrackRepositoryV1SavePostBody {
    /**
     *
     * @type {SalesDataShipmentTrackInterface}
     * @memberof SalesShipmentTrackRepositoryV1SavePostBody
     */
    entity: SalesDataShipmentTrackInterface;
}

/**
 *
 * @export
 * @interface SharedCatalogCategoryManagementV1AssignCategoriesPostBody
 */
export interface SharedCatalogCategoryManagementV1AssignCategoriesPostBody {
    /**
     *
     * @type {Array<CatalogDataCategoryInterface>}
     * @memberof SharedCatalogCategoryManagementV1AssignCategoriesPostBody
     */
    categories: Array<CatalogDataCategoryInterface>;
}

/**
 *
 * @export
 * @interface SharedCatalogCategoryManagementV1UnassignCategoriesPostBody
 */
export interface SharedCatalogCategoryManagementV1UnassignCategoriesPostBody {
    /**
     *
     * @type {Array<CatalogDataCategoryInterface>}
     * @memberof SharedCatalogCategoryManagementV1UnassignCategoriesPostBody
     */
    categories: Array<CatalogDataCategoryInterface>;
}

/**
 *
 * @export
 * @interface SharedCatalogCompanyManagementV1AssignCompaniesPostBody
 */
export interface SharedCatalogCompanyManagementV1AssignCompaniesPostBody {
    /**
     *
     * @type {Array<CompanyDataCompanyInterface>}
     * @memberof SharedCatalogCompanyManagementV1AssignCompaniesPostBody
     */
    companies: Array<CompanyDataCompanyInterface>;
}

/**
 *
 * @export
 * @interface SharedCatalogCompanyManagementV1UnassignCompaniesPostBody
 */
export interface SharedCatalogCompanyManagementV1UnassignCompaniesPostBody {
    /**
     *
     * @type {Array<CompanyDataCompanyInterface>}
     * @memberof SharedCatalogCompanyManagementV1UnassignCompaniesPostBody
     */
    companies: Array<CompanyDataCompanyInterface>;
}

/**
 * Interface for Shared Catalog search results.
 * @export
 * @interface SharedCatalogDataSearchResultsInterface
 */
export interface SharedCatalogDataSearchResultsInterface {
    /**
     * Shared Catalog list.
     * @type {Array<SharedCatalogDataSharedCatalogInterface>}
     * @memberof SharedCatalogDataSearchResultsInterface
     */
    items: Array<SharedCatalogDataSharedCatalogInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof SharedCatalogDataSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof SharedCatalogDataSearchResultsInterface
     */
    totalCount: number;
}

/**
 * SharedCatalogInterface interface.
 * @export
 * @interface SharedCatalogDataSharedCatalogInterface
 */
export interface SharedCatalogDataSharedCatalogInterface {
    /**
     * ID.
     * @type {number}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    id?: number;
    /**
     * Shared Catalog name.
     * @type {string}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    name: string;
    /**
     * Shared Catalog description.
     * @type {string}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    description: string;
    /**
     * Customer Group Id.
     * @type {number}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    customerGroupId: number;
    /**
     * Shared Catalog type.
     * @type {number}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    type: number;
    /**
     * Created time for Shared Catalog.
     * @type {string}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    createdAt: string;
    /**
     * Admin id for Shared Catalog.
     * @type {number}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    createdBy: number;
    /**
     * Store id for Shared Catalog.
     * @type {number}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    storeId: number;
    /**
     * Tax class id.
     * @type {number}
     * @memberof SharedCatalogDataSharedCatalogInterface
     */
    taxClassId: number;
}

/**
 *
 * @export
 * @interface SharedCatalogProductManagementV1AssignProductsPostBody
 */
export interface SharedCatalogProductManagementV1AssignProductsPostBody {
    /**
     *
     * @type {Array<CatalogDataProductInterface>}
     * @memberof SharedCatalogProductManagementV1AssignProductsPostBody
     */
    products: Array<CatalogDataProductInterface>;
}

/**
 *
 * @export
 * @interface SharedCatalogProductManagementV1UnassignProductsPostBody
 */
export interface SharedCatalogProductManagementV1UnassignProductsPostBody {
    /**
     *
     * @type {Array<CatalogDataProductInterface>}
     * @memberof SharedCatalogProductManagementV1UnassignProductsPostBody
     */
    products: Array<CatalogDataProductInterface>;
}

/**
 *
 * @export
 * @interface SharedCatalogSharedCatalogRepositoryV1SavePostBody
 */
export interface SharedCatalogSharedCatalogRepositoryV1SavePostBody {
    /**
     *
     * @type {SharedCatalogDataSharedCatalogInterface}
     * @memberof SharedCatalogSharedCatalogRepositoryV1SavePostBody
     */
    sharedCatalog: SharedCatalogDataSharedCatalogInterface;
}

/**
 *
 * @export
 * @interface SharedCatalogSharedCatalogRepositoryV1SavePutBody
 */
export interface SharedCatalogSharedCatalogRepositoryV1SavePutBody {
    /**
     *
     * @type {SharedCatalogDataSharedCatalogInterface}
     * @memberof SharedCatalogSharedCatalogRepositoryV1SavePutBody
     */
    sharedCatalog: SharedCatalogDataSharedCatalogInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Store\\Api\\Data\\GroupInterface
 * @export
 * @interface StoreDataGroupExtensionInterface
 */
export interface StoreDataGroupExtensionInterface {
}

/**
 * Group interface
 * @export
 * @interface StoreDataGroupInterface
 */
export interface StoreDataGroupInterface {
    /**
     *
     * @type {number}
     * @memberof StoreDataGroupInterface
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof StoreDataGroupInterface
     */
    websiteId: number;
    /**
     *
     * @type {number}
     * @memberof StoreDataGroupInterface
     */
    rootCategoryId: number;
    /**
     *
     * @type {number}
     * @memberof StoreDataGroupInterface
     */
    defaultStoreId: number;
    /**
     *
     * @type {string}
     * @memberof StoreDataGroupInterface
     */
    name: string;
    /**
     * Group code.
     * @type {string}
     * @memberof StoreDataGroupInterface
     */
    code: string;
    /**
     *
     * @type {StoreDataGroupExtensionInterface}
     * @memberof StoreDataGroupInterface
     */
    extensionAttributes?: StoreDataGroupExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Store\\Api\\Data\\StoreConfigInterface
 * @export
 * @interface StoreDataStoreConfigExtensionInterface
 */
export interface StoreDataStoreConfigExtensionInterface {
}

/**
 * StoreConfig interface
 * @export
 * @interface StoreDataStoreConfigInterface
 */
export interface StoreDataStoreConfigInterface {
    /**
     * Store id
     * @type {number}
     * @memberof StoreDataStoreConfigInterface
     */
    id: number;
    /**
     * Store code
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    code: string;
    /**
     * Website id of the store
     * @type {number}
     * @memberof StoreDataStoreConfigInterface
     */
    websiteId: number;
    /**
     * Store locale
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    locale: string;
    /**
     * Base currency code
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    baseCurrencyCode: string;
    /**
     * Default display currency code
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    defaultDisplayCurrencyCode: string;
    /**
     * Timezone of the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    timezone: string;
    /**
     * The unit of weight
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    weightUnit: string;
    /**
     * Base URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    baseUrl: string;
    /**
     * Base link URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    baseLinkUrl: string;
    /**
     * Base static URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    baseStaticUrl: string;
    /**
     * Base media URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    baseMediaUrl: string;
    /**
     * Secure base URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    secureBaseUrl: string;
    /**
     * Secure base link URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    secureBaseLinkUrl: string;
    /**
     * Secure base static URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    secureBaseStaticUrl: string;
    /**
     * Secure base media URL for the store
     * @type {string}
     * @memberof StoreDataStoreConfigInterface
     */
    secureBaseMediaUrl: string;
    /**
     *
     * @type {StoreDataStoreConfigExtensionInterface}
     * @memberof StoreDataStoreConfigInterface
     */
    extensionAttributes?: StoreDataStoreConfigExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Store\\Api\\Data\\StoreInterface
 * @export
 * @interface StoreDataStoreExtensionInterface
 */
export interface StoreDataStoreExtensionInterface {
}

/**
 * Store interface
 * @export
 * @interface StoreDataStoreInterface
 */
export interface StoreDataStoreInterface {
    /**
     *
     * @type {number}
     * @memberof StoreDataStoreInterface
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof StoreDataStoreInterface
     */
    code: string;
    /**
     * Store name
     * @type {string}
     * @memberof StoreDataStoreInterface
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof StoreDataStoreInterface
     */
    websiteId: number;
    /**
     *
     * @type {number}
     * @memberof StoreDataStoreInterface
     */
    storeGroupId: number;
    /**
     *
     * @type {StoreDataStoreExtensionInterface}
     * @memberof StoreDataStoreInterface
     */
    extensionAttributes?: StoreDataStoreExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Store\\Api\\Data\\WebsiteInterface
 * @export
 * @interface StoreDataWebsiteExtensionInterface
 */
export interface StoreDataWebsiteExtensionInterface {
}

/**
 * Website interface
 * @export
 * @interface StoreDataWebsiteInterface
 */
export interface StoreDataWebsiteInterface {
    /**
     *
     * @type {number}
     * @memberof StoreDataWebsiteInterface
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof StoreDataWebsiteInterface
     */
    code: string;
    /**
     * Website name
     * @type {string}
     * @memberof StoreDataWebsiteInterface
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof StoreDataWebsiteInterface
     */
    defaultGroupId: number;
    /**
     *
     * @type {StoreDataWebsiteExtensionInterface}
     * @memberof StoreDataWebsiteInterface
     */
    extensionAttributes?: StoreDataWebsiteExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\AppliedTaxRateInterface
 * @export
 * @interface TaxDataAppliedTaxRateExtensionInterface
 */
export interface TaxDataAppliedTaxRateExtensionInterface {
}

/**
 * Applied tax rate interface.
 * @export
 * @interface TaxDataAppliedTaxRateInterface
 */
export interface TaxDataAppliedTaxRateInterface {
    /**
     * Code
     * @type {string}
     * @memberof TaxDataAppliedTaxRateInterface
     */
    code?: string;
    /**
     * Title
     * @type {string}
     * @memberof TaxDataAppliedTaxRateInterface
     */
    title?: string;
    /**
     * Tax Percent
     * @type {number}
     * @memberof TaxDataAppliedTaxRateInterface
     */
    percent?: number;
    /**
     *
     * @type {TaxDataAppliedTaxRateExtensionInterface}
     * @memberof TaxDataAppliedTaxRateInterface
     */
    extensionAttributes?: TaxDataAppliedTaxRateExtensionInterface;
}

/**
 * Interface GrandTotalDetailsInterface
 * @export
 * @interface TaxDataGrandTotalDetailsInterface
 */
export interface TaxDataGrandTotalDetailsInterface {
    /**
     * Tax amount value
     * @type {number}
     * @memberof TaxDataGrandTotalDetailsInterface
     */
    amount: number;
    /**
     * Tax rates info
     * @type {Array<TaxDataGrandTotalRatesInterface>}
     * @memberof TaxDataGrandTotalDetailsInterface
     */
    rates: Array<TaxDataGrandTotalRatesInterface>;
    /**
     * Group identifier
     * @type {number}
     * @memberof TaxDataGrandTotalDetailsInterface
     */
    groupId: number;
}

/**
 * Interface GrandTotalRatesInterface
 * @export
 * @interface TaxDataGrandTotalRatesInterface
 */
export interface TaxDataGrandTotalRatesInterface {
    /**
     * Tax percentage value
     * @type {string}
     * @memberof TaxDataGrandTotalRatesInterface
     */
    percent: string;
    /**
     * Rate title
     * @type {string}
     * @memberof TaxDataGrandTotalRatesInterface
     */
    title: string;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\OrderTaxDetailsAppliedTaxInterface
 * @export
 * @interface TaxDataOrderTaxDetailsAppliedTaxExtensionInterface
 */
export interface TaxDataOrderTaxDetailsAppliedTaxExtensionInterface {
    /**
     *
     * @type {Array<TaxDataAppliedTaxRateInterface>}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxExtensionInterface
     */
    rates?: Array<TaxDataAppliedTaxRateInterface>;
}

/**
 * Interface OrderTaxDetailsAppliedTaxInterface
 * @export
 * @interface TaxDataOrderTaxDetailsAppliedTaxInterface
 */
export interface TaxDataOrderTaxDetailsAppliedTaxInterface {
    /**
     * Code
     * @type {string}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxInterface
     */
    code?: string;
    /**
     * Title
     * @type {string}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxInterface
     */
    title?: string;
    /**
     * Tax Percent
     * @type {number}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxInterface
     */
    percent?: number;
    /**
     * Tax amount
     * @type {number}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxInterface
     */
    amount: number;
    /**
     * Tax amount in base currency
     * @type {number}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxInterface
     */
    baseAmount: number;
    /**
     *
     * @type {TaxDataOrderTaxDetailsAppliedTaxExtensionInterface}
     * @memberof TaxDataOrderTaxDetailsAppliedTaxInterface
     */
    extensionAttributes?: TaxDataOrderTaxDetailsAppliedTaxExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\OrderTaxDetailsItemInterface
 * @export
 * @interface TaxDataOrderTaxDetailsItemExtensionInterface
 */
export interface TaxDataOrderTaxDetailsItemExtensionInterface {
}

/**
 * Interface OrderTaxDetailsItemInterface
 * @export
 * @interface TaxDataOrderTaxDetailsItemInterface
 */
export interface TaxDataOrderTaxDetailsItemInterface {
    /**
     * Type (shipping, product, weee, gift wrapping, etc)
     * @type {string}
     * @memberof TaxDataOrderTaxDetailsItemInterface
     */
    type?: string;
    /**
     * Item id if this item is a product
     * @type {number}
     * @memberof TaxDataOrderTaxDetailsItemInterface
     */
    itemId?: number;
    /**
     * Associated item id if this item is associated with another item, null otherwise
     * @type {number}
     * @memberof TaxDataOrderTaxDetailsItemInterface
     */
    associatedItemId?: number;
    /**
     * Applied taxes
     * @type {Array<TaxDataOrderTaxDetailsAppliedTaxInterface>}
     * @memberof TaxDataOrderTaxDetailsItemInterface
     */
    appliedTaxes?: Array<TaxDataOrderTaxDetailsAppliedTaxInterface>;
    /**
     *
     * @type {TaxDataOrderTaxDetailsItemExtensionInterface}
     * @memberof TaxDataOrderTaxDetailsItemInterface
     */
    extensionAttributes?: TaxDataOrderTaxDetailsItemExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\TaxClassInterface
 * @export
 * @interface TaxDataTaxClassExtensionInterface
 */
export interface TaxDataTaxClassExtensionInterface {
}

/**
 * Tax class interface.
 * @export
 * @interface TaxDataTaxClassInterface
 */
export interface TaxDataTaxClassInterface {
    /**
     * Tax class ID.
     * @type {number}
     * @memberof TaxDataTaxClassInterface
     */
    classId?: number;
    /**
     * Tax class name.
     * @type {string}
     * @memberof TaxDataTaxClassInterface
     */
    className: string;
    /**
     * Tax class type.
     * @type {string}
     * @memberof TaxDataTaxClassInterface
     */
    classType: string;
    /**
     *
     * @type {TaxDataTaxClassExtensionInterface}
     * @memberof TaxDataTaxClassInterface
     */
    extensionAttributes?: TaxDataTaxClassExtensionInterface;
}

/**
 * Interface for tax class search results.
 * @export
 * @interface TaxDataTaxClassSearchResultsInterface
 */
export interface TaxDataTaxClassSearchResultsInterface {
    /**
     * Items
     * @type {Array<TaxDataTaxClassInterface>}
     * @memberof TaxDataTaxClassSearchResultsInterface
     */
    items: Array<TaxDataTaxClassInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof TaxDataTaxClassSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof TaxDataTaxClassSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\TaxRateInterface
 * @export
 * @interface TaxDataTaxRateExtensionInterface
 */
export interface TaxDataTaxRateExtensionInterface {
}

/**
 * Tax rate interface.
 * @export
 * @interface TaxDataTaxRateInterface
 */
export interface TaxDataTaxRateInterface {
    /**
     * Id
     * @type {number}
     * @memberof TaxDataTaxRateInterface
     */
    id?: number;
    /**
     * Country id
     * @type {string}
     * @memberof TaxDataTaxRateInterface
     */
    taxCountryId: string;
    /**
     * Region id
     * @type {number}
     * @memberof TaxDataTaxRateInterface
     */
    taxRegionId?: number;
    /**
     * Region name
     * @type {string}
     * @memberof TaxDataTaxRateInterface
     */
    regionName?: string;
    /**
     * Postcode
     * @type {string}
     * @memberof TaxDataTaxRateInterface
     */
    taxPostcode?: string;
    /**
     * Zip is range
     * @type {number}
     * @memberof TaxDataTaxRateInterface
     */
    zipIsRange?: number;
    /**
     * Zip range from
     * @type {number}
     * @memberof TaxDataTaxRateInterface
     */
    zipFrom?: number;
    /**
     * Zip range to
     * @type {number}
     * @memberof TaxDataTaxRateInterface
     */
    zipTo?: number;
    /**
     * Tax rate in percentage
     * @type {number}
     * @memberof TaxDataTaxRateInterface
     */
    rate: number;
    /**
     * Tax rate code
     * @type {string}
     * @memberof TaxDataTaxRateInterface
     */
    code: string;
    /**
     * Tax rate titles
     * @type {Array<TaxDataTaxRateTitleInterface>}
     * @memberof TaxDataTaxRateInterface
     */
    titles?: Array<TaxDataTaxRateTitleInterface>;
    /**
     *
     * @type {TaxDataTaxRateExtensionInterface}
     * @memberof TaxDataTaxRateInterface
     */
    extensionAttributes?: TaxDataTaxRateExtensionInterface;
}

/**
 * Interface for tax rate search results.
 * @export
 * @interface TaxDataTaxRateSearchResultsInterface
 */
export interface TaxDataTaxRateSearchResultsInterface {
    /**
     * Items
     * @type {Array<TaxDataTaxRateInterface>}
     * @memberof TaxDataTaxRateSearchResultsInterface
     */
    items: Array<TaxDataTaxRateInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof TaxDataTaxRateSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof TaxDataTaxRateSearchResultsInterface
     */
    totalCount: number;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\TaxRateTitleInterface
 * @export
 * @interface TaxDataTaxRateTitleExtensionInterface
 */
export interface TaxDataTaxRateTitleExtensionInterface {
}

/**
 * Tax rate title interface.
 * @export
 * @interface TaxDataTaxRateTitleInterface
 */
export interface TaxDataTaxRateTitleInterface {
    /**
     * Store id
     * @type {string}
     * @memberof TaxDataTaxRateTitleInterface
     */
    storeId: string;
    /**
     * Title value
     * @type {string}
     * @memberof TaxDataTaxRateTitleInterface
     */
    value: string;
    /**
     *
     * @type {TaxDataTaxRateTitleExtensionInterface}
     * @memberof TaxDataTaxRateTitleInterface
     */
    extensionAttributes?: TaxDataTaxRateTitleExtensionInterface;
}

/**
 * ExtensionInterface class for @see \\Magento\\Tax\\Api\\Data\\TaxRuleInterface
 * @export
 * @interface TaxDataTaxRuleExtensionInterface
 */
export interface TaxDataTaxRuleExtensionInterface {
}

/**
 * Tax rule interface.
 * @export
 * @interface TaxDataTaxRuleInterface
 */
export interface TaxDataTaxRuleInterface {
    /**
     * Id
     * @type {number}
     * @memberof TaxDataTaxRuleInterface
     */
    id?: number;
    /**
     * Tax rule code
     * @type {string}
     * @memberof TaxDataTaxRuleInterface
     */
    code: string;
    /**
     * Priority
     * @type {number}
     * @memberof TaxDataTaxRuleInterface
     */
    priority: number;
    /**
     * Sort order.
     * @type {number}
     * @memberof TaxDataTaxRuleInterface
     */
    position: number;
    /**
     * Customer tax class id
     * @type {Array<number>}
     * @memberof TaxDataTaxRuleInterface
     */
    customerTaxClassIds: Array<number>;
    /**
     * Product tax class id
     * @type {Array<number>}
     * @memberof TaxDataTaxRuleInterface
     */
    productTaxClassIds: Array<number>;
    /**
     * Tax rate ids
     * @type {Array<number>}
     * @memberof TaxDataTaxRuleInterface
     */
    taxRateIds: Array<number>;
    /**
     * Calculate subtotal.
     * @type {boolean}
     * @memberof TaxDataTaxRuleInterface
     */
    calculateSubtotal?: boolean;
    /**
     *
     * @type {TaxDataTaxRuleExtensionInterface}
     * @memberof TaxDataTaxRuleInterface
     */
    extensionAttributes?: TaxDataTaxRuleExtensionInterface;
}

/**
 * Interface for tax rule search results.
 * @export
 * @interface TaxDataTaxRuleSearchResultsInterface
 */
export interface TaxDataTaxRuleSearchResultsInterface {
    /**
     * Items
     * @type {Array<TaxDataTaxRuleInterface>}
     * @memberof TaxDataTaxRuleSearchResultsInterface
     */
    items: Array<TaxDataTaxRuleInterface>;
    /**
     *
     * @type {FrameworkSearchCriteriaInterface}
     * @memberof TaxDataTaxRuleSearchResultsInterface
     */
    searchCriteria: FrameworkSearchCriteriaInterface;
    /**
     * Total count.
     * @type {number}
     * @memberof TaxDataTaxRuleSearchResultsInterface
     */
    totalCount: number;
}

/**
 *
 * @export
 * @interface TaxTaxClassRepositoryV1SavePostBody
 */
export interface TaxTaxClassRepositoryV1SavePostBody {
    /**
     *
     * @type {TaxDataTaxClassInterface}
     * @memberof TaxTaxClassRepositoryV1SavePostBody
     */
    taxClass: TaxDataTaxClassInterface;
}

/**
 *
 * @export
 * @interface TaxTaxClassRepositoryV1SavePutBody
 */
export interface TaxTaxClassRepositoryV1SavePutBody {
    /**
     *
     * @type {TaxDataTaxClassInterface}
     * @memberof TaxTaxClassRepositoryV1SavePutBody
     */
    taxClass: TaxDataTaxClassInterface;
}

/**
 *
 * @export
 * @interface TaxTaxRateRepositoryV1SavePostBody
 */
export interface TaxTaxRateRepositoryV1SavePostBody {
    /**
     *
     * @type {TaxDataTaxRateInterface}
     * @memberof TaxTaxRateRepositoryV1SavePostBody
     */
    taxRate: TaxDataTaxRateInterface;
}

/**
 *
 * @export
 * @interface TaxTaxRateRepositoryV1SavePutBody
 */
export interface TaxTaxRateRepositoryV1SavePutBody {
    /**
     *
     * @type {TaxDataTaxRateInterface}
     * @memberof TaxTaxRateRepositoryV1SavePutBody
     */
    taxRate: TaxDataTaxRateInterface;
}

/**
 *
 * @export
 * @interface TaxTaxRuleRepositoryV1SavePostBody
 */
export interface TaxTaxRuleRepositoryV1SavePostBody {
    /**
     *
     * @type {TaxDataTaxRuleInterface}
     * @memberof TaxTaxRuleRepositoryV1SavePostBody
     */
    rule: TaxDataTaxRuleInterface;
}

/**
 *
 * @export
 * @interface TaxTaxRuleRepositoryV1SavePutBody
 */
export interface TaxTaxRuleRepositoryV1SavePutBody {
    /**
     *
     * @type {TaxDataTaxRuleInterface}
     * @memberof TaxTaxRuleRepositoryV1SavePutBody
     */
    rule: TaxDataTaxRuleInterface;
}

/**
 * Gateway vault payment token interface.
 * @export
 * @interface VaultDataPaymentTokenInterface
 */
export interface VaultDataPaymentTokenInterface {
    /**
     * Entity ID.
     * @type {number}
     * @memberof VaultDataPaymentTokenInterface
     */
    entityId?: number;
    /**
     * Customer ID.
     * @type {number}
     * @memberof VaultDataPaymentTokenInterface
     */
    customerId?: number;
    /**
     * Public hash
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    publicHash: string;
    /**
     * Payment method code
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    paymentMethodCode: string;
    /**
     * Type
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    type: string;
    /**
     * Token creation timestamp
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    createdAt?: string;
    /**
     * Token expiration timestamp
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    expiresAt?: string;
    /**
     * Gateway token ID
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    gatewayToken: string;
    /**
     * Token details
     * @type {string}
     * @memberof VaultDataPaymentTokenInterface
     */
    tokenDetails: string;
    /**
     * Is active.
     * @type {boolean}
     * @memberof VaultDataPaymentTokenInterface
     */
    isActive: boolean;
    /**
     * Is visible.
     * @type {boolean}
     * @memberof VaultDataPaymentTokenInterface
     */
    isVisible: boolean;
}

/**
 * ExtensionInterface class for @see \\Magento\\Weee\\Api\\Data\\ProductRender\\WeeeAdjustmentAttributeInterface
 * @export
 * @interface WeeeDataProductRenderWeeeAdjustmentAttributeExtensionInterface
 */
export interface WeeeDataProductRenderWeeeAdjustmentAttributeExtensionInterface {
}

/**
 * List of all weee attributes, their amounts, etc.., that product has
 * @export
 * @interface WeeeDataProductRenderWeeeAdjustmentAttributeInterface
 */
export interface WeeeDataProductRenderWeeeAdjustmentAttributeInterface {
    /**
     * Weee attribute amount
     * @type {string}
     * @memberof WeeeDataProductRenderWeeeAdjustmentAttributeInterface
     */
    amount: string;
    /**
     * Tax which is calculated to fixed product tax attribute
     * @type {string}
     * @memberof WeeeDataProductRenderWeeeAdjustmentAttributeInterface
     */
    taxAmount: string;
    /**
     * Tax amount of weee attribute
     * @type {string}
     * @memberof WeeeDataProductRenderWeeeAdjustmentAttributeInterface
     */
    taxAmountInclTax: string;
    /**
     * Product amount exclude tax
     * @type {string}
     * @memberof WeeeDataProductRenderWeeeAdjustmentAttributeInterface
     */
    amountExclTax: string;
    /**
     * Weee attribute code
     * @type {string}
     * @memberof WeeeDataProductRenderWeeeAdjustmentAttributeInterface
     */
    attributeCode: string;
    /**
     *
     * @type {WeeeDataProductRenderWeeeAdjustmentAttributeExtensionInterface}
     * @memberof WeeeDataProductRenderWeeeAdjustmentAttributeInterface
     */
    extensionAttributes: WeeeDataProductRenderWeeeAdjustmentAttributeExtensionInterface;
}

/**
 *
 * @export
 * @interface WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody
 */
export interface WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody {
    /**
     *
     * @type {string}
     * @memberof WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody
     */
    email: string;
    /**
     *
     * @type {QuoteDataPaymentInterface}
     * @memberof WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody
     */
    paymentMethod: QuoteDataPaymentInterface;
    /**
     *
     * @type {QuoteDataAddressInterface}
     * @memberof WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody
     */
    billingAddress?: QuoteDataAddressInterface;
}


/**
 * AnalyticsLinkProviderV1Api - fetch parameter creator
 * @export
 */
export const AnalyticsLinkProviderV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsLinkProviderV1GetGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/analytics/link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsLinkProviderV1Api - functional programming interface
 * @export
 */
export const AnalyticsLinkProviderV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsLinkProviderV1GetGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnalyticsDataLinkInterface> {
            const localVarFetchArgs = AnalyticsLinkProviderV1ApiFetchParamCreator(configuration).analyticsLinkProviderV1GetGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AnalyticsLinkProviderV1Api - factory interface
 * @export
 */
export const AnalyticsLinkProviderV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsLinkProviderV1GetGet(options?: any) {
            return AnalyticsLinkProviderV1ApiFp(configuration).analyticsLinkProviderV1GetGet(options)(fetch, basePath);
        },
    };
};

/**
 * AnalyticsLinkProviderV1Api - object-oriented interface
 * @export
 * @class AnalyticsLinkProviderV1Api
 * @extends {BaseAPI}
 */
export class AnalyticsLinkProviderV1Api extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsLinkProviderV1Api
     */
    public analyticsLinkProviderV1GetGet(options?: any) {
        return AnalyticsLinkProviderV1ApiFp(this.configuration).analyticsLinkProviderV1GetGet(options)(this.fetch, this.basePath);
    }

}

/**
 * BackendModuleServiceV1Api - fetch parameter creator
 * @export
 */
export const BackendModuleServiceV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an array of enabled modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backendModuleServiceV1GetModulesGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/modules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackendModuleServiceV1Api - functional programming interface
 * @export
 */
export const BackendModuleServiceV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an array of enabled modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backendModuleServiceV1GetModulesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = BackendModuleServiceV1ApiFetchParamCreator(configuration).backendModuleServiceV1GetModulesGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BackendModuleServiceV1Api - factory interface
 * @export
 */
export const BackendModuleServiceV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns an array of enabled modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backendModuleServiceV1GetModulesGet(options?: any) {
            return BackendModuleServiceV1ApiFp(configuration).backendModuleServiceV1GetModulesGet(options)(fetch, basePath);
        },
    };
};

/**
 * BackendModuleServiceV1Api - object-oriented interface
 * @export
 * @class BackendModuleServiceV1Api
 * @extends {BaseAPI}
 */
export class BackendModuleServiceV1Api extends BaseAPI {
    /**
     * Returns an array of enabled modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackendModuleServiceV1Api
     */
    public backendModuleServiceV1GetModulesGet(options?: any) {
        return BackendModuleServiceV1ApiFp(this.configuration).backendModuleServiceV1GetModulesGet(options)(this.fetch, this.basePath);
    }

}

/**
 * BundleProductLinkManagementV1Api - fetch parameter creator
 * @export
 */
export const BundleProductLinkManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add child product to specified Bundle option by product sku
         * @param {string} sku
         * @param {number} optionId
         * @param {BundleProductLinkManagementV1AddChildByProductSkuPostBody} [bundleProductLinkManagementV1AddChildByProductSkuPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1AddChildByProductSkuPost(sku: string, optionId: number, bundleProductLinkManagementV1AddChildByProductSkuPostBody?: BundleProductLinkManagementV1AddChildByProductSkuPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling bundleProductLinkManagementV1AddChildByProductSkuPost.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling bundleProductLinkManagementV1AddChildByProductSkuPost.');
            }
            const localVarPath = `/V1/bundle-products/{sku}/links/{optionId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BundleProductLinkManagementV1AddChildByProductSkuPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bundleProductLinkManagementV1AddChildByProductSkuPostBody || {}) : (bundleProductLinkManagementV1AddChildByProductSkuPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all children for Bundle product
         * @param {string} productSku
         * @param {number} [optionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1GetChildrenGet(productSku: string, optionId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling bundleProductLinkManagementV1GetChildrenGet.');
            }
            const localVarPath = `/V1/bundle-products/{productSku}/children`
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (optionId !== undefined) {
                localVarQueryParameter['optionId'] = optionId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove product from Bundle product option
         * @param {string} sku
         * @param {number} optionId
         * @param {string} childSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1RemoveChildDelete(sku: string, optionId: number, childSku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling bundleProductLinkManagementV1RemoveChildDelete.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling bundleProductLinkManagementV1RemoveChildDelete.');
            }
            // verify required parameter 'childSku' is not null or undefined
            if (childSku === null || childSku === undefined) {
                throw new RequiredError('childSku','Required parameter childSku was null or undefined when calling bundleProductLinkManagementV1RemoveChildDelete.');
            }
            const localVarPath = `/V1/bundle-products/{sku}/options/{optionId}/children/{childSku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)))
                .replace(`{${"childSku"}}`, encodeURIComponent(String(childSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} sku
         * @param {string} id
         * @param {BundleProductLinkManagementV1SaveChildPutBody} [bundleProductLinkManagementV1SaveChildPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1SaveChildPut(sku: string, id: string, bundleProductLinkManagementV1SaveChildPutBody?: BundleProductLinkManagementV1SaveChildPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling bundleProductLinkManagementV1SaveChildPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bundleProductLinkManagementV1SaveChildPut.');
            }
            const localVarPath = `/V1/bundle-products/{sku}/links/{id}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BundleProductLinkManagementV1SaveChildPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bundleProductLinkManagementV1SaveChildPutBody || {}) : (bundleProductLinkManagementV1SaveChildPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleProductLinkManagementV1Api - functional programming interface
 * @export
 */
export const BundleProductLinkManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add child product to specified Bundle option by product sku
         * @param {string} sku
         * @param {number} optionId
         * @param {BundleProductLinkManagementV1AddChildByProductSkuPostBody} [bundleProductLinkManagementV1AddChildByProductSkuPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1AddChildByProductSkuPost(sku: string, optionId: number, bundleProductLinkManagementV1AddChildByProductSkuPostBody?: BundleProductLinkManagementV1AddChildByProductSkuPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = BundleProductLinkManagementV1ApiFetchParamCreator(configuration).bundleProductLinkManagementV1AddChildByProductSkuPost(sku, optionId, bundleProductLinkManagementV1AddChildByProductSkuPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all children for Bundle product
         * @param {string} productSku
         * @param {number} [optionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1GetChildrenGet(productSku: string, optionId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BundleDataLinkInterface>> {
            const localVarFetchArgs = BundleProductLinkManagementV1ApiFetchParamCreator(configuration).bundleProductLinkManagementV1GetChildrenGet(productSku, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove product from Bundle product option
         * @param {string} sku
         * @param {number} optionId
         * @param {string} childSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1RemoveChildDelete(sku: string, optionId: number, childSku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = BundleProductLinkManagementV1ApiFetchParamCreator(configuration).bundleProductLinkManagementV1RemoveChildDelete(sku, optionId, childSku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} sku
         * @param {string} id
         * @param {BundleProductLinkManagementV1SaveChildPutBody} [bundleProductLinkManagementV1SaveChildPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1SaveChildPut(sku: string, id: string, bundleProductLinkManagementV1SaveChildPutBody?: BundleProductLinkManagementV1SaveChildPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = BundleProductLinkManagementV1ApiFetchParamCreator(configuration).bundleProductLinkManagementV1SaveChildPut(sku, id, bundleProductLinkManagementV1SaveChildPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BundleProductLinkManagementV1Api - factory interface
 * @export
 */
export const BundleProductLinkManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add child product to specified Bundle option by product sku
         * @param {string} sku
         * @param {number} optionId
         * @param {BundleProductLinkManagementV1AddChildByProductSkuPostBody} [bundleProductLinkManagementV1AddChildByProductSkuPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1AddChildByProductSkuPost(sku: string, optionId: number, bundleProductLinkManagementV1AddChildByProductSkuPostBody?: BundleProductLinkManagementV1AddChildByProductSkuPostBody, options?: any) {
            return BundleProductLinkManagementV1ApiFp(configuration).bundleProductLinkManagementV1AddChildByProductSkuPost(sku, optionId, bundleProductLinkManagementV1AddChildByProductSkuPostBody, options)(fetch, basePath);
        },
        /**
         * Get all children for Bundle product
         * @param {string} productSku
         * @param {number} [optionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1GetChildrenGet(productSku: string, optionId?: number, options?: any) {
            return BundleProductLinkManagementV1ApiFp(configuration).bundleProductLinkManagementV1GetChildrenGet(productSku, optionId, options)(fetch, basePath);
        },
        /**
         * Remove product from Bundle product option
         * @param {string} sku
         * @param {number} optionId
         * @param {string} childSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1RemoveChildDelete(sku: string, optionId: number, childSku: string, options?: any) {
            return BundleProductLinkManagementV1ApiFp(configuration).bundleProductLinkManagementV1RemoveChildDelete(sku, optionId, childSku, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} sku
         * @param {string} id
         * @param {BundleProductLinkManagementV1SaveChildPutBody} [bundleProductLinkManagementV1SaveChildPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductLinkManagementV1SaveChildPut(sku: string, id: string, bundleProductLinkManagementV1SaveChildPutBody?: BundleProductLinkManagementV1SaveChildPutBody, options?: any) {
            return BundleProductLinkManagementV1ApiFp(configuration).bundleProductLinkManagementV1SaveChildPut(sku, id, bundleProductLinkManagementV1SaveChildPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * BundleProductLinkManagementV1Api - object-oriented interface
 * @export
 * @class BundleProductLinkManagementV1Api
 * @extends {BaseAPI}
 */
export class BundleProductLinkManagementV1Api extends BaseAPI {
    /**
     * Add child product to specified Bundle option by product sku
     * @param {string} sku
     * @param {number} optionId
     * @param {BundleProductLinkManagementV1AddChildByProductSkuPostBody} [bundleProductLinkManagementV1AddChildByProductSkuPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductLinkManagementV1Api
     */
    public bundleProductLinkManagementV1AddChildByProductSkuPost(sku: string, optionId: number, bundleProductLinkManagementV1AddChildByProductSkuPostBody?: BundleProductLinkManagementV1AddChildByProductSkuPostBody, options?: any) {
        return BundleProductLinkManagementV1ApiFp(this.configuration).bundleProductLinkManagementV1AddChildByProductSkuPost(sku, optionId, bundleProductLinkManagementV1AddChildByProductSkuPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Get all children for Bundle product
     * @param {string} productSku
     * @param {number} [optionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductLinkManagementV1Api
     */
    public bundleProductLinkManagementV1GetChildrenGet(productSku: string, optionId?: number, options?: any) {
        return BundleProductLinkManagementV1ApiFp(this.configuration).bundleProductLinkManagementV1GetChildrenGet(productSku, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove product from Bundle product option
     * @param {string} sku
     * @param {number} optionId
     * @param {string} childSku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductLinkManagementV1Api
     */
    public bundleProductLinkManagementV1RemoveChildDelete(sku: string, optionId: number, childSku: string, options?: any) {
        return BundleProductLinkManagementV1ApiFp(this.configuration).bundleProductLinkManagementV1RemoveChildDelete(sku, optionId, childSku, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} sku
     * @param {string} id
     * @param {BundleProductLinkManagementV1SaveChildPutBody} [bundleProductLinkManagementV1SaveChildPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductLinkManagementV1Api
     */
    public bundleProductLinkManagementV1SaveChildPut(sku: string, id: string, bundleProductLinkManagementV1SaveChildPutBody?: BundleProductLinkManagementV1SaveChildPutBody, options?: any) {
        return BundleProductLinkManagementV1ApiFp(this.configuration).bundleProductLinkManagementV1SaveChildPut(sku, id, bundleProductLinkManagementV1SaveChildPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * BundleProductOptionManagementV1Api - fetch parameter creator
 * @export
 */
export const BundleProductOptionManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add new option for bundle product
         * @param {BundleProductOptionManagementV1SavePostBody} [bundleProductOptionManagementV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody?: BundleProductOptionManagementV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/bundle-products/options/add`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BundleProductOptionManagementV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bundleProductOptionManagementV1SavePostBody || {}) : (bundleProductOptionManagementV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new option for bundle product
         * @param {string} optionId
         * @param {BundleProductOptionManagementV1SavePutBody} [bundleProductOptionManagementV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionManagementV1SavePut(optionId: string, bundleProductOptionManagementV1SavePutBody?: BundleProductOptionManagementV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling bundleProductOptionManagementV1SavePut.');
            }
            const localVarPath = `/V1/bundle-products/options/{optionId}`
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BundleProductOptionManagementV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bundleProductOptionManagementV1SavePutBody || {}) : (bundleProductOptionManagementV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleProductOptionManagementV1Api - functional programming interface
 * @export
 */
export const BundleProductOptionManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add new option for bundle product
         * @param {BundleProductOptionManagementV1SavePostBody} [bundleProductOptionManagementV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody?: BundleProductOptionManagementV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = BundleProductOptionManagementV1ApiFetchParamCreator(configuration).bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add new option for bundle product
         * @param {string} optionId
         * @param {BundleProductOptionManagementV1SavePutBody} [bundleProductOptionManagementV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionManagementV1SavePut(optionId: string, bundleProductOptionManagementV1SavePutBody?: BundleProductOptionManagementV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = BundleProductOptionManagementV1ApiFetchParamCreator(configuration).bundleProductOptionManagementV1SavePut(optionId, bundleProductOptionManagementV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BundleProductOptionManagementV1Api - factory interface
 * @export
 */
export const BundleProductOptionManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add new option for bundle product
         * @param {BundleProductOptionManagementV1SavePostBody} [bundleProductOptionManagementV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody?: BundleProductOptionManagementV1SavePostBody, options?: any) {
            return BundleProductOptionManagementV1ApiFp(configuration).bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Add new option for bundle product
         * @param {string} optionId
         * @param {BundleProductOptionManagementV1SavePutBody} [bundleProductOptionManagementV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionManagementV1SavePut(optionId: string, bundleProductOptionManagementV1SavePutBody?: BundleProductOptionManagementV1SavePutBody, options?: any) {
            return BundleProductOptionManagementV1ApiFp(configuration).bundleProductOptionManagementV1SavePut(optionId, bundleProductOptionManagementV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * BundleProductOptionManagementV1Api - object-oriented interface
 * @export
 * @class BundleProductOptionManagementV1Api
 * @extends {BaseAPI}
 */
export class BundleProductOptionManagementV1Api extends BaseAPI {
    /**
     * Add new option for bundle product
     * @param {BundleProductOptionManagementV1SavePostBody} [bundleProductOptionManagementV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductOptionManagementV1Api
     */
    public bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody?: BundleProductOptionManagementV1SavePostBody, options?: any) {
        return BundleProductOptionManagementV1ApiFp(this.configuration).bundleProductOptionManagementV1SavePost(bundleProductOptionManagementV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add new option for bundle product
     * @param {string} optionId
     * @param {BundleProductOptionManagementV1SavePutBody} [bundleProductOptionManagementV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductOptionManagementV1Api
     */
    public bundleProductOptionManagementV1SavePut(optionId: string, bundleProductOptionManagementV1SavePutBody?: BundleProductOptionManagementV1SavePutBody, options?: any) {
        return BundleProductOptionManagementV1ApiFp(this.configuration).bundleProductOptionManagementV1SavePut(optionId, bundleProductOptionManagementV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * BundleProductOptionRepositoryV1Api - fetch parameter creator
 * @export
 */
export const BundleProductOptionRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove bundle option
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1DeleteByIdDelete(sku: string, optionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling bundleProductOptionRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling bundleProductOptionRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/bundle-products/{sku}/options/{optionId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get option for bundle product
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1GetGet(sku: string, optionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling bundleProductOptionRepositoryV1GetGet.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling bundleProductOptionRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/bundle-products/{sku}/options/{optionId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all options for bundle product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1GetListGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling bundleProductOptionRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/bundle-products/{sku}/options/all`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleProductOptionRepositoryV1Api - functional programming interface
 * @export
 */
export const BundleProductOptionRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove bundle option
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1DeleteByIdDelete(sku: string, optionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = BundleProductOptionRepositoryV1ApiFetchParamCreator(configuration).bundleProductOptionRepositoryV1DeleteByIdDelete(sku, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get option for bundle product
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1GetGet(sku: string, optionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BundleDataOptionInterface> {
            const localVarFetchArgs = BundleProductOptionRepositoryV1ApiFetchParamCreator(configuration).bundleProductOptionRepositoryV1GetGet(sku, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all options for bundle product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1GetListGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BundleDataOptionInterface>> {
            const localVarFetchArgs = BundleProductOptionRepositoryV1ApiFetchParamCreator(configuration).bundleProductOptionRepositoryV1GetListGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BundleProductOptionRepositoryV1Api - factory interface
 * @export
 */
export const BundleProductOptionRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove bundle option
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1DeleteByIdDelete(sku: string, optionId: number, options?: any) {
            return BundleProductOptionRepositoryV1ApiFp(configuration).bundleProductOptionRepositoryV1DeleteByIdDelete(sku, optionId, options)(fetch, basePath);
        },
        /**
         * Get option for bundle product
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1GetGet(sku: string, optionId: number, options?: any) {
            return BundleProductOptionRepositoryV1ApiFp(configuration).bundleProductOptionRepositoryV1GetGet(sku, optionId, options)(fetch, basePath);
        },
        /**
         * Get all options for bundle product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionRepositoryV1GetListGet(sku: string, options?: any) {
            return BundleProductOptionRepositoryV1ApiFp(configuration).bundleProductOptionRepositoryV1GetListGet(sku, options)(fetch, basePath);
        },
    };
};

/**
 * BundleProductOptionRepositoryV1Api - object-oriented interface
 * @export
 * @class BundleProductOptionRepositoryV1Api
 * @extends {BaseAPI}
 */
export class BundleProductOptionRepositoryV1Api extends BaseAPI {
    /**
     * Remove bundle option
     * @param {string} sku
     * @param {number} optionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductOptionRepositoryV1Api
     */
    public bundleProductOptionRepositoryV1DeleteByIdDelete(sku: string, optionId: number, options?: any) {
        return BundleProductOptionRepositoryV1ApiFp(this.configuration).bundleProductOptionRepositoryV1DeleteByIdDelete(sku, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get option for bundle product
     * @param {string} sku
     * @param {number} optionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductOptionRepositoryV1Api
     */
    public bundleProductOptionRepositoryV1GetGet(sku: string, optionId: number, options?: any) {
        return BundleProductOptionRepositoryV1ApiFp(this.configuration).bundleProductOptionRepositoryV1GetGet(sku, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all options for bundle product
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductOptionRepositoryV1Api
     */
    public bundleProductOptionRepositoryV1GetListGet(sku: string, options?: any) {
        return BundleProductOptionRepositoryV1ApiFp(this.configuration).bundleProductOptionRepositoryV1GetListGet(sku, options)(this.fetch, this.basePath);
    }

}

/**
 * BundleProductOptionTypeListV1Api - fetch parameter creator
 * @export
 */
export const BundleProductOptionTypeListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all types for options for bundle products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionTypeListV1GetItemsGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/bundle-products/options/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleProductOptionTypeListV1Api - functional programming interface
 * @export
 */
export const BundleProductOptionTypeListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all types for options for bundle products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionTypeListV1GetItemsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BundleDataOptionTypeInterface>> {
            const localVarFetchArgs = BundleProductOptionTypeListV1ApiFetchParamCreator(configuration).bundleProductOptionTypeListV1GetItemsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BundleProductOptionTypeListV1Api - factory interface
 * @export
 */
export const BundleProductOptionTypeListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all types for options for bundle products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleProductOptionTypeListV1GetItemsGet(options?: any) {
            return BundleProductOptionTypeListV1ApiFp(configuration).bundleProductOptionTypeListV1GetItemsGet(options)(fetch, basePath);
        },
    };
};

/**
 * BundleProductOptionTypeListV1Api - object-oriented interface
 * @export
 * @class BundleProductOptionTypeListV1Api
 * @extends {BaseAPI}
 */
export class BundleProductOptionTypeListV1Api extends BaseAPI {
    /**
     * Get all types for options for bundle products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleProductOptionTypeListV1Api
     */
    public bundleProductOptionTypeListV1GetItemsGet(options?: any) {
        return BundleProductOptionTypeListV1ApiFp(this.configuration).bundleProductOptionTypeListV1GetItemsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogAttributeSetManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogAttributeSetManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create attribute set from data
         * @param {CatalogAttributeSetManagementV1CreatePostBody} [catalogAttributeSetManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody?: CatalogAttributeSetManagementV1CreatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attribute-sets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogAttributeSetManagementV1CreatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogAttributeSetManagementV1CreatePostBody || {}) : (catalogAttributeSetManagementV1CreatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogAttributeSetManagementV1Api - functional programming interface
 * @export
 */
export const CatalogAttributeSetManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create attribute set from data
         * @param {CatalogAttributeSetManagementV1CreatePostBody} [catalogAttributeSetManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody?: CatalogAttributeSetManagementV1CreatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetInterface> {
            const localVarFetchArgs = CatalogAttributeSetManagementV1ApiFetchParamCreator(configuration).catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogAttributeSetManagementV1Api - factory interface
 * @export
 */
export const CatalogAttributeSetManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create attribute set from data
         * @param {CatalogAttributeSetManagementV1CreatePostBody} [catalogAttributeSetManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody?: CatalogAttributeSetManagementV1CreatePostBody, options?: any) {
            return CatalogAttributeSetManagementV1ApiFp(configuration).catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogAttributeSetManagementV1Api - object-oriented interface
 * @export
 * @class CatalogAttributeSetManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogAttributeSetManagementV1Api extends BaseAPI {
    /**
     * Create attribute set from data
     * @param {CatalogAttributeSetManagementV1CreatePostBody} [catalogAttributeSetManagementV1CreatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAttributeSetManagementV1Api
     */
    public catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody?: CatalogAttributeSetManagementV1CreatePostBody, options?: any) {
        return CatalogAttributeSetManagementV1ApiFp(this.configuration).catalogAttributeSetManagementV1CreatePost(catalogAttributeSetManagementV1CreatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogAttributeSetRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogAttributeSetRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove attribute set by given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling catalogAttributeSetRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/products/attribute-sets/{attributeSetId}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve attribute set information based on given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1GetGet(attributeSetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling catalogAttributeSetRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/products/attribute-sets/{attributeSetId}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of Attribute Sets
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attribute-sets/sets/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save attribute set data
         * @param {string} attributeSetId
         * @param {CatalogAttributeSetRepositoryV1SavePutBody} [catalogAttributeSetRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1SavePut(attributeSetId: string, catalogAttributeSetRepositoryV1SavePutBody?: CatalogAttributeSetRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling catalogAttributeSetRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/attribute-sets/{attributeSetId}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogAttributeSetRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogAttributeSetRepositoryV1SavePutBody || {}) : (catalogAttributeSetRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogAttributeSetRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogAttributeSetRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove attribute set by given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogAttributeSetRepositoryV1ApiFetchParamCreator(configuration).catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve attribute set information based on given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1GetGet(attributeSetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetInterface> {
            const localVarFetchArgs = CatalogAttributeSetRepositoryV1ApiFetchParamCreator(configuration).catalogAttributeSetRepositoryV1GetGet(attributeSetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve list of Attribute Sets
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetSearchResultsInterface> {
            const localVarFetchArgs = CatalogAttributeSetRepositoryV1ApiFetchParamCreator(configuration).catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save attribute set data
         * @param {string} attributeSetId
         * @param {CatalogAttributeSetRepositoryV1SavePutBody} [catalogAttributeSetRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1SavePut(attributeSetId: string, catalogAttributeSetRepositoryV1SavePutBody?: CatalogAttributeSetRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetInterface> {
            const localVarFetchArgs = CatalogAttributeSetRepositoryV1ApiFetchParamCreator(configuration).catalogAttributeSetRepositoryV1SavePut(attributeSetId, catalogAttributeSetRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogAttributeSetRepositoryV1Api - factory interface
 * @export
 */
export const CatalogAttributeSetRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove attribute set by given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options?: any) {
            return CatalogAttributeSetRepositoryV1ApiFp(configuration).catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId, options)(fetch, basePath);
        },
        /**
         * Retrieve attribute set information based on given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1GetGet(attributeSetId: number, options?: any) {
            return CatalogAttributeSetRepositoryV1ApiFp(configuration).catalogAttributeSetRepositoryV1GetGet(attributeSetId, options)(fetch, basePath);
        },
        /**
         * Retrieve list of Attribute Sets
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogAttributeSetRepositoryV1ApiFp(configuration).catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save attribute set data
         * @param {string} attributeSetId
         * @param {CatalogAttributeSetRepositoryV1SavePutBody} [catalogAttributeSetRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAttributeSetRepositoryV1SavePut(attributeSetId: string, catalogAttributeSetRepositoryV1SavePutBody?: CatalogAttributeSetRepositoryV1SavePutBody, options?: any) {
            return CatalogAttributeSetRepositoryV1ApiFp(configuration).catalogAttributeSetRepositoryV1SavePut(attributeSetId, catalogAttributeSetRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogAttributeSetRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogAttributeSetRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogAttributeSetRepositoryV1Api extends BaseAPI {
    /**
     * Remove attribute set by given ID
     * @param {number} attributeSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAttributeSetRepositoryV1Api
     */
    public catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options?: any) {
        return CatalogAttributeSetRepositoryV1ApiFp(this.configuration).catalogAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve attribute set information based on given ID
     * @param {number} attributeSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAttributeSetRepositoryV1Api
     */
    public catalogAttributeSetRepositoryV1GetGet(attributeSetId: number, options?: any) {
        return CatalogAttributeSetRepositoryV1ApiFp(this.configuration).catalogAttributeSetRepositoryV1GetGet(attributeSetId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve list of Attribute Sets
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAttributeSetRepositoryV1Api
     */
    public catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogAttributeSetRepositoryV1ApiFp(this.configuration).catalogAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save attribute set data
     * @param {string} attributeSetId
     * @param {CatalogAttributeSetRepositoryV1SavePutBody} [catalogAttributeSetRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAttributeSetRepositoryV1Api
     */
    public catalogAttributeSetRepositoryV1SavePut(attributeSetId: string, catalogAttributeSetRepositoryV1SavePutBody?: CatalogAttributeSetRepositoryV1SavePutBody, options?: any) {
        return CatalogAttributeSetRepositoryV1ApiFp(this.configuration).catalogAttributeSetRepositoryV1SavePut(attributeSetId, catalogAttributeSetRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogBasePriceStorageV1Api - fetch parameter creator
 * @export
 */
export const CatalogBasePriceStorageV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogBasePriceStorageV1GetPostBody} [catalogBasePriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody?: CatalogBasePriceStorageV1GetPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/base-prices-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogBasePriceStorageV1GetPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogBasePriceStorageV1GetPostBody || {}) : (catalogBasePriceStorageV1GetPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update product prices. Input item should correspond \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid price, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogBasePriceStorageV1UpdatePostBody} [catalogBasePriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody?: CatalogBasePriceStorageV1UpdatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/base-prices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogBasePriceStorageV1UpdatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogBasePriceStorageV1UpdatePostBody || {}) : (catalogBasePriceStorageV1UpdatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogBasePriceStorageV1Api - functional programming interface
 * @export
 */
export const CatalogBasePriceStorageV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogBasePriceStorageV1GetPostBody} [catalogBasePriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody?: CatalogBasePriceStorageV1GetPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataBasePriceInterface>> {
            const localVarFetchArgs = CatalogBasePriceStorageV1ApiFetchParamCreator(configuration).catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or update product prices. Input item should correspond \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid price, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogBasePriceStorageV1UpdatePostBody} [catalogBasePriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody?: CatalogBasePriceStorageV1UpdatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogBasePriceStorageV1ApiFetchParamCreator(configuration).catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogBasePriceStorageV1Api - factory interface
 * @export
 */
export const CatalogBasePriceStorageV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogBasePriceStorageV1GetPostBody} [catalogBasePriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody?: CatalogBasePriceStorageV1GetPostBody, options?: any) {
            return CatalogBasePriceStorageV1ApiFp(configuration).catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody, options)(fetch, basePath);
        },
        /**
         * Add or update product prices. Input item should correspond \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid price, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogBasePriceStorageV1UpdatePostBody} [catalogBasePriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody?: CatalogBasePriceStorageV1UpdatePostBody, options?: any) {
            return CatalogBasePriceStorageV1ApiFp(configuration).catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogBasePriceStorageV1Api - object-oriented interface
 * @export
 * @class CatalogBasePriceStorageV1Api
 * @extends {BaseAPI}
 */
export class CatalogBasePriceStorageV1Api extends BaseAPI {
    /**
     * Return product prices. In case of at least one of skus is not found exception will be thrown.
     * @param {CatalogBasePriceStorageV1GetPostBody} [catalogBasePriceStorageV1GetPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogBasePriceStorageV1Api
     */
    public catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody?: CatalogBasePriceStorageV1GetPostBody, options?: any) {
        return CatalogBasePriceStorageV1ApiFp(this.configuration).catalogBasePriceStorageV1GetPost(catalogBasePriceStorageV1GetPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add or update product prices. Input item should correspond \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid price, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
     * @param {CatalogBasePriceStorageV1UpdatePostBody} [catalogBasePriceStorageV1UpdatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogBasePriceStorageV1Api
     */
    public catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody?: CatalogBasePriceStorageV1UpdatePostBody, options?: any) {
        return CatalogBasePriceStorageV1ApiFp(this.configuration).catalogBasePriceStorageV1UpdatePost(catalogBasePriceStorageV1UpdatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryAttributeOptionManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryAttributeOptionManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve list of attribute options
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogCategoryAttributeOptionManagementV1GetItemsGet.');
            }
            const localVarPath = `/V1/categories/attributes/{attributeCode}/options`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryAttributeOptionManagementV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryAttributeOptionManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve list of attribute options
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EavDataAttributeOptionInterface>> {
            const localVarFetchArgs = CatalogCategoryAttributeOptionManagementV1ApiFetchParamCreator(configuration).catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryAttributeOptionManagementV1Api - factory interface
 * @export
 */
export const CatalogCategoryAttributeOptionManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve list of attribute options
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode: string, options?: any) {
            return CatalogCategoryAttributeOptionManagementV1ApiFp(configuration).catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryAttributeOptionManagementV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryAttributeOptionManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryAttributeOptionManagementV1Api extends BaseAPI {
    /**
     * Retrieve list of attribute options
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryAttributeOptionManagementV1Api
     */
    public catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode: string, options?: any) {
        return CatalogCategoryAttributeOptionManagementV1ApiFp(this.configuration).catalogCategoryAttributeOptionManagementV1GetItemsGet(attributeCode, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryAttributeRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryAttributeRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve specific attribute
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeRepositoryV1GetGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogCategoryAttributeRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/categories/attributes/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all attributes for entity type
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/categories/attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryAttributeRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryAttributeRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve specific attribute
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeRepositoryV1GetGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategoryAttributeInterface> {
            const localVarFetchArgs = CatalogCategoryAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryAttributeRepositoryV1GetGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all attributes for entity type
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategoryAttributeSearchResultsInterface> {
            const localVarFetchArgs = CatalogCategoryAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryAttributeRepositoryV1Api - factory interface
 * @export
 */
export const CatalogCategoryAttributeRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve specific attribute
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeRepositoryV1GetGet(attributeCode: string, options?: any) {
            return CatalogCategoryAttributeRepositoryV1ApiFp(configuration).catalogCategoryAttributeRepositoryV1GetGet(attributeCode, options)(fetch, basePath);
        },
        /**
         * Retrieve all attributes for entity type
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogCategoryAttributeRepositoryV1ApiFp(configuration).catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryAttributeRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryAttributeRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryAttributeRepositoryV1Api extends BaseAPI {
    /**
     * Retrieve specific attribute
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryAttributeRepositoryV1Api
     */
    public catalogCategoryAttributeRepositoryV1GetGet(attributeCode: string, options?: any) {
        return CatalogCategoryAttributeRepositoryV1ApiFp(this.configuration).catalogCategoryAttributeRepositoryV1GetGet(attributeCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all attributes for entity type
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryAttributeRepositoryV1Api
     */
    public catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogCategoryAttributeRepositoryV1ApiFp(this.configuration).catalogCategoryAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryLinkManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryLinkManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get products assigned to category
         * @param {number} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryLinkManagementV1GetAssignedProductsGet.');
            }
            const localVarPath = `/V1/categories/{categoryId}/products`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryLinkManagementV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryLinkManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get products assigned to category
         * @param {number} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataCategoryProductLinkInterface>> {
            const localVarFetchArgs = CatalogCategoryLinkManagementV1ApiFetchParamCreator(configuration).catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryLinkManagementV1Api - factory interface
 * @export
 */
export const CatalogCategoryLinkManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get products assigned to category
         * @param {number} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId: number, options?: any) {
            return CatalogCategoryLinkManagementV1ApiFp(configuration).catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryLinkManagementV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryLinkManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryLinkManagementV1Api extends BaseAPI {
    /**
     * Get products assigned to category
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryLinkManagementV1Api
     */
    public catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId: number, options?: any) {
        return CatalogCategoryLinkManagementV1ApiFp(this.configuration).catalogCategoryLinkManagementV1GetAssignedProductsGet(categoryId, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryLinkRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryLinkRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove the product assignment from the category by category id and sku
         * @param {string} categoryId
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId: string, sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryLinkRepositoryV1DeleteByIdsDelete.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogCategoryLinkRepositoryV1DeleteByIdsDelete.');
            }
            const localVarPath = `/V1/categories/{categoryId}/products/{sku}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a product to the required category
         * @param {string} categoryId
         * @param {CatalogCategoryLinkRepositoryV1SavePostBody} [catalogCategoryLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1SavePost(categoryId: string, catalogCategoryLinkRepositoryV1SavePostBody?: CatalogCategoryLinkRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryLinkRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/categories/{categoryId}/products`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCategoryLinkRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCategoryLinkRepositoryV1SavePostBody || {}) : (catalogCategoryLinkRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a product to the required category
         * @param {string} categoryId
         * @param {CatalogCategoryLinkRepositoryV1SavePutBody} [catalogCategoryLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1SavePut(categoryId: string, catalogCategoryLinkRepositoryV1SavePutBody?: CatalogCategoryLinkRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryLinkRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/categories/{categoryId}/products`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCategoryLinkRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCategoryLinkRepositoryV1SavePutBody || {}) : (catalogCategoryLinkRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryLinkRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryLinkRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove the product assignment from the category by category id and sku
         * @param {string} categoryId
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId: string, sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogCategoryLinkRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId, sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assign a product to the required category
         * @param {string} categoryId
         * @param {CatalogCategoryLinkRepositoryV1SavePostBody} [catalogCategoryLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1SavePost(categoryId: string, catalogCategoryLinkRepositoryV1SavePostBody?: CatalogCategoryLinkRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogCategoryLinkRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryLinkRepositoryV1SavePost(categoryId, catalogCategoryLinkRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assign a product to the required category
         * @param {string} categoryId
         * @param {CatalogCategoryLinkRepositoryV1SavePutBody} [catalogCategoryLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1SavePut(categoryId: string, catalogCategoryLinkRepositoryV1SavePutBody?: CatalogCategoryLinkRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogCategoryLinkRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryLinkRepositoryV1SavePut(categoryId, catalogCategoryLinkRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryLinkRepositoryV1Api - factory interface
 * @export
 */
export const CatalogCategoryLinkRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove the product assignment from the category by category id and sku
         * @param {string} categoryId
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId: string, sku: string, options?: any) {
            return CatalogCategoryLinkRepositoryV1ApiFp(configuration).catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId, sku, options)(fetch, basePath);
        },
        /**
         * Assign a product to the required category
         * @param {string} categoryId
         * @param {CatalogCategoryLinkRepositoryV1SavePostBody} [catalogCategoryLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1SavePost(categoryId: string, catalogCategoryLinkRepositoryV1SavePostBody?: CatalogCategoryLinkRepositoryV1SavePostBody, options?: any) {
            return CatalogCategoryLinkRepositoryV1ApiFp(configuration).catalogCategoryLinkRepositoryV1SavePost(categoryId, catalogCategoryLinkRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Assign a product to the required category
         * @param {string} categoryId
         * @param {CatalogCategoryLinkRepositoryV1SavePutBody} [catalogCategoryLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryLinkRepositoryV1SavePut(categoryId: string, catalogCategoryLinkRepositoryV1SavePutBody?: CatalogCategoryLinkRepositoryV1SavePutBody, options?: any) {
            return CatalogCategoryLinkRepositoryV1ApiFp(configuration).catalogCategoryLinkRepositoryV1SavePut(categoryId, catalogCategoryLinkRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryLinkRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryLinkRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryLinkRepositoryV1Api extends BaseAPI {
    /**
     * Remove the product assignment from the category by category id and sku
     * @param {string} categoryId
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryLinkRepositoryV1Api
     */
    public catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId: string, sku: string, options?: any) {
        return CatalogCategoryLinkRepositoryV1ApiFp(this.configuration).catalogCategoryLinkRepositoryV1DeleteByIdsDelete(categoryId, sku, options)(this.fetch, this.basePath);
    }

    /**
     * Assign a product to the required category
     * @param {string} categoryId
     * @param {CatalogCategoryLinkRepositoryV1SavePostBody} [catalogCategoryLinkRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryLinkRepositoryV1Api
     */
    public catalogCategoryLinkRepositoryV1SavePost(categoryId: string, catalogCategoryLinkRepositoryV1SavePostBody?: CatalogCategoryLinkRepositoryV1SavePostBody, options?: any) {
        return CatalogCategoryLinkRepositoryV1ApiFp(this.configuration).catalogCategoryLinkRepositoryV1SavePost(categoryId, catalogCategoryLinkRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Assign a product to the required category
     * @param {string} categoryId
     * @param {CatalogCategoryLinkRepositoryV1SavePutBody} [catalogCategoryLinkRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryLinkRepositoryV1Api
     */
    public catalogCategoryLinkRepositoryV1SavePut(categoryId: string, catalogCategoryLinkRepositoryV1SavePutBody?: CatalogCategoryLinkRepositoryV1SavePutBody, options?: any) {
        return CatalogCategoryLinkRepositoryV1ApiFp(this.configuration).catalogCategoryLinkRepositoryV1SavePut(categoryId, catalogCategoryLinkRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryListV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get category list
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/categories/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryListV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get category list
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategorySearchResultsInterface> {
            const localVarFetchArgs = CatalogCategoryListV1ApiFetchParamCreator(configuration).catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryListV1Api - factory interface
 * @export
 */
export const CatalogCategoryListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get category list
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogCategoryListV1ApiFp(configuration).catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryListV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryListV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryListV1Api extends BaseAPI {
    /**
     * Get category list
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryListV1Api
     */
    public catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogCategoryListV1ApiFp(this.configuration).catalogCategoryListV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve list of categories
         * @param {number} [rootCategoryId]
         * @param {number} [depth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryManagementV1GetTreeGet(rootCategoryId?: number, depth?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rootCategoryId !== undefined) {
                localVarQueryParameter['rootCategoryId'] = rootCategoryId;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move category
         * @param {number} categoryId
         * @param {CatalogCategoryManagementV1MovePutBody} [catalogCategoryManagementV1MovePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryManagementV1MovePut(categoryId: number, catalogCategoryManagementV1MovePutBody?: CatalogCategoryManagementV1MovePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryManagementV1MovePut.');
            }
            const localVarPath = `/V1/categories/{categoryId}/move`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCategoryManagementV1MovePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCategoryManagementV1MovePutBody || {}) : (catalogCategoryManagementV1MovePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryManagementV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve list of categories
         * @param {number} [rootCategoryId]
         * @param {number} [depth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryManagementV1GetTreeGet(rootCategoryId?: number, depth?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategoryTreeInterface> {
            const localVarFetchArgs = CatalogCategoryManagementV1ApiFetchParamCreator(configuration).catalogCategoryManagementV1GetTreeGet(rootCategoryId, depth, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Move category
         * @param {number} categoryId
         * @param {CatalogCategoryManagementV1MovePutBody} [catalogCategoryManagementV1MovePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryManagementV1MovePut(categoryId: number, catalogCategoryManagementV1MovePutBody?: CatalogCategoryManagementV1MovePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogCategoryManagementV1ApiFetchParamCreator(configuration).catalogCategoryManagementV1MovePut(categoryId, catalogCategoryManagementV1MovePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryManagementV1Api - factory interface
 * @export
 */
export const CatalogCategoryManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve list of categories
         * @param {number} [rootCategoryId]
         * @param {number} [depth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryManagementV1GetTreeGet(rootCategoryId?: number, depth?: number, options?: any) {
            return CatalogCategoryManagementV1ApiFp(configuration).catalogCategoryManagementV1GetTreeGet(rootCategoryId, depth, options)(fetch, basePath);
        },
        /**
         * Move category
         * @param {number} categoryId
         * @param {CatalogCategoryManagementV1MovePutBody} [catalogCategoryManagementV1MovePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryManagementV1MovePut(categoryId: number, catalogCategoryManagementV1MovePutBody?: CatalogCategoryManagementV1MovePutBody, options?: any) {
            return CatalogCategoryManagementV1ApiFp(configuration).catalogCategoryManagementV1MovePut(categoryId, catalogCategoryManagementV1MovePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryManagementV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryManagementV1Api extends BaseAPI {
    /**
     * Retrieve list of categories
     * @param {number} [rootCategoryId]
     * @param {number} [depth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryManagementV1Api
     */
    public catalogCategoryManagementV1GetTreeGet(rootCategoryId?: number, depth?: number, options?: any) {
        return CatalogCategoryManagementV1ApiFp(this.configuration).catalogCategoryManagementV1GetTreeGet(rootCategoryId, depth, options)(this.fetch, this.basePath);
    }

    /**
     * Move category
     * @param {number} categoryId
     * @param {CatalogCategoryManagementV1MovePutBody} [catalogCategoryManagementV1MovePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryManagementV1Api
     */
    public catalogCategoryManagementV1MovePut(categoryId: number, catalogCategoryManagementV1MovePutBody?: CatalogCategoryManagementV1MovePutBody, options?: any) {
        return CatalogCategoryManagementV1ApiFp(this.configuration).catalogCategoryManagementV1MovePut(categoryId, catalogCategoryManagementV1MovePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCategoryRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogCategoryRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete category by identifier
         * @param {number} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryRepositoryV1DeleteByIdentifierDelete.');
            }
            const localVarPath = `/V1/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get info about category by category id
         * @param {number} categoryId
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1GetGet(categoryId: number, storeId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling catalogCategoryRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create category service
         * @param {CatalogCategoryRepositoryV1SavePostBody} [catalogCategoryRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody?: CatalogCategoryRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCategoryRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCategoryRepositoryV1SavePostBody || {}) : (catalogCategoryRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create category service
         * @param {string} id
         * @param {CatalogCategoryRepositoryV1SavePutBody} [catalogCategoryRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1SavePut(id: string, catalogCategoryRepositoryV1SavePutBody?: CatalogCategoryRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling catalogCategoryRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCategoryRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCategoryRepositoryV1SavePutBody || {}) : (catalogCategoryRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCategoryRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogCategoryRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete category by identifier
         * @param {number} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogCategoryRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get info about category by category id
         * @param {number} categoryId
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1GetGet(categoryId: number, storeId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategoryInterface> {
            const localVarFetchArgs = CatalogCategoryRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryRepositoryV1GetGet(categoryId, storeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create category service
         * @param {CatalogCategoryRepositoryV1SavePostBody} [catalogCategoryRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody?: CatalogCategoryRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategoryInterface> {
            const localVarFetchArgs = CatalogCategoryRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create category service
         * @param {string} id
         * @param {CatalogCategoryRepositoryV1SavePutBody} [catalogCategoryRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1SavePut(id: string, catalogCategoryRepositoryV1SavePutBody?: CatalogCategoryRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataCategoryInterface> {
            const localVarFetchArgs = CatalogCategoryRepositoryV1ApiFetchParamCreator(configuration).catalogCategoryRepositoryV1SavePut(id, catalogCategoryRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCategoryRepositoryV1Api - factory interface
 * @export
 */
export const CatalogCategoryRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete category by identifier
         * @param {number} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId: number, options?: any) {
            return CatalogCategoryRepositoryV1ApiFp(configuration).catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId, options)(fetch, basePath);
        },
        /**
         * Get info about category by category id
         * @param {number} categoryId
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1GetGet(categoryId: number, storeId?: number, options?: any) {
            return CatalogCategoryRepositoryV1ApiFp(configuration).catalogCategoryRepositoryV1GetGet(categoryId, storeId, options)(fetch, basePath);
        },
        /**
         * Create category service
         * @param {CatalogCategoryRepositoryV1SavePostBody} [catalogCategoryRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody?: CatalogCategoryRepositoryV1SavePostBody, options?: any) {
            return CatalogCategoryRepositoryV1ApiFp(configuration).catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create category service
         * @param {string} id
         * @param {CatalogCategoryRepositoryV1SavePutBody} [catalogCategoryRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCategoryRepositoryV1SavePut(id: string, catalogCategoryRepositoryV1SavePutBody?: CatalogCategoryRepositoryV1SavePutBody, options?: any) {
            return CatalogCategoryRepositoryV1ApiFp(configuration).catalogCategoryRepositoryV1SavePut(id, catalogCategoryRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCategoryRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogCategoryRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogCategoryRepositoryV1Api extends BaseAPI {
    /**
     * Delete category by identifier
     * @param {number} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryRepositoryV1Api
     */
    public catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId: number, options?: any) {
        return CatalogCategoryRepositoryV1ApiFp(this.configuration).catalogCategoryRepositoryV1DeleteByIdentifierDelete(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * Get info about category by category id
     * @param {number} categoryId
     * @param {number} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryRepositoryV1Api
     */
    public catalogCategoryRepositoryV1GetGet(categoryId: number, storeId?: number, options?: any) {
        return CatalogCategoryRepositoryV1ApiFp(this.configuration).catalogCategoryRepositoryV1GetGet(categoryId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Create category service
     * @param {CatalogCategoryRepositoryV1SavePostBody} [catalogCategoryRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryRepositoryV1Api
     */
    public catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody?: CatalogCategoryRepositoryV1SavePostBody, options?: any) {
        return CatalogCategoryRepositoryV1ApiFp(this.configuration).catalogCategoryRepositoryV1SavePost(catalogCategoryRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create category service
     * @param {string} id
     * @param {CatalogCategoryRepositoryV1SavePutBody} [catalogCategoryRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCategoryRepositoryV1Api
     */
    public catalogCategoryRepositoryV1SavePut(id: string, catalogCategoryRepositoryV1SavePutBody?: CatalogCategoryRepositoryV1SavePutBody, options?: any) {
        return CatalogCategoryRepositoryV1ApiFp(this.configuration).catalogCategoryRepositoryV1SavePut(id, catalogCategoryRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogCostStorageV1Api - fetch parameter creator
 * @export
 */
export const CatalogCostStorageV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete product cost. In case of at least one of skus is not found exception will be thrown. If error occurred during the delete exception will be thrown.
         * @param {CatalogCostStorageV1DeletePostBody} [catalogCostStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody?: CatalogCostStorageV1DeletePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/cost-delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCostStorageV1DeletePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCostStorageV1DeletePostBody || {}) : (catalogCostStorageV1DeletePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogCostStorageV1GetPostBody} [catalogCostStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody?: CatalogCostStorageV1GetPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/cost-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCostStorageV1GetPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCostStorageV1GetPostBody || {}) : (catalogCostStorageV1GetPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update product cost. Input item should correspond to \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid cost, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogCostStorageV1UpdatePostBody} [catalogCostStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody?: CatalogCostStorageV1UpdatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/cost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogCostStorageV1UpdatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogCostStorageV1UpdatePostBody || {}) : (catalogCostStorageV1UpdatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogCostStorageV1Api - functional programming interface
 * @export
 */
export const CatalogCostStorageV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete product cost. In case of at least one of skus is not found exception will be thrown. If error occurred during the delete exception will be thrown.
         * @param {CatalogCostStorageV1DeletePostBody} [catalogCostStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody?: CatalogCostStorageV1DeletePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogCostStorageV1ApiFetchParamCreator(configuration).catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogCostStorageV1GetPostBody} [catalogCostStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody?: CatalogCostStorageV1GetPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataCostInterface>> {
            const localVarFetchArgs = CatalogCostStorageV1ApiFetchParamCreator(configuration).catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or update product cost. Input item should correspond to \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid cost, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogCostStorageV1UpdatePostBody} [catalogCostStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody?: CatalogCostStorageV1UpdatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogCostStorageV1ApiFetchParamCreator(configuration).catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogCostStorageV1Api - factory interface
 * @export
 */
export const CatalogCostStorageV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete product cost. In case of at least one of skus is not found exception will be thrown. If error occurred during the delete exception will be thrown.
         * @param {CatalogCostStorageV1DeletePostBody} [catalogCostStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody?: CatalogCostStorageV1DeletePostBody, options?: any) {
            return CatalogCostStorageV1ApiFp(configuration).catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody, options)(fetch, basePath);
        },
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogCostStorageV1GetPostBody} [catalogCostStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody?: CatalogCostStorageV1GetPostBody, options?: any) {
            return CatalogCostStorageV1ApiFp(configuration).catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody, options)(fetch, basePath);
        },
        /**
         * Add or update product cost. Input item should correspond to \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid cost, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogCostStorageV1UpdatePostBody} [catalogCostStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody?: CatalogCostStorageV1UpdatePostBody, options?: any) {
            return CatalogCostStorageV1ApiFp(configuration).catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogCostStorageV1Api - object-oriented interface
 * @export
 * @class CatalogCostStorageV1Api
 * @extends {BaseAPI}
 */
export class CatalogCostStorageV1Api extends BaseAPI {
    /**
     * Delete product cost. In case of at least one of skus is not found exception will be thrown. If error occurred during the delete exception will be thrown.
     * @param {CatalogCostStorageV1DeletePostBody} [catalogCostStorageV1DeletePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCostStorageV1Api
     */
    public catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody?: CatalogCostStorageV1DeletePostBody, options?: any) {
        return CatalogCostStorageV1ApiFp(this.configuration).catalogCostStorageV1DeletePost(catalogCostStorageV1DeletePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return product prices. In case of at least one of skus is not found exception will be thrown.
     * @param {CatalogCostStorageV1GetPostBody} [catalogCostStorageV1GetPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCostStorageV1Api
     */
    public catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody?: CatalogCostStorageV1GetPostBody, options?: any) {
        return CatalogCostStorageV1ApiFp(this.configuration).catalogCostStorageV1GetPost(catalogCostStorageV1GetPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add or update product cost. Input item should correspond to \\Magento\\Catalog\\Api\\Data\\CostInterface. If any items will have invalid cost, store id or sku, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
     * @param {CatalogCostStorageV1UpdatePostBody} [catalogCostStorageV1UpdatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogCostStorageV1Api
     */
    public catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody?: CatalogCostStorageV1UpdatePostBody, options?: any) {
        return CatalogCostStorageV1ApiFp(this.configuration).catalogCostStorageV1UpdatePost(catalogCostStorageV1UpdatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogInventoryStockRegistryV1Api - fetch parameter creator
 * @export
 */
export const CatalogInventoryStockRegistryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of SKU's with low inventory qty
         * @param {number} scopeId
         * @param {number} qty
         * @param {number} [currentPage]
         * @param {number} [pageSize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId: number, qty: number, currentPage?: number, pageSize?: number, options: any = {}): FetchArgs {
            // verify required parameter 'scopeId' is not null or undefined
            if (scopeId === null || scopeId === undefined) {
                throw new RequiredError('scopeId','Required parameter scopeId was null or undefined when calling catalogInventoryStockRegistryV1GetLowStockItemsGet.');
            }
            // verify required parameter 'qty' is not null or undefined
            if (qty === null || qty === undefined) {
                throw new RequiredError('qty','Required parameter qty was null or undefined when calling catalogInventoryStockRegistryV1GetLowStockItemsGet.');
            }
            const localVarPath = `/V1/stockItems/lowStock/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (scopeId !== undefined) {
                localVarQueryParameter['scopeId'] = scopeId;
            }

            if (qty !== undefined) {
                localVarQueryParameter['qty'] = qty;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} productSku
         * @param {number} [scopeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku: string, scopeId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling catalogInventoryStockRegistryV1GetStockItemBySkuGet.');
            }
            const localVarPath = `/V1/stockItems/{productSku}`
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (scopeId !== undefined) {
                localVarQueryParameter['scopeId'] = scopeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} productSku
         * @param {number} [scopeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku: string, scopeId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling catalogInventoryStockRegistryV1GetStockStatusBySkuGet.');
            }
            const localVarPath = `/V1/stockStatuses/{productSku}`
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (scopeId !== undefined) {
                localVarQueryParameter['scopeId'] = scopeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} productSku
         * @param {string} itemId
         * @param {CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody} [catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku: string, itemId: string, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody?: CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'productSku' is not null or undefined
            if (productSku === null || productSku === undefined) {
                throw new RequiredError('productSku','Required parameter productSku was null or undefined when calling catalogInventoryStockRegistryV1UpdateStockItemBySkuPut.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling catalogInventoryStockRegistryV1UpdateStockItemBySkuPut.');
            }
            const localVarPath = `/V1/products/{productSku}/stockItems/{itemId}`
                .replace(`{${"productSku"}}`, encodeURIComponent(String(productSku)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody || {}) : (catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogInventoryStockRegistryV1Api - functional programming interface
 * @export
 */
export const CatalogInventoryStockRegistryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of SKU's with low inventory qty
         * @param {number} scopeId
         * @param {number} qty
         * @param {number} [currentPage]
         * @param {number} [pageSize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId: number, qty: number, currentPage?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogInventoryDataStockStatusCollectionInterface> {
            const localVarFetchArgs = CatalogInventoryStockRegistryV1ApiFetchParamCreator(configuration).catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId, qty, currentPage, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} productSku
         * @param {number} [scopeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku: string, scopeId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogInventoryDataStockItemInterface> {
            const localVarFetchArgs = CatalogInventoryStockRegistryV1ApiFetchParamCreator(configuration).catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku, scopeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} productSku
         * @param {number} [scopeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku: string, scopeId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogInventoryDataStockStatusInterface> {
            const localVarFetchArgs = CatalogInventoryStockRegistryV1ApiFetchParamCreator(configuration).catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku, scopeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} productSku
         * @param {string} itemId
         * @param {CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody} [catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku: string, itemId: string, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody?: CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CatalogInventoryStockRegistryV1ApiFetchParamCreator(configuration).catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku, itemId, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogInventoryStockRegistryV1Api - factory interface
 * @export
 */
export const CatalogInventoryStockRegistryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves a list of SKU's with low inventory qty
         * @param {number} scopeId
         * @param {number} qty
         * @param {number} [currentPage]
         * @param {number} [pageSize]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId: number, qty: number, currentPage?: number, pageSize?: number, options?: any) {
            return CatalogInventoryStockRegistryV1ApiFp(configuration).catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId, qty, currentPage, pageSize, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} productSku
         * @param {number} [scopeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku: string, scopeId?: number, options?: any) {
            return CatalogInventoryStockRegistryV1ApiFp(configuration).catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku, scopeId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} productSku
         * @param {number} [scopeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku: string, scopeId?: number, options?: any) {
            return CatalogInventoryStockRegistryV1ApiFp(configuration).catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku, scopeId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} productSku
         * @param {string} itemId
         * @param {CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody} [catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku: string, itemId: string, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody?: CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options?: any) {
            return CatalogInventoryStockRegistryV1ApiFp(configuration).catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku, itemId, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogInventoryStockRegistryV1Api - object-oriented interface
 * @export
 * @class CatalogInventoryStockRegistryV1Api
 * @extends {BaseAPI}
 */
export class CatalogInventoryStockRegistryV1Api extends BaseAPI {
    /**
     * Retrieves a list of SKU's with low inventory qty
     * @param {number} scopeId
     * @param {number} qty
     * @param {number} [currentPage]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogInventoryStockRegistryV1Api
     */
    public catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId: number, qty: number, currentPage?: number, pageSize?: number, options?: any) {
        return CatalogInventoryStockRegistryV1ApiFp(this.configuration).catalogInventoryStockRegistryV1GetLowStockItemsGet(scopeId, qty, currentPage, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} productSku
     * @param {number} [scopeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogInventoryStockRegistryV1Api
     */
    public catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku: string, scopeId?: number, options?: any) {
        return CatalogInventoryStockRegistryV1ApiFp(this.configuration).catalogInventoryStockRegistryV1GetStockItemBySkuGet(productSku, scopeId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} productSku
     * @param {number} [scopeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogInventoryStockRegistryV1Api
     */
    public catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku: string, scopeId?: number, options?: any) {
        return CatalogInventoryStockRegistryV1ApiFp(this.configuration).catalogInventoryStockRegistryV1GetStockStatusBySkuGet(productSku, scopeId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} productSku
     * @param {string} itemId
     * @param {CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody} [catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogInventoryStockRegistryV1Api
     */
    public catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku: string, itemId: string, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody?: CatalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options?: any) {
        return CatalogInventoryStockRegistryV1ApiFp(this.configuration).catalogInventoryStockRegistryV1UpdateStockItemBySkuPut(productSku, itemId, catalogInventoryStockRegistryV1UpdateStockItemBySkuPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductAttributeGroupRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductAttributeGroupRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove attribute group by id
         * @param {number} groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling catalogProductAttributeGroupRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/products/attribute-sets/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of attribute groups
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attribute-sets/groups/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save attribute group
         * @param {CatalogProductAttributeGroupRepositoryV1SavePostBody} [catalogProductAttributeGroupRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody?: CatalogProductAttributeGroupRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attribute-sets/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeGroupRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeGroupRepositoryV1SavePostBody || {}) : (catalogProductAttributeGroupRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save attribute group
         * @param {string} attributeSetId
         * @param {CatalogProductAttributeGroupRepositoryV1SavePutBody} [catalogProductAttributeGroupRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId: string, catalogProductAttributeGroupRepositoryV1SavePutBody?: CatalogProductAttributeGroupRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling catalogProductAttributeGroupRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/attribute-sets/{attributeSetId}/groups`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeGroupRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeGroupRepositoryV1SavePutBody || {}) : (catalogProductAttributeGroupRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductAttributeGroupRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogProductAttributeGroupRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove attribute group by id
         * @param {number} groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeGroupRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve list of attribute groups
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeGroupSearchResultsInterface> {
            const localVarFetchArgs = CatalogProductAttributeGroupRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save attribute group
         * @param {CatalogProductAttributeGroupRepositoryV1SavePostBody} [catalogProductAttributeGroupRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody?: CatalogProductAttributeGroupRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeGroupInterface> {
            const localVarFetchArgs = CatalogProductAttributeGroupRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save attribute group
         * @param {string} attributeSetId
         * @param {CatalogProductAttributeGroupRepositoryV1SavePutBody} [catalogProductAttributeGroupRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId: string, catalogProductAttributeGroupRepositoryV1SavePutBody?: CatalogProductAttributeGroupRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeGroupInterface> {
            const localVarFetchArgs = CatalogProductAttributeGroupRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId, catalogProductAttributeGroupRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductAttributeGroupRepositoryV1Api - factory interface
 * @export
 */
export const CatalogProductAttributeGroupRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove attribute group by id
         * @param {number} groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId: number, options?: any) {
            return CatalogProductAttributeGroupRepositoryV1ApiFp(configuration).catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId, options)(fetch, basePath);
        },
        /**
         * Retrieve list of attribute groups
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogProductAttributeGroupRepositoryV1ApiFp(configuration).catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save attribute group
         * @param {CatalogProductAttributeGroupRepositoryV1SavePostBody} [catalogProductAttributeGroupRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody?: CatalogProductAttributeGroupRepositoryV1SavePostBody, options?: any) {
            return CatalogProductAttributeGroupRepositoryV1ApiFp(configuration).catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save attribute group
         * @param {string} attributeSetId
         * @param {CatalogProductAttributeGroupRepositoryV1SavePutBody} [catalogProductAttributeGroupRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId: string, catalogProductAttributeGroupRepositoryV1SavePutBody?: CatalogProductAttributeGroupRepositoryV1SavePutBody, options?: any) {
            return CatalogProductAttributeGroupRepositoryV1ApiFp(configuration).catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId, catalogProductAttributeGroupRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductAttributeGroupRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogProductAttributeGroupRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductAttributeGroupRepositoryV1Api extends BaseAPI {
    /**
     * Remove attribute group by id
     * @param {number} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeGroupRepositoryV1Api
     */
    public catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId: number, options?: any) {
        return CatalogProductAttributeGroupRepositoryV1ApiFp(this.configuration).catalogProductAttributeGroupRepositoryV1DeleteByIdDelete(groupId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve list of attribute groups
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeGroupRepositoryV1Api
     */
    public catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogProductAttributeGroupRepositoryV1ApiFp(this.configuration).catalogProductAttributeGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save attribute group
     * @param {CatalogProductAttributeGroupRepositoryV1SavePostBody} [catalogProductAttributeGroupRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeGroupRepositoryV1Api
     */
    public catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody?: CatalogProductAttributeGroupRepositoryV1SavePostBody, options?: any) {
        return CatalogProductAttributeGroupRepositoryV1ApiFp(this.configuration).catalogProductAttributeGroupRepositoryV1SavePost(catalogProductAttributeGroupRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save attribute group
     * @param {string} attributeSetId
     * @param {CatalogProductAttributeGroupRepositoryV1SavePutBody} [catalogProductAttributeGroupRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeGroupRepositoryV1Api
     */
    public catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId: string, catalogProductAttributeGroupRepositoryV1SavePutBody?: CatalogProductAttributeGroupRepositoryV1SavePutBody, options?: any) {
        return CatalogProductAttributeGroupRepositoryV1ApiFp(this.configuration).catalogProductAttributeGroupRepositoryV1SavePut(attributeSetId, catalogProductAttributeGroupRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductAttributeManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductAttributeManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign attribute to attribute set
         * @param {CatalogProductAttributeManagementV1AssignPostBody} [catalogProductAttributeManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody?: CatalogProductAttributeManagementV1AssignPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attribute-sets/attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeManagementV1AssignPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeManagementV1AssignPostBody || {}) : (catalogProductAttributeManagementV1AssignPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve related attributes based on given attribute set ID
         * @param {string} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1GetAttributesGet(attributeSetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling catalogProductAttributeManagementV1GetAttributesGet.');
            }
            const localVarPath = `/V1/products/attribute-sets/{attributeSetId}/attributes`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove attribute from attribute set
         * @param {string} attributeSetId
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1UnassignDelete(attributeSetId: string, attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling catalogProductAttributeManagementV1UnassignDelete.');
            }
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeManagementV1UnassignDelete.');
            }
            const localVarPath = `/V1/products/attribute-sets/{attributeSetId}/attributes/{attributeCode}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)))
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductAttributeManagementV1Api - functional programming interface
 * @export
 */
export const CatalogProductAttributeManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assign attribute to attribute set
         * @param {CatalogProductAttributeManagementV1AssignPostBody} [catalogProductAttributeManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody?: CatalogProductAttributeManagementV1AssignPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CatalogProductAttributeManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve related attributes based on given attribute set ID
         * @param {string} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1GetAttributesGet(attributeSetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductAttributeInterface>> {
            const localVarFetchArgs = CatalogProductAttributeManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeManagementV1GetAttributesGet(attributeSetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove attribute from attribute set
         * @param {string} attributeSetId
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1UnassignDelete(attributeSetId: string, attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeManagementV1UnassignDelete(attributeSetId, attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductAttributeManagementV1Api - factory interface
 * @export
 */
export const CatalogProductAttributeManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assign attribute to attribute set
         * @param {CatalogProductAttributeManagementV1AssignPostBody} [catalogProductAttributeManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody?: CatalogProductAttributeManagementV1AssignPostBody, options?: any) {
            return CatalogProductAttributeManagementV1ApiFp(configuration).catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody, options)(fetch, basePath);
        },
        /**
         * Retrieve related attributes based on given attribute set ID
         * @param {string} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1GetAttributesGet(attributeSetId: string, options?: any) {
            return CatalogProductAttributeManagementV1ApiFp(configuration).catalogProductAttributeManagementV1GetAttributesGet(attributeSetId, options)(fetch, basePath);
        },
        /**
         * Remove attribute from attribute set
         * @param {string} attributeSetId
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeManagementV1UnassignDelete(attributeSetId: string, attributeCode: string, options?: any) {
            return CatalogProductAttributeManagementV1ApiFp(configuration).catalogProductAttributeManagementV1UnassignDelete(attributeSetId, attributeCode, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductAttributeManagementV1Api - object-oriented interface
 * @export
 * @class CatalogProductAttributeManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductAttributeManagementV1Api extends BaseAPI {
    /**
     * Assign attribute to attribute set
     * @param {CatalogProductAttributeManagementV1AssignPostBody} [catalogProductAttributeManagementV1AssignPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeManagementV1Api
     */
    public catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody?: CatalogProductAttributeManagementV1AssignPostBody, options?: any) {
        return CatalogProductAttributeManagementV1ApiFp(this.configuration).catalogProductAttributeManagementV1AssignPost(catalogProductAttributeManagementV1AssignPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve related attributes based on given attribute set ID
     * @param {string} attributeSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeManagementV1Api
     */
    public catalogProductAttributeManagementV1GetAttributesGet(attributeSetId: string, options?: any) {
        return CatalogProductAttributeManagementV1ApiFp(this.configuration).catalogProductAttributeManagementV1GetAttributesGet(attributeSetId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove attribute from attribute set
     * @param {string} attributeSetId
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeManagementV1Api
     */
    public catalogProductAttributeManagementV1UnassignDelete(attributeSetId: string, attributeCode: string, options?: any) {
        return CatalogProductAttributeManagementV1ApiFp(this.configuration).catalogProductAttributeManagementV1UnassignDelete(attributeSetId, attributeCode, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductAttributeMediaGalleryManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductAttributeMediaGalleryManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new gallery entry
         * @param {string} sku
         * @param {CatalogProductAttributeMediaGalleryManagementV1CreatePostBody} [catalogProductAttributeMediaGalleryManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1CreatePost(sku: string, catalogProductAttributeMediaGalleryManagementV1CreatePostBody?: CatalogProductAttributeMediaGalleryManagementV1CreatePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1CreatePost.');
            }
            const localVarPath = `/V1/products/{sku}/media`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeMediaGalleryManagementV1CreatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeMediaGalleryManagementV1CreatePostBody || {}) : (catalogProductAttributeMediaGalleryManagementV1CreatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about gallery entry
         * @param {string} sku
         * @param {number} entryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1GetGet(sku: string, entryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1GetGet.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1GetGet.');
            }
            const localVarPath = `/V1/products/{sku}/media/{entryId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of gallery entries associated with given product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1GetListGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1GetListGet.');
            }
            const localVarPath = `/V1/products/{sku}/media`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove gallery entry
         * @param {string} sku
         * @param {number} entryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku: string, entryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1RemoveDelete.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1RemoveDelete.');
            }
            const localVarPath = `/V1/products/{sku}/media/{entryId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update gallery entry
         * @param {string} sku
         * @param {string} entryId
         * @param {CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody} [catalogProductAttributeMediaGalleryManagementV1UpdatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku: string, entryId: string, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody?: CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1UpdatePut.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling catalogProductAttributeMediaGalleryManagementV1UpdatePut.');
            }
            const localVarPath = `/V1/products/{sku}/media/{entryId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeMediaGalleryManagementV1UpdatePutBody || {}) : (catalogProductAttributeMediaGalleryManagementV1UpdatePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductAttributeMediaGalleryManagementV1Api - functional programming interface
 * @export
 */
export const CatalogProductAttributeMediaGalleryManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new gallery entry
         * @param {string} sku
         * @param {CatalogProductAttributeMediaGalleryManagementV1CreatePostBody} [catalogProductAttributeMediaGalleryManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1CreatePost(sku: string, catalogProductAttributeMediaGalleryManagementV1CreatePostBody?: CatalogProductAttributeMediaGalleryManagementV1CreatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CatalogProductAttributeMediaGalleryManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeMediaGalleryManagementV1CreatePost(sku, catalogProductAttributeMediaGalleryManagementV1CreatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return information about gallery entry
         * @param {string} sku
         * @param {number} entryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1GetGet(sku: string, entryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductAttributeMediaGalleryEntryInterface> {
            const localVarFetchArgs = CatalogProductAttributeMediaGalleryManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeMediaGalleryManagementV1GetGet(sku, entryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the list of gallery entries associated with given product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1GetListGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductAttributeMediaGalleryEntryInterface>> {
            const localVarFetchArgs = CatalogProductAttributeMediaGalleryManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeMediaGalleryManagementV1GetListGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove gallery entry
         * @param {string} sku
         * @param {number} entryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku: string, entryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeMediaGalleryManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku, entryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update gallery entry
         * @param {string} sku
         * @param {string} entryId
         * @param {CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody} [catalogProductAttributeMediaGalleryManagementV1UpdatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku: string, entryId: string, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody?: CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeMediaGalleryManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku, entryId, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductAttributeMediaGalleryManagementV1Api - factory interface
 * @export
 */
export const CatalogProductAttributeMediaGalleryManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new gallery entry
         * @param {string} sku
         * @param {CatalogProductAttributeMediaGalleryManagementV1CreatePostBody} [catalogProductAttributeMediaGalleryManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1CreatePost(sku: string, catalogProductAttributeMediaGalleryManagementV1CreatePostBody?: CatalogProductAttributeMediaGalleryManagementV1CreatePostBody, options?: any) {
            return CatalogProductAttributeMediaGalleryManagementV1ApiFp(configuration).catalogProductAttributeMediaGalleryManagementV1CreatePost(sku, catalogProductAttributeMediaGalleryManagementV1CreatePostBody, options)(fetch, basePath);
        },
        /**
         * Return information about gallery entry
         * @param {string} sku
         * @param {number} entryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1GetGet(sku: string, entryId: number, options?: any) {
            return CatalogProductAttributeMediaGalleryManagementV1ApiFp(configuration).catalogProductAttributeMediaGalleryManagementV1GetGet(sku, entryId, options)(fetch, basePath);
        },
        /**
         * Retrieve the list of gallery entries associated with given product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1GetListGet(sku: string, options?: any) {
            return CatalogProductAttributeMediaGalleryManagementV1ApiFp(configuration).catalogProductAttributeMediaGalleryManagementV1GetListGet(sku, options)(fetch, basePath);
        },
        /**
         * Remove gallery entry
         * @param {string} sku
         * @param {number} entryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku: string, entryId: number, options?: any) {
            return CatalogProductAttributeMediaGalleryManagementV1ApiFp(configuration).catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku, entryId, options)(fetch, basePath);
        },
        /**
         * Update gallery entry
         * @param {string} sku
         * @param {string} entryId
         * @param {CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody} [catalogProductAttributeMediaGalleryManagementV1UpdatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku: string, entryId: string, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody?: CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options?: any) {
            return CatalogProductAttributeMediaGalleryManagementV1ApiFp(configuration).catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku, entryId, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductAttributeMediaGalleryManagementV1Api - object-oriented interface
 * @export
 * @class CatalogProductAttributeMediaGalleryManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductAttributeMediaGalleryManagementV1Api extends BaseAPI {
    /**
     * Create new gallery entry
     * @param {string} sku
     * @param {CatalogProductAttributeMediaGalleryManagementV1CreatePostBody} [catalogProductAttributeMediaGalleryManagementV1CreatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1Api
     */
    public catalogProductAttributeMediaGalleryManagementV1CreatePost(sku: string, catalogProductAttributeMediaGalleryManagementV1CreatePostBody?: CatalogProductAttributeMediaGalleryManagementV1CreatePostBody, options?: any) {
        return CatalogProductAttributeMediaGalleryManagementV1ApiFp(this.configuration).catalogProductAttributeMediaGalleryManagementV1CreatePost(sku, catalogProductAttributeMediaGalleryManagementV1CreatePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return information about gallery entry
     * @param {string} sku
     * @param {number} entryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1Api
     */
    public catalogProductAttributeMediaGalleryManagementV1GetGet(sku: string, entryId: number, options?: any) {
        return CatalogProductAttributeMediaGalleryManagementV1ApiFp(this.configuration).catalogProductAttributeMediaGalleryManagementV1GetGet(sku, entryId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the list of gallery entries associated with given product
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1Api
     */
    public catalogProductAttributeMediaGalleryManagementV1GetListGet(sku: string, options?: any) {
        return CatalogProductAttributeMediaGalleryManagementV1ApiFp(this.configuration).catalogProductAttributeMediaGalleryManagementV1GetListGet(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Remove gallery entry
     * @param {string} sku
     * @param {number} entryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1Api
     */
    public catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku: string, entryId: number, options?: any) {
        return CatalogProductAttributeMediaGalleryManagementV1ApiFp(this.configuration).catalogProductAttributeMediaGalleryManagementV1RemoveDelete(sku, entryId, options)(this.fetch, this.basePath);
    }

    /**
     * Update gallery entry
     * @param {string} sku
     * @param {string} entryId
     * @param {CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody} [catalogProductAttributeMediaGalleryManagementV1UpdatePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeMediaGalleryManagementV1Api
     */
    public catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku: string, entryId: string, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody?: CatalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options?: any) {
        return CatalogProductAttributeMediaGalleryManagementV1ApiFp(this.configuration).catalogProductAttributeMediaGalleryManagementV1UpdatePut(sku, entryId, catalogProductAttributeMediaGalleryManagementV1UpdatePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductAttributeOptionManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductAttributeOptionManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add option to attribute
         * @param {string} attributeCode
         * @param {CatalogProductAttributeOptionManagementV1AddPostBody} [catalogProductAttributeOptionManagementV1AddPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1AddPost(attributeCode: string, catalogProductAttributeOptionManagementV1AddPostBody?: CatalogProductAttributeOptionManagementV1AddPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeOptionManagementV1AddPost.');
            }
            const localVarPath = `/V1/products/attributes/{attributeCode}/options`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeOptionManagementV1AddPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeOptionManagementV1AddPostBody || {}) : (catalogProductAttributeOptionManagementV1AddPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete option from attribute
         * @param {string} attributeCode
         * @param {string} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode: string, optionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeOptionManagementV1DeleteDelete.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling catalogProductAttributeOptionManagementV1DeleteDelete.');
            }
            const localVarPath = `/V1/products/attributes/{attributeCode}/options/{optionId}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of attribute options
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeOptionManagementV1GetItemsGet.');
            }
            const localVarPath = `/V1/products/attributes/{attributeCode}/options`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductAttributeOptionManagementV1Api - functional programming interface
 * @export
 */
export const CatalogProductAttributeOptionManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add option to attribute
         * @param {string} attributeCode
         * @param {CatalogProductAttributeOptionManagementV1AddPostBody} [catalogProductAttributeOptionManagementV1AddPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1AddPost(attributeCode: string, catalogProductAttributeOptionManagementV1AddPostBody?: CatalogProductAttributeOptionManagementV1AddPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeOptionManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeOptionManagementV1AddPost(attributeCode, catalogProductAttributeOptionManagementV1AddPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete option from attribute
         * @param {string} attributeCode
         * @param {string} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode: string, optionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeOptionManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve list of attribute options
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EavDataAttributeOptionInterface>> {
            const localVarFetchArgs = CatalogProductAttributeOptionManagementV1ApiFetchParamCreator(configuration).catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductAttributeOptionManagementV1Api - factory interface
 * @export
 */
export const CatalogProductAttributeOptionManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add option to attribute
         * @param {string} attributeCode
         * @param {CatalogProductAttributeOptionManagementV1AddPostBody} [catalogProductAttributeOptionManagementV1AddPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1AddPost(attributeCode: string, catalogProductAttributeOptionManagementV1AddPostBody?: CatalogProductAttributeOptionManagementV1AddPostBody, options?: any) {
            return CatalogProductAttributeOptionManagementV1ApiFp(configuration).catalogProductAttributeOptionManagementV1AddPost(attributeCode, catalogProductAttributeOptionManagementV1AddPostBody, options)(fetch, basePath);
        },
        /**
         * Delete option from attribute
         * @param {string} attributeCode
         * @param {string} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode: string, optionId: string, options?: any) {
            return CatalogProductAttributeOptionManagementV1ApiFp(configuration).catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode, optionId, options)(fetch, basePath);
        },
        /**
         * Retrieve list of attribute options
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode: string, options?: any) {
            return CatalogProductAttributeOptionManagementV1ApiFp(configuration).catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductAttributeOptionManagementV1Api - object-oriented interface
 * @export
 * @class CatalogProductAttributeOptionManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductAttributeOptionManagementV1Api extends BaseAPI {
    /**
     * Add option to attribute
     * @param {string} attributeCode
     * @param {CatalogProductAttributeOptionManagementV1AddPostBody} [catalogProductAttributeOptionManagementV1AddPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeOptionManagementV1Api
     */
    public catalogProductAttributeOptionManagementV1AddPost(attributeCode: string, catalogProductAttributeOptionManagementV1AddPostBody?: CatalogProductAttributeOptionManagementV1AddPostBody, options?: any) {
        return CatalogProductAttributeOptionManagementV1ApiFp(this.configuration).catalogProductAttributeOptionManagementV1AddPost(attributeCode, catalogProductAttributeOptionManagementV1AddPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Delete option from attribute
     * @param {string} attributeCode
     * @param {string} optionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeOptionManagementV1Api
     */
    public catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode: string, optionId: string, options?: any) {
        return CatalogProductAttributeOptionManagementV1ApiFp(this.configuration).catalogProductAttributeOptionManagementV1DeleteDelete(attributeCode, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve list of attribute options
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeOptionManagementV1Api
     */
    public catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode: string, options?: any) {
        return CatalogProductAttributeOptionManagementV1ApiFp(this.configuration).catalogProductAttributeOptionManagementV1GetItemsGet(attributeCode, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductAttributeRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductAttributeRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete Attribute by id
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/products/attributes/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve specific attribute
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1GetGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/products/attributes/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all attributes for entity type
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save attribute data
         * @param {CatalogProductAttributeRepositoryV1SavePostBody} [catalogProductAttributeRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody?: CatalogProductAttributeRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeRepositoryV1SavePostBody || {}) : (catalogProductAttributeRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save attribute data
         * @param {string} attributeCode
         * @param {CatalogProductAttributeRepositoryV1SavePutBody} [catalogProductAttributeRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1SavePut(attributeCode: string, catalogProductAttributeRepositoryV1SavePutBody?: CatalogProductAttributeRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling catalogProductAttributeRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/attributes/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductAttributeRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductAttributeRepositoryV1SavePutBody || {}) : (catalogProductAttributeRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductAttributeRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogProductAttributeRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete Attribute by id
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve specific attribute
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1GetGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductAttributeInterface> {
            const localVarFetchArgs = CatalogProductAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeRepositoryV1GetGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all attributes for entity type
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductAttributeSearchResultsInterface> {
            const localVarFetchArgs = CatalogProductAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save attribute data
         * @param {CatalogProductAttributeRepositoryV1SavePostBody} [catalogProductAttributeRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody?: CatalogProductAttributeRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductAttributeInterface> {
            const localVarFetchArgs = CatalogProductAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save attribute data
         * @param {string} attributeCode
         * @param {CatalogProductAttributeRepositoryV1SavePutBody} [catalogProductAttributeRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1SavePut(attributeCode: string, catalogProductAttributeRepositoryV1SavePutBody?: CatalogProductAttributeRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductAttributeInterface> {
            const localVarFetchArgs = CatalogProductAttributeRepositoryV1ApiFetchParamCreator(configuration).catalogProductAttributeRepositoryV1SavePut(attributeCode, catalogProductAttributeRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductAttributeRepositoryV1Api - factory interface
 * @export
 */
export const CatalogProductAttributeRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete Attribute by id
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode: string, options?: any) {
            return CatalogProductAttributeRepositoryV1ApiFp(configuration).catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode, options)(fetch, basePath);
        },
        /**
         * Retrieve specific attribute
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1GetGet(attributeCode: string, options?: any) {
            return CatalogProductAttributeRepositoryV1ApiFp(configuration).catalogProductAttributeRepositoryV1GetGet(attributeCode, options)(fetch, basePath);
        },
        /**
         * Retrieve all attributes for entity type
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogProductAttributeRepositoryV1ApiFp(configuration).catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save attribute data
         * @param {CatalogProductAttributeRepositoryV1SavePostBody} [catalogProductAttributeRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody?: CatalogProductAttributeRepositoryV1SavePostBody, options?: any) {
            return CatalogProductAttributeRepositoryV1ApiFp(configuration).catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save attribute data
         * @param {string} attributeCode
         * @param {CatalogProductAttributeRepositoryV1SavePutBody} [catalogProductAttributeRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeRepositoryV1SavePut(attributeCode: string, catalogProductAttributeRepositoryV1SavePutBody?: CatalogProductAttributeRepositoryV1SavePutBody, options?: any) {
            return CatalogProductAttributeRepositoryV1ApiFp(configuration).catalogProductAttributeRepositoryV1SavePut(attributeCode, catalogProductAttributeRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductAttributeRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogProductAttributeRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductAttributeRepositoryV1Api extends BaseAPI {
    /**
     * Delete Attribute by id
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeRepositoryV1Api
     */
    public catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode: string, options?: any) {
        return CatalogProductAttributeRepositoryV1ApiFp(this.configuration).catalogProductAttributeRepositoryV1DeleteByIdDelete(attributeCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve specific attribute
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeRepositoryV1Api
     */
    public catalogProductAttributeRepositoryV1GetGet(attributeCode: string, options?: any) {
        return CatalogProductAttributeRepositoryV1ApiFp(this.configuration).catalogProductAttributeRepositoryV1GetGet(attributeCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all attributes for entity type
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeRepositoryV1Api
     */
    public catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogProductAttributeRepositoryV1ApiFp(this.configuration).catalogProductAttributeRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save attribute data
     * @param {CatalogProductAttributeRepositoryV1SavePostBody} [catalogProductAttributeRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeRepositoryV1Api
     */
    public catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody?: CatalogProductAttributeRepositoryV1SavePostBody, options?: any) {
        return CatalogProductAttributeRepositoryV1ApiFp(this.configuration).catalogProductAttributeRepositoryV1SavePost(catalogProductAttributeRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save attribute data
     * @param {string} attributeCode
     * @param {CatalogProductAttributeRepositoryV1SavePutBody} [catalogProductAttributeRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeRepositoryV1Api
     */
    public catalogProductAttributeRepositoryV1SavePut(attributeCode: string, catalogProductAttributeRepositoryV1SavePutBody?: CatalogProductAttributeRepositoryV1SavePutBody, options?: any) {
        return CatalogProductAttributeRepositoryV1ApiFp(this.configuration).catalogProductAttributeRepositoryV1SavePut(attributeCode, catalogProductAttributeRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductAttributeTypesListV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductAttributeTypesListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve list of product attribute types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeTypesListV1GetItemsGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/attributes/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductAttributeTypesListV1Api - functional programming interface
 * @export
 */
export const CatalogProductAttributeTypesListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve list of product attribute types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeTypesListV1GetItemsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductAttributeTypeInterface>> {
            const localVarFetchArgs = CatalogProductAttributeTypesListV1ApiFetchParamCreator(configuration).catalogProductAttributeTypesListV1GetItemsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductAttributeTypesListV1Api - factory interface
 * @export
 */
export const CatalogProductAttributeTypesListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve list of product attribute types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductAttributeTypesListV1GetItemsGet(options?: any) {
            return CatalogProductAttributeTypesListV1ApiFp(configuration).catalogProductAttributeTypesListV1GetItemsGet(options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductAttributeTypesListV1Api - object-oriented interface
 * @export
 * @class CatalogProductAttributeTypesListV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductAttributeTypesListV1Api extends BaseAPI {
    /**
     * Retrieve list of product attribute types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductAttributeTypesListV1Api
     */
    public catalogProductAttributeTypesListV1GetItemsGet(options?: any) {
        return CatalogProductAttributeTypesListV1ApiFp(this.configuration).catalogProductAttributeTypesListV1GetItemsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductCustomOptionRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductCustomOptionRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku: string, optionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete.');
            }
            const localVarPath = `/V1/products/{sku}/options/{optionId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom option for a specific product
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1GetGet(sku: string, optionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductCustomOptionRepositoryV1GetGet.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling catalogProductCustomOptionRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/products/{sku}/options/{optionId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of custom options for a specific product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1GetListGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductCustomOptionRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/products/{sku}/options`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save Custom Option
         * @param {CatalogProductCustomOptionRepositoryV1SavePostBody} [catalogProductCustomOptionRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody?: CatalogProductCustomOptionRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/options`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductCustomOptionRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductCustomOptionRepositoryV1SavePostBody || {}) : (catalogProductCustomOptionRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save Custom Option
         * @param {string} optionId
         * @param {CatalogProductCustomOptionRepositoryV1SavePutBody} [catalogProductCustomOptionRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1SavePut(optionId: string, catalogProductCustomOptionRepositoryV1SavePutBody?: CatalogProductCustomOptionRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling catalogProductCustomOptionRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/options/{optionId}`
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductCustomOptionRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductCustomOptionRepositoryV1SavePutBody || {}) : (catalogProductCustomOptionRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductCustomOptionRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogProductCustomOptionRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku: string, optionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductCustomOptionRepositoryV1ApiFetchParamCreator(configuration).catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get custom option for a specific product
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1GetGet(sku: string, optionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductCustomOptionInterface> {
            const localVarFetchArgs = CatalogProductCustomOptionRepositoryV1ApiFetchParamCreator(configuration).catalogProductCustomOptionRepositoryV1GetGet(sku, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the list of custom options for a specific product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1GetListGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductCustomOptionInterface>> {
            const localVarFetchArgs = CatalogProductCustomOptionRepositoryV1ApiFetchParamCreator(configuration).catalogProductCustomOptionRepositoryV1GetListGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save Custom Option
         * @param {CatalogProductCustomOptionRepositoryV1SavePostBody} [catalogProductCustomOptionRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody?: CatalogProductCustomOptionRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductCustomOptionInterface> {
            const localVarFetchArgs = CatalogProductCustomOptionRepositoryV1ApiFetchParamCreator(configuration).catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save Custom Option
         * @param {string} optionId
         * @param {CatalogProductCustomOptionRepositoryV1SavePutBody} [catalogProductCustomOptionRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1SavePut(optionId: string, catalogProductCustomOptionRepositoryV1SavePutBody?: CatalogProductCustomOptionRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductCustomOptionInterface> {
            const localVarFetchArgs = CatalogProductCustomOptionRepositoryV1ApiFetchParamCreator(configuration).catalogProductCustomOptionRepositoryV1SavePut(optionId, catalogProductCustomOptionRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductCustomOptionRepositoryV1Api - factory interface
 * @export
 */
export const CatalogProductCustomOptionRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku: string, optionId: number, options?: any) {
            return CatalogProductCustomOptionRepositoryV1ApiFp(configuration).catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku, optionId, options)(fetch, basePath);
        },
        /**
         * Get custom option for a specific product
         * @param {string} sku
         * @param {number} optionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1GetGet(sku: string, optionId: number, options?: any) {
            return CatalogProductCustomOptionRepositoryV1ApiFp(configuration).catalogProductCustomOptionRepositoryV1GetGet(sku, optionId, options)(fetch, basePath);
        },
        /**
         * Get the list of custom options for a specific product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1GetListGet(sku: string, options?: any) {
            return CatalogProductCustomOptionRepositoryV1ApiFp(configuration).catalogProductCustomOptionRepositoryV1GetListGet(sku, options)(fetch, basePath);
        },
        /**
         * Save Custom Option
         * @param {CatalogProductCustomOptionRepositoryV1SavePostBody} [catalogProductCustomOptionRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody?: CatalogProductCustomOptionRepositoryV1SavePostBody, options?: any) {
            return CatalogProductCustomOptionRepositoryV1ApiFp(configuration).catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save Custom Option
         * @param {string} optionId
         * @param {CatalogProductCustomOptionRepositoryV1SavePutBody} [catalogProductCustomOptionRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionRepositoryV1SavePut(optionId: string, catalogProductCustomOptionRepositoryV1SavePutBody?: CatalogProductCustomOptionRepositoryV1SavePutBody, options?: any) {
            return CatalogProductCustomOptionRepositoryV1ApiFp(configuration).catalogProductCustomOptionRepositoryV1SavePut(optionId, catalogProductCustomOptionRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductCustomOptionRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogProductCustomOptionRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductCustomOptionRepositoryV1Api extends BaseAPI {
    /**
     *
     * @param {string} sku
     * @param {number} optionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductCustomOptionRepositoryV1Api
     */
    public catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku: string, optionId: number, options?: any) {
        return CatalogProductCustomOptionRepositoryV1ApiFp(this.configuration).catalogProductCustomOptionRepositoryV1DeleteByIdentifierDelete(sku, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get custom option for a specific product
     * @param {string} sku
     * @param {number} optionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductCustomOptionRepositoryV1Api
     */
    public catalogProductCustomOptionRepositoryV1GetGet(sku: string, optionId: number, options?: any) {
        return CatalogProductCustomOptionRepositoryV1ApiFp(this.configuration).catalogProductCustomOptionRepositoryV1GetGet(sku, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get the list of custom options for a specific product
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductCustomOptionRepositoryV1Api
     */
    public catalogProductCustomOptionRepositoryV1GetListGet(sku: string, options?: any) {
        return CatalogProductCustomOptionRepositoryV1ApiFp(this.configuration).catalogProductCustomOptionRepositoryV1GetListGet(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Save Custom Option
     * @param {CatalogProductCustomOptionRepositoryV1SavePostBody} [catalogProductCustomOptionRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductCustomOptionRepositoryV1Api
     */
    public catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody?: CatalogProductCustomOptionRepositoryV1SavePostBody, options?: any) {
        return CatalogProductCustomOptionRepositoryV1ApiFp(this.configuration).catalogProductCustomOptionRepositoryV1SavePost(catalogProductCustomOptionRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save Custom Option
     * @param {string} optionId
     * @param {CatalogProductCustomOptionRepositoryV1SavePutBody} [catalogProductCustomOptionRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductCustomOptionRepositoryV1Api
     */
    public catalogProductCustomOptionRepositoryV1SavePut(optionId: string, catalogProductCustomOptionRepositoryV1SavePutBody?: CatalogProductCustomOptionRepositoryV1SavePutBody, options?: any) {
        return CatalogProductCustomOptionRepositoryV1ApiFp(this.configuration).catalogProductCustomOptionRepositoryV1SavePut(optionId, catalogProductCustomOptionRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductCustomOptionTypeListV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductCustomOptionTypeListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get custom option types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionTypeListV1GetItemsGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/options/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductCustomOptionTypeListV1Api - functional programming interface
 * @export
 */
export const CatalogProductCustomOptionTypeListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get custom option types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionTypeListV1GetItemsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductCustomOptionTypeInterface>> {
            const localVarFetchArgs = CatalogProductCustomOptionTypeListV1ApiFetchParamCreator(configuration).catalogProductCustomOptionTypeListV1GetItemsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductCustomOptionTypeListV1Api - factory interface
 * @export
 */
export const CatalogProductCustomOptionTypeListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get custom option types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductCustomOptionTypeListV1GetItemsGet(options?: any) {
            return CatalogProductCustomOptionTypeListV1ApiFp(configuration).catalogProductCustomOptionTypeListV1GetItemsGet(options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductCustomOptionTypeListV1Api - object-oriented interface
 * @export
 * @class CatalogProductCustomOptionTypeListV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductCustomOptionTypeListV1Api extends BaseAPI {
    /**
     * Get custom option types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductCustomOptionTypeListV1Api
     */
    public catalogProductCustomOptionTypeListV1GetItemsGet(options?: any) {
        return CatalogProductCustomOptionTypeListV1ApiFp(this.configuration).catalogProductCustomOptionTypeListV1GetItemsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductLinkManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductLinkManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide the list of links for a specific product
         * @param {string} sku
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku: string, type: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductLinkManagementV1GetLinkedItemsByTypeGet.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling catalogProductLinkManagementV1GetLinkedItemsByTypeGet.');
            }
            const localVarPath = `/V1/products/{sku}/links/{type}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a product link to another product
         * @param {string} sku
         * @param {CatalogProductLinkManagementV1SetProductLinksPostBody} [catalogProductLinkManagementV1SetProductLinksPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkManagementV1SetProductLinksPost(sku: string, catalogProductLinkManagementV1SetProductLinksPostBody?: CatalogProductLinkManagementV1SetProductLinksPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductLinkManagementV1SetProductLinksPost.');
            }
            const localVarPath = `/V1/products/{sku}/links`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductLinkManagementV1SetProductLinksPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductLinkManagementV1SetProductLinksPostBody || {}) : (catalogProductLinkManagementV1SetProductLinksPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductLinkManagementV1Api - functional programming interface
 * @export
 */
export const CatalogProductLinkManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provide the list of links for a specific product
         * @param {string} sku
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku: string, type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductLinkInterface>> {
            const localVarFetchArgs = CatalogProductLinkManagementV1ApiFetchParamCreator(configuration).catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assign a product link to another product
         * @param {string} sku
         * @param {CatalogProductLinkManagementV1SetProductLinksPostBody} [catalogProductLinkManagementV1SetProductLinksPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkManagementV1SetProductLinksPost(sku: string, catalogProductLinkManagementV1SetProductLinksPostBody?: CatalogProductLinkManagementV1SetProductLinksPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductLinkManagementV1ApiFetchParamCreator(configuration).catalogProductLinkManagementV1SetProductLinksPost(sku, catalogProductLinkManagementV1SetProductLinksPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductLinkManagementV1Api - factory interface
 * @export
 */
export const CatalogProductLinkManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provide the list of links for a specific product
         * @param {string} sku
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku: string, type: string, options?: any) {
            return CatalogProductLinkManagementV1ApiFp(configuration).catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku, type, options)(fetch, basePath);
        },
        /**
         * Assign a product link to another product
         * @param {string} sku
         * @param {CatalogProductLinkManagementV1SetProductLinksPostBody} [catalogProductLinkManagementV1SetProductLinksPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkManagementV1SetProductLinksPost(sku: string, catalogProductLinkManagementV1SetProductLinksPostBody?: CatalogProductLinkManagementV1SetProductLinksPostBody, options?: any) {
            return CatalogProductLinkManagementV1ApiFp(configuration).catalogProductLinkManagementV1SetProductLinksPost(sku, catalogProductLinkManagementV1SetProductLinksPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductLinkManagementV1Api - object-oriented interface
 * @export
 * @class CatalogProductLinkManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductLinkManagementV1Api extends BaseAPI {
    /**
     * Provide the list of links for a specific product
     * @param {string} sku
     * @param {string} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductLinkManagementV1Api
     */
    public catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku: string, type: string, options?: any) {
        return CatalogProductLinkManagementV1ApiFp(this.configuration).catalogProductLinkManagementV1GetLinkedItemsByTypeGet(sku, type, options)(this.fetch, this.basePath);
    }

    /**
     * Assign a product link to another product
     * @param {string} sku
     * @param {CatalogProductLinkManagementV1SetProductLinksPostBody} [catalogProductLinkManagementV1SetProductLinksPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductLinkManagementV1Api
     */
    public catalogProductLinkManagementV1SetProductLinksPost(sku: string, catalogProductLinkManagementV1SetProductLinksPostBody?: CatalogProductLinkManagementV1SetProductLinksPostBody, options?: any) {
        return CatalogProductLinkManagementV1ApiFp(this.configuration).catalogProductLinkManagementV1SetProductLinksPost(sku, catalogProductLinkManagementV1SetProductLinksPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductLinkRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductLinkRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {string} type
         * @param {string} linkedProductSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkRepositoryV1DeleteByIdDelete(sku: string, type: string, linkedProductSku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductLinkRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling catalogProductLinkRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'linkedProductSku' is not null or undefined
            if (linkedProductSku === null || linkedProductSku === undefined) {
                throw new RequiredError('linkedProductSku','Required parameter linkedProductSku was null or undefined when calling catalogProductLinkRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/products/{sku}/links/{type}/{linkedProductSku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"linkedProductSku"}}`, encodeURIComponent(String(linkedProductSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save product link
         * @param {string} sku
         * @param {CatalogProductLinkRepositoryV1SavePutBody} [catalogProductLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkRepositoryV1SavePut(sku: string, catalogProductLinkRepositoryV1SavePutBody?: CatalogProductLinkRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductLinkRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/{sku}/links`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductLinkRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductLinkRepositoryV1SavePutBody || {}) : (catalogProductLinkRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductLinkRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogProductLinkRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {string} type
         * @param {string} linkedProductSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkRepositoryV1DeleteByIdDelete(sku: string, type: string, linkedProductSku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductLinkRepositoryV1ApiFetchParamCreator(configuration).catalogProductLinkRepositoryV1DeleteByIdDelete(sku, type, linkedProductSku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save product link
         * @param {string} sku
         * @param {CatalogProductLinkRepositoryV1SavePutBody} [catalogProductLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkRepositoryV1SavePut(sku: string, catalogProductLinkRepositoryV1SavePutBody?: CatalogProductLinkRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductLinkRepositoryV1ApiFetchParamCreator(configuration).catalogProductLinkRepositoryV1SavePut(sku, catalogProductLinkRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductLinkRepositoryV1Api - factory interface
 * @export
 */
export const CatalogProductLinkRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} sku
         * @param {string} type
         * @param {string} linkedProductSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkRepositoryV1DeleteByIdDelete(sku: string, type: string, linkedProductSku: string, options?: any) {
            return CatalogProductLinkRepositoryV1ApiFp(configuration).catalogProductLinkRepositoryV1DeleteByIdDelete(sku, type, linkedProductSku, options)(fetch, basePath);
        },
        /**
         * Save product link
         * @param {string} sku
         * @param {CatalogProductLinkRepositoryV1SavePutBody} [catalogProductLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkRepositoryV1SavePut(sku: string, catalogProductLinkRepositoryV1SavePutBody?: CatalogProductLinkRepositoryV1SavePutBody, options?: any) {
            return CatalogProductLinkRepositoryV1ApiFp(configuration).catalogProductLinkRepositoryV1SavePut(sku, catalogProductLinkRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductLinkRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogProductLinkRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductLinkRepositoryV1Api extends BaseAPI {
    /**
     *
     * @param {string} sku
     * @param {string} type
     * @param {string} linkedProductSku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductLinkRepositoryV1Api
     */
    public catalogProductLinkRepositoryV1DeleteByIdDelete(sku: string, type: string, linkedProductSku: string, options?: any) {
        return CatalogProductLinkRepositoryV1ApiFp(this.configuration).catalogProductLinkRepositoryV1DeleteByIdDelete(sku, type, linkedProductSku, options)(this.fetch, this.basePath);
    }

    /**
     * Save product link
     * @param {string} sku
     * @param {CatalogProductLinkRepositoryV1SavePutBody} [catalogProductLinkRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductLinkRepositoryV1Api
     */
    public catalogProductLinkRepositoryV1SavePut(sku: string, catalogProductLinkRepositoryV1SavePutBody?: CatalogProductLinkRepositoryV1SavePutBody, options?: any) {
        return CatalogProductLinkRepositoryV1ApiFp(this.configuration).catalogProductLinkRepositoryV1SavePut(sku, catalogProductLinkRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductLinkTypeListV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductLinkTypeListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide a list of the product link type attributes
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkTypeListV1GetItemAttributesGet(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling catalogProductLinkTypeListV1GetItemAttributesGet.');
            }
            const localVarPath = `/V1/products/links/{type}/attributes`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about available product link types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkTypeListV1GetItemsGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/links/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductLinkTypeListV1Api - functional programming interface
 * @export
 */
export const CatalogProductLinkTypeListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provide a list of the product link type attributes
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkTypeListV1GetItemAttributesGet(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductLinkAttributeInterface>> {
            const localVarFetchArgs = CatalogProductLinkTypeListV1ApiFetchParamCreator(configuration).catalogProductLinkTypeListV1GetItemAttributesGet(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve information about available product link types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkTypeListV1GetItemsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductLinkTypeInterface>> {
            const localVarFetchArgs = CatalogProductLinkTypeListV1ApiFetchParamCreator(configuration).catalogProductLinkTypeListV1GetItemsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductLinkTypeListV1Api - factory interface
 * @export
 */
export const CatalogProductLinkTypeListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Provide a list of the product link type attributes
         * @param {string} type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkTypeListV1GetItemAttributesGet(type: string, options?: any) {
            return CatalogProductLinkTypeListV1ApiFp(configuration).catalogProductLinkTypeListV1GetItemAttributesGet(type, options)(fetch, basePath);
        },
        /**
         * Retrieve information about available product link types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductLinkTypeListV1GetItemsGet(options?: any) {
            return CatalogProductLinkTypeListV1ApiFp(configuration).catalogProductLinkTypeListV1GetItemsGet(options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductLinkTypeListV1Api - object-oriented interface
 * @export
 * @class CatalogProductLinkTypeListV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductLinkTypeListV1Api extends BaseAPI {
    /**
     * Provide a list of the product link type attributes
     * @param {string} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductLinkTypeListV1Api
     */
    public catalogProductLinkTypeListV1GetItemAttributesGet(type: string, options?: any) {
        return CatalogProductLinkTypeListV1ApiFp(this.configuration).catalogProductLinkTypeListV1GetItemAttributesGet(type, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve information about available product link types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductLinkTypeListV1Api
     */
    public catalogProductLinkTypeListV1GetItemsGet(options?: any) {
        return CatalogProductLinkTypeListV1ApiFp(this.configuration).catalogProductLinkTypeListV1GetItemsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductMediaAttributeManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductMediaAttributeManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the list of media attributes (fronted input type is media_image) assigned to the given attribute set.
         * @param {string} attributeSetName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductMediaAttributeManagementV1GetListGet(attributeSetName: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetName' is not null or undefined
            if (attributeSetName === null || attributeSetName === undefined) {
                throw new RequiredError('attributeSetName','Required parameter attributeSetName was null or undefined when calling catalogProductMediaAttributeManagementV1GetListGet.');
            }
            const localVarPath = `/V1/products/media/types/{attributeSetName}`
                .replace(`{${"attributeSetName"}}`, encodeURIComponent(String(attributeSetName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductMediaAttributeManagementV1Api - functional programming interface
 * @export
 */
export const CatalogProductMediaAttributeManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve the list of media attributes (fronted input type is media_image) assigned to the given attribute set.
         * @param {string} attributeSetName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductMediaAttributeManagementV1GetListGet(attributeSetName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductAttributeInterface>> {
            const localVarFetchArgs = CatalogProductMediaAttributeManagementV1ApiFetchParamCreator(configuration).catalogProductMediaAttributeManagementV1GetListGet(attributeSetName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductMediaAttributeManagementV1Api - factory interface
 * @export
 */
export const CatalogProductMediaAttributeManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve the list of media attributes (fronted input type is media_image) assigned to the given attribute set.
         * @param {string} attributeSetName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductMediaAttributeManagementV1GetListGet(attributeSetName: string, options?: any) {
            return CatalogProductMediaAttributeManagementV1ApiFp(configuration).catalogProductMediaAttributeManagementV1GetListGet(attributeSetName, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductMediaAttributeManagementV1Api - object-oriented interface
 * @export
 * @class CatalogProductMediaAttributeManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductMediaAttributeManagementV1Api extends BaseAPI {
    /**
     * Retrieve the list of media attributes (fronted input type is media_image) assigned to the given attribute set.
     * @param {string} attributeSetName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductMediaAttributeManagementV1Api
     */
    public catalogProductMediaAttributeManagementV1GetListGet(attributeSetName: string, options?: any) {
        return CatalogProductMediaAttributeManagementV1ApiFp(this.configuration).catalogProductMediaAttributeManagementV1GetListGet(attributeSetName, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductRenderListV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductRenderListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Collect and retrieve the list of product render info This info contains raw prices and formated prices, product name, stock status, store_id, etc
         * @param {number} storeId
         * @param {string} currencyCode
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRenderListV1GetListGet(storeId: number, currencyCode: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId','Required parameter storeId was null or undefined when calling catalogProductRenderListV1GetListGet.');
            }
            // verify required parameter 'currencyCode' is not null or undefined
            if (currencyCode === null || currencyCode === undefined) {
                throw new RequiredError('currencyCode','Required parameter currencyCode was null or undefined when calling catalogProductRenderListV1GetListGet.');
            }
            const localVarPath = `/V1/products-render-info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (currencyCode !== undefined) {
                localVarQueryParameter['currencyCode'] = currencyCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductRenderListV1Api - functional programming interface
 * @export
 */
export const CatalogProductRenderListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Collect and retrieve the list of product render info This info contains raw prices and formated prices, product name, stock status, store_id, etc
         * @param {number} storeId
         * @param {string} currencyCode
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRenderListV1GetListGet(storeId: number, currencyCode: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductRenderSearchResultsInterface> {
            const localVarFetchArgs = CatalogProductRenderListV1ApiFetchParamCreator(configuration).catalogProductRenderListV1GetListGet(storeId, currencyCode, searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductRenderListV1Api - factory interface
 * @export
 */
export const CatalogProductRenderListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Collect and retrieve the list of product render info This info contains raw prices and formated prices, product name, stock status, store_id, etc
         * @param {number} storeId
         * @param {string} currencyCode
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRenderListV1GetListGet(storeId: number, currencyCode: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogProductRenderListV1ApiFp(configuration).catalogProductRenderListV1GetListGet(storeId, currencyCode, searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductRenderListV1Api - object-oriented interface
 * @export
 * @class CatalogProductRenderListV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductRenderListV1Api extends BaseAPI {
    /**
     * Collect and retrieve the list of product render info This info contains raw prices and formated prices, product name, stock status, store_id, etc
     * @param {number} storeId
     * @param {string} currencyCode
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductRenderListV1Api
     */
    public catalogProductRenderListV1GetListGet(storeId: number, currencyCode: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogProductRenderListV1ApiFp(this.configuration).catalogProductRenderListV1GetListGet(storeId, currencyCode, searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1DeleteByIdDelete(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/products/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get info about product by product SKU
         * @param {string} sku
         * @param {boolean} [editMode]
         * @param {number} [storeId]
         * @param {boolean} [forceReload]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1GetGet(sku: string, editMode?: boolean, storeId?: number, forceReload?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/products/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (editMode !== undefined) {
                localVarQueryParameter['editMode'] = editMode;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (forceReload !== undefined) {
                localVarQueryParameter['forceReload'] = forceReload;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product list
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create product
         * @param {CatalogProductRepositoryV1SavePostBody} [catalogProductRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody?: CatalogProductRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductRepositoryV1SavePostBody || {}) : (catalogProductRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create product
         * @param {string} sku
         * @param {CatalogProductRepositoryV1SavePutBody} [catalogProductRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1SavePut(sku: string, catalogProductRepositoryV1SavePutBody?: CatalogProductRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductRepositoryV1SavePutBody || {}) : (catalogProductRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogProductRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1DeleteByIdDelete(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductRepositoryV1ApiFetchParamCreator(configuration).catalogProductRepositoryV1DeleteByIdDelete(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get info about product by product SKU
         * @param {string} sku
         * @param {boolean} [editMode]
         * @param {number} [storeId]
         * @param {boolean} [forceReload]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1GetGet(sku: string, editMode?: boolean, storeId?: number, forceReload?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductInterface> {
            const localVarFetchArgs = CatalogProductRepositoryV1ApiFetchParamCreator(configuration).catalogProductRepositoryV1GetGet(sku, editMode, storeId, forceReload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get product list
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductSearchResultsInterface> {
            const localVarFetchArgs = CatalogProductRepositoryV1ApiFetchParamCreator(configuration).catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create product
         * @param {CatalogProductRepositoryV1SavePostBody} [catalogProductRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody?: CatalogProductRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductInterface> {
            const localVarFetchArgs = CatalogProductRepositoryV1ApiFetchParamCreator(configuration).catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create product
         * @param {string} sku
         * @param {CatalogProductRepositoryV1SavePutBody} [catalogProductRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1SavePut(sku: string, catalogProductRepositoryV1SavePutBody?: CatalogProductRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogDataProductInterface> {
            const localVarFetchArgs = CatalogProductRepositoryV1ApiFetchParamCreator(configuration).catalogProductRepositoryV1SavePut(sku, catalogProductRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductRepositoryV1Api - factory interface
 * @export
 */
export const CatalogProductRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1DeleteByIdDelete(sku: string, options?: any) {
            return CatalogProductRepositoryV1ApiFp(configuration).catalogProductRepositoryV1DeleteByIdDelete(sku, options)(fetch, basePath);
        },
        /**
         * Get info about product by product SKU
         * @param {string} sku
         * @param {boolean} [editMode]
         * @param {number} [storeId]
         * @param {boolean} [forceReload]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1GetGet(sku: string, editMode?: boolean, storeId?: number, forceReload?: boolean, options?: any) {
            return CatalogProductRepositoryV1ApiFp(configuration).catalogProductRepositoryV1GetGet(sku, editMode, storeId, forceReload, options)(fetch, basePath);
        },
        /**
         * Get product list
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CatalogProductRepositoryV1ApiFp(configuration).catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create product
         * @param {CatalogProductRepositoryV1SavePostBody} [catalogProductRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody?: CatalogProductRepositoryV1SavePostBody, options?: any) {
            return CatalogProductRepositoryV1ApiFp(configuration).catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create product
         * @param {string} sku
         * @param {CatalogProductRepositoryV1SavePutBody} [catalogProductRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductRepositoryV1SavePut(sku: string, catalogProductRepositoryV1SavePutBody?: CatalogProductRepositoryV1SavePutBody, options?: any) {
            return CatalogProductRepositoryV1ApiFp(configuration).catalogProductRepositoryV1SavePut(sku, catalogProductRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogProductRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductRepositoryV1Api extends BaseAPI {
    /**
     *
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductRepositoryV1Api
     */
    public catalogProductRepositoryV1DeleteByIdDelete(sku: string, options?: any) {
        return CatalogProductRepositoryV1ApiFp(this.configuration).catalogProductRepositoryV1DeleteByIdDelete(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Get info about product by product SKU
     * @param {string} sku
     * @param {boolean} [editMode]
     * @param {number} [storeId]
     * @param {boolean} [forceReload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductRepositoryV1Api
     */
    public catalogProductRepositoryV1GetGet(sku: string, editMode?: boolean, storeId?: number, forceReload?: boolean, options?: any) {
        return CatalogProductRepositoryV1ApiFp(this.configuration).catalogProductRepositoryV1GetGet(sku, editMode, storeId, forceReload, options)(this.fetch, this.basePath);
    }

    /**
     * Get product list
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductRepositoryV1Api
     */
    public catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CatalogProductRepositoryV1ApiFp(this.configuration).catalogProductRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create product
     * @param {CatalogProductRepositoryV1SavePostBody} [catalogProductRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductRepositoryV1Api
     */
    public catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody?: CatalogProductRepositoryV1SavePostBody, options?: any) {
        return CatalogProductRepositoryV1ApiFp(this.configuration).catalogProductRepositoryV1SavePost(catalogProductRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create product
     * @param {string} sku
     * @param {CatalogProductRepositoryV1SavePutBody} [catalogProductRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductRepositoryV1Api
     */
    public catalogProductRepositoryV1SavePut(sku: string, catalogProductRepositoryV1SavePutBody?: CatalogProductRepositoryV1SavePutBody, options?: any) {
        return CatalogProductRepositoryV1ApiFp(this.configuration).catalogProductRepositoryV1SavePut(sku, catalogProductRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductTierPriceManagementV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductTierPriceManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create tier price for product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {number} price
         * @param {number} qty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1AddPost(sku: string, customerGroupId: string, price: number, qty: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductTierPriceManagementV1AddPost.');
            }
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new RequiredError('customerGroupId','Required parameter customerGroupId was null or undefined when calling catalogProductTierPriceManagementV1AddPost.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new RequiredError('price','Required parameter price was null or undefined when calling catalogProductTierPriceManagementV1AddPost.');
            }
            // verify required parameter 'qty' is not null or undefined
            if (qty === null || qty === undefined) {
                throw new RequiredError('qty','Required parameter qty was null or undefined when calling catalogProductTierPriceManagementV1AddPost.');
            }
            const localVarPath = `/V1/products/{sku}/group-prices/{customerGroupId}/tiers/{qty}/price/{price}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)))
                .replace(`{${"price"}}`, encodeURIComponent(String(price)))
                .replace(`{${"qty"}}`, encodeURIComponent(String(qty)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tier price of product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1GetListGet(sku: string, customerGroupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductTierPriceManagementV1GetListGet.');
            }
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new RequiredError('customerGroupId','Required parameter customerGroupId was null or undefined when calling catalogProductTierPriceManagementV1GetListGet.');
            }
            const localVarPath = `/V1/products/{sku}/group-prices/{customerGroupId}/tiers`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove tier price from product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {number} qty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1RemoveDelete(sku: string, customerGroupId: string, qty: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductTierPriceManagementV1RemoveDelete.');
            }
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new RequiredError('customerGroupId','Required parameter customerGroupId was null or undefined when calling catalogProductTierPriceManagementV1RemoveDelete.');
            }
            // verify required parameter 'qty' is not null or undefined
            if (qty === null || qty === undefined) {
                throw new RequiredError('qty','Required parameter qty was null or undefined when calling catalogProductTierPriceManagementV1RemoveDelete.');
            }
            const localVarPath = `/V1/products/{sku}/group-prices/{customerGroupId}/tiers/{qty}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)))
                .replace(`{${"qty"}}`, encodeURIComponent(String(qty)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductTierPriceManagementV1Api - functional programming interface
 * @export
 */
export const CatalogProductTierPriceManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create tier price for product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {number} price
         * @param {number} qty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1AddPost(sku: string, customerGroupId: string, price: number, qty: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductTierPriceManagementV1ApiFetchParamCreator(configuration).catalogProductTierPriceManagementV1AddPost(sku, customerGroupId, price, qty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get tier price of product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1GetListGet(sku: string, customerGroupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductTierPriceInterface>> {
            const localVarFetchArgs = CatalogProductTierPriceManagementV1ApiFetchParamCreator(configuration).catalogProductTierPriceManagementV1GetListGet(sku, customerGroupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove tier price from product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {number} qty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1RemoveDelete(sku: string, customerGroupId: string, qty: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductTierPriceManagementV1ApiFetchParamCreator(configuration).catalogProductTierPriceManagementV1RemoveDelete(sku, customerGroupId, qty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductTierPriceManagementV1Api - factory interface
 * @export
 */
export const CatalogProductTierPriceManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create tier price for product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {number} price
         * @param {number} qty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1AddPost(sku: string, customerGroupId: string, price: number, qty: number, options?: any) {
            return CatalogProductTierPriceManagementV1ApiFp(configuration).catalogProductTierPriceManagementV1AddPost(sku, customerGroupId, price, qty, options)(fetch, basePath);
        },
        /**
         * Get tier price of product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1GetListGet(sku: string, customerGroupId: string, options?: any) {
            return CatalogProductTierPriceManagementV1ApiFp(configuration).catalogProductTierPriceManagementV1GetListGet(sku, customerGroupId, options)(fetch, basePath);
        },
        /**
         * Remove tier price from product
         * @param {string} sku
         * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
         * @param {number} qty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTierPriceManagementV1RemoveDelete(sku: string, customerGroupId: string, qty: number, options?: any) {
            return CatalogProductTierPriceManagementV1ApiFp(configuration).catalogProductTierPriceManagementV1RemoveDelete(sku, customerGroupId, qty, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductTierPriceManagementV1Api - object-oriented interface
 * @export
 * @class CatalogProductTierPriceManagementV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductTierPriceManagementV1Api extends BaseAPI {
    /**
     * Create tier price for product
     * @param {string} sku
     * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
     * @param {number} price
     * @param {number} qty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductTierPriceManagementV1Api
     */
    public catalogProductTierPriceManagementV1AddPost(sku: string, customerGroupId: string, price: number, qty: number, options?: any) {
        return CatalogProductTierPriceManagementV1ApiFp(this.configuration).catalogProductTierPriceManagementV1AddPost(sku, customerGroupId, price, qty, options)(this.fetch, this.basePath);
    }

    /**
     * Get tier price of product
     * @param {string} sku
     * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductTierPriceManagementV1Api
     */
    public catalogProductTierPriceManagementV1GetListGet(sku: string, customerGroupId: string, options?: any) {
        return CatalogProductTierPriceManagementV1ApiFp(this.configuration).catalogProductTierPriceManagementV1GetListGet(sku, customerGroupId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove tier price from product
     * @param {string} sku
     * @param {string} customerGroupId &#39;all&#39; can be used to specify &#39;ALL GROUPS&#39;
     * @param {number} qty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductTierPriceManagementV1Api
     */
    public catalogProductTierPriceManagementV1RemoveDelete(sku: string, customerGroupId: string, qty: number, options?: any) {
        return CatalogProductTierPriceManagementV1ApiFp(this.configuration).catalogProductTierPriceManagementV1RemoveDelete(sku, customerGroupId, qty, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductTypeListV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductTypeListV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve available product types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTypeListV1GetProductTypesGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductTypeListV1Api - functional programming interface
 * @export
 */
export const CatalogProductTypeListV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve available product types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTypeListV1GetProductTypesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductTypeInterface>> {
            const localVarFetchArgs = CatalogProductTypeListV1ApiFetchParamCreator(configuration).catalogProductTypeListV1GetProductTypesGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductTypeListV1Api - factory interface
 * @export
 */
export const CatalogProductTypeListV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve available product types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductTypeListV1GetProductTypesGet(options?: any) {
            return CatalogProductTypeListV1ApiFp(configuration).catalogProductTypeListV1GetProductTypesGet(options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductTypeListV1Api - object-oriented interface
 * @export
 * @class CatalogProductTypeListV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductTypeListV1Api extends BaseAPI {
    /**
     * Retrieve available product types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductTypeListV1Api
     */
    public catalogProductTypeListV1GetProductTypesGet(options?: any) {
        return CatalogProductTypeListV1ApiFp(this.configuration).catalogProductTypeListV1GetProductTypesGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogProductWebsiteLinkRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CatalogProductWebsiteLinkRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove the website assignment from the product by product sku
         * @param {string} sku
         * @param {number} websiteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku: string, websiteId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'websiteId' is not null or undefined
            if (websiteId === null || websiteId === undefined) {
                throw new RequiredError('websiteId','Required parameter websiteId was null or undefined when calling catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/products/{sku}/websites/{websiteId}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"websiteId"}}`, encodeURIComponent(String(websiteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a product to the website
         * @param {string} sku
         * @param {CatalogProductWebsiteLinkRepositoryV1SavePostBody} [catalogProductWebsiteLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1SavePost(sku: string, catalogProductWebsiteLinkRepositoryV1SavePostBody?: CatalogProductWebsiteLinkRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductWebsiteLinkRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/products/{sku}/websites`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductWebsiteLinkRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductWebsiteLinkRepositoryV1SavePostBody || {}) : (catalogProductWebsiteLinkRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a product to the website
         * @param {string} sku
         * @param {CatalogProductWebsiteLinkRepositoryV1SavePutBody} [catalogProductWebsiteLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1SavePut(sku: string, catalogProductWebsiteLinkRepositoryV1SavePutBody?: CatalogProductWebsiteLinkRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling catalogProductWebsiteLinkRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/{sku}/websites`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogProductWebsiteLinkRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogProductWebsiteLinkRepositoryV1SavePutBody || {}) : (catalogProductWebsiteLinkRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogProductWebsiteLinkRepositoryV1Api - functional programming interface
 * @export
 */
export const CatalogProductWebsiteLinkRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove the website assignment from the product by product sku
         * @param {string} sku
         * @param {number} websiteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku: string, websiteId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductWebsiteLinkRepositoryV1ApiFetchParamCreator(configuration).catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku, websiteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assign a product to the website
         * @param {string} sku
         * @param {CatalogProductWebsiteLinkRepositoryV1SavePostBody} [catalogProductWebsiteLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1SavePost(sku: string, catalogProductWebsiteLinkRepositoryV1SavePostBody?: CatalogProductWebsiteLinkRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductWebsiteLinkRepositoryV1ApiFetchParamCreator(configuration).catalogProductWebsiteLinkRepositoryV1SavePost(sku, catalogProductWebsiteLinkRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assign a product to the website
         * @param {string} sku
         * @param {CatalogProductWebsiteLinkRepositoryV1SavePutBody} [catalogProductWebsiteLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1SavePut(sku: string, catalogProductWebsiteLinkRepositoryV1SavePutBody?: CatalogProductWebsiteLinkRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CatalogProductWebsiteLinkRepositoryV1ApiFetchParamCreator(configuration).catalogProductWebsiteLinkRepositoryV1SavePut(sku, catalogProductWebsiteLinkRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogProductWebsiteLinkRepositoryV1Api - factory interface
 * @export
 */
export const CatalogProductWebsiteLinkRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove the website assignment from the product by product sku
         * @param {string} sku
         * @param {number} websiteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku: string, websiteId: number, options?: any) {
            return CatalogProductWebsiteLinkRepositoryV1ApiFp(configuration).catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku, websiteId, options)(fetch, basePath);
        },
        /**
         * Assign a product to the website
         * @param {string} sku
         * @param {CatalogProductWebsiteLinkRepositoryV1SavePostBody} [catalogProductWebsiteLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1SavePost(sku: string, catalogProductWebsiteLinkRepositoryV1SavePostBody?: CatalogProductWebsiteLinkRepositoryV1SavePostBody, options?: any) {
            return CatalogProductWebsiteLinkRepositoryV1ApiFp(configuration).catalogProductWebsiteLinkRepositoryV1SavePost(sku, catalogProductWebsiteLinkRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Assign a product to the website
         * @param {string} sku
         * @param {CatalogProductWebsiteLinkRepositoryV1SavePutBody} [catalogProductWebsiteLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogProductWebsiteLinkRepositoryV1SavePut(sku: string, catalogProductWebsiteLinkRepositoryV1SavePutBody?: CatalogProductWebsiteLinkRepositoryV1SavePutBody, options?: any) {
            return CatalogProductWebsiteLinkRepositoryV1ApiFp(configuration).catalogProductWebsiteLinkRepositoryV1SavePut(sku, catalogProductWebsiteLinkRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogProductWebsiteLinkRepositoryV1Api - object-oriented interface
 * @export
 * @class CatalogProductWebsiteLinkRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CatalogProductWebsiteLinkRepositoryV1Api extends BaseAPI {
    /**
     * Remove the website assignment from the product by product sku
     * @param {string} sku
     * @param {number} websiteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductWebsiteLinkRepositoryV1Api
     */
    public catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku: string, websiteId: number, options?: any) {
        return CatalogProductWebsiteLinkRepositoryV1ApiFp(this.configuration).catalogProductWebsiteLinkRepositoryV1DeleteByIdDelete(sku, websiteId, options)(this.fetch, this.basePath);
    }

    /**
     * Assign a product to the website
     * @param {string} sku
     * @param {CatalogProductWebsiteLinkRepositoryV1SavePostBody} [catalogProductWebsiteLinkRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductWebsiteLinkRepositoryV1Api
     */
    public catalogProductWebsiteLinkRepositoryV1SavePost(sku: string, catalogProductWebsiteLinkRepositoryV1SavePostBody?: CatalogProductWebsiteLinkRepositoryV1SavePostBody, options?: any) {
        return CatalogProductWebsiteLinkRepositoryV1ApiFp(this.configuration).catalogProductWebsiteLinkRepositoryV1SavePost(sku, catalogProductWebsiteLinkRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Assign a product to the website
     * @param {string} sku
     * @param {CatalogProductWebsiteLinkRepositoryV1SavePutBody} [catalogProductWebsiteLinkRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogProductWebsiteLinkRepositoryV1Api
     */
    public catalogProductWebsiteLinkRepositoryV1SavePut(sku: string, catalogProductWebsiteLinkRepositoryV1SavePutBody?: CatalogProductWebsiteLinkRepositoryV1SavePutBody, options?: any) {
        return CatalogProductWebsiteLinkRepositoryV1ApiFp(this.configuration).catalogProductWebsiteLinkRepositoryV1SavePut(sku, catalogProductWebsiteLinkRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogSpecialPriceStorageV1Api - fetch parameter creator
 * @export
 */
export const CatalogSpecialPriceStorageV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the delete exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1DeletePostBody} [catalogSpecialPriceStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody?: CatalogSpecialPriceStorageV1DeletePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/special-price-delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogSpecialPriceStorageV1DeletePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogSpecialPriceStorageV1DeletePostBody || {}) : (catalogSpecialPriceStorageV1DeletePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return product's special price. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1GetPostBody} [catalogSpecialPriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody?: CatalogSpecialPriceStorageV1GetPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/special-price-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogSpecialPriceStorageV1GetPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogSpecialPriceStorageV1GetPostBody || {}) : (catalogSpecialPriceStorageV1GetPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1UpdatePostBody} [catalogSpecialPriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody?: CatalogSpecialPriceStorageV1UpdatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/special-price`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogSpecialPriceStorageV1UpdatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogSpecialPriceStorageV1UpdatePostBody || {}) : (catalogSpecialPriceStorageV1UpdatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogSpecialPriceStorageV1Api - functional programming interface
 * @export
 */
export const CatalogSpecialPriceStorageV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the delete exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1DeletePostBody} [catalogSpecialPriceStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody?: CatalogSpecialPriceStorageV1DeletePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogSpecialPriceStorageV1ApiFetchParamCreator(configuration).catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return product's special price. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1GetPostBody} [catalogSpecialPriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody?: CatalogSpecialPriceStorageV1GetPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataSpecialPriceInterface>> {
            const localVarFetchArgs = CatalogSpecialPriceStorageV1ApiFetchParamCreator(configuration).catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or update product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1UpdatePostBody} [catalogSpecialPriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody?: CatalogSpecialPriceStorageV1UpdatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogSpecialPriceStorageV1ApiFetchParamCreator(configuration).catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogSpecialPriceStorageV1Api - factory interface
 * @export
 */
export const CatalogSpecialPriceStorageV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the delete exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1DeletePostBody} [catalogSpecialPriceStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody?: CatalogSpecialPriceStorageV1DeletePostBody, options?: any) {
            return CatalogSpecialPriceStorageV1ApiFp(configuration).catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody, options)(fetch, basePath);
        },
        /**
         * Return product's special price. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1GetPostBody} [catalogSpecialPriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody?: CatalogSpecialPriceStorageV1GetPostBody, options?: any) {
            return CatalogSpecialPriceStorageV1ApiFp(configuration).catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody, options)(fetch, basePath);
        },
        /**
         * Add or update product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogSpecialPriceStorageV1UpdatePostBody} [catalogSpecialPriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody?: CatalogSpecialPriceStorageV1UpdatePostBody, options?: any) {
            return CatalogSpecialPriceStorageV1ApiFp(configuration).catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogSpecialPriceStorageV1Api - object-oriented interface
 * @export
 * @class CatalogSpecialPriceStorageV1Api
 * @extends {BaseAPI}
 */
export class CatalogSpecialPriceStorageV1Api extends BaseAPI {
    /**
     * Delete product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the delete exception will be thrown.
     * @param {CatalogSpecialPriceStorageV1DeletePostBody} [catalogSpecialPriceStorageV1DeletePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSpecialPriceStorageV1Api
     */
    public catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody?: CatalogSpecialPriceStorageV1DeletePostBody, options?: any) {
        return CatalogSpecialPriceStorageV1ApiFp(this.configuration).catalogSpecialPriceStorageV1DeletePost(catalogSpecialPriceStorageV1DeletePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return product's special price. In case of at least one of skus is not found exception will be thrown.
     * @param {CatalogSpecialPriceStorageV1GetPostBody} [catalogSpecialPriceStorageV1GetPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSpecialPriceStorageV1Api
     */
    public catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody?: CatalogSpecialPriceStorageV1GetPostBody, options?: any) {
        return CatalogSpecialPriceStorageV1ApiFp(this.configuration).catalogSpecialPriceStorageV1GetPost(catalogSpecialPriceStorageV1GetPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add or update product's special price. If any items will have invalid price, store id, sku or dates, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
     * @param {CatalogSpecialPriceStorageV1UpdatePostBody} [catalogSpecialPriceStorageV1UpdatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogSpecialPriceStorageV1Api
     */
    public catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody?: CatalogSpecialPriceStorageV1UpdatePostBody, options?: any) {
        return CatalogSpecialPriceStorageV1ApiFp(this.configuration).catalogSpecialPriceStorageV1UpdatePost(catalogSpecialPriceStorageV1UpdatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogTierPriceStorageV1Api - fetch parameter creator
 * @export
 */
export const CatalogTierPriceStorageV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete product tier prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1DeletePostBody} [catalogTierPriceStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody?: CatalogTierPriceStorageV1DeletePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/tier-prices-delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogTierPriceStorageV1DeletePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogTierPriceStorageV1DeletePostBody || {}) : (catalogTierPriceStorageV1DeletePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogTierPriceStorageV1GetPostBody} [catalogTierPriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody?: CatalogTierPriceStorageV1GetPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/tier-prices-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogTierPriceStorageV1GetPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogTierPriceStorageV1GetPostBody || {}) : (catalogTierPriceStorageV1GetPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove existing tier prices and replace them with the new ones. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from replace list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1ReplacePutBody} [catalogTierPriceStorageV1ReplacePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody?: CatalogTierPriceStorageV1ReplacePutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/tier-prices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogTierPriceStorageV1ReplacePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogTierPriceStorageV1ReplacePutBody || {}) : (catalogTierPriceStorageV1ReplacePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or update product prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1UpdatePostBody} [catalogTierPriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody?: CatalogTierPriceStorageV1UpdatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/products/tier-prices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatalogTierPriceStorageV1UpdatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catalogTierPriceStorageV1UpdatePostBody || {}) : (catalogTierPriceStorageV1UpdatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogTierPriceStorageV1Api - functional programming interface
 * @export
 */
export const CatalogTierPriceStorageV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete product tier prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1DeletePostBody} [catalogTierPriceStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody?: CatalogTierPriceStorageV1DeletePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogTierPriceStorageV1ApiFetchParamCreator(configuration).catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogTierPriceStorageV1GetPostBody} [catalogTierPriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody?: CatalogTierPriceStorageV1GetPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataTierPriceInterface>> {
            const localVarFetchArgs = CatalogTierPriceStorageV1ApiFetchParamCreator(configuration).catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove existing tier prices and replace them with the new ones. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from replace list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1ReplacePutBody} [catalogTierPriceStorageV1ReplacePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody?: CatalogTierPriceStorageV1ReplacePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogTierPriceStorageV1ApiFetchParamCreator(configuration).catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or update product prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1UpdatePostBody} [catalogTierPriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody?: CatalogTierPriceStorageV1UpdatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataPriceUpdateResultInterface>> {
            const localVarFetchArgs = CatalogTierPriceStorageV1ApiFetchParamCreator(configuration).catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogTierPriceStorageV1Api - factory interface
 * @export
 */
export const CatalogTierPriceStorageV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete product tier prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1DeletePostBody} [catalogTierPriceStorageV1DeletePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody?: CatalogTierPriceStorageV1DeletePostBody, options?: any) {
            return CatalogTierPriceStorageV1ApiFp(configuration).catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody, options)(fetch, basePath);
        },
        /**
         * Return product prices. In case of at least one of skus is not found exception will be thrown.
         * @param {CatalogTierPriceStorageV1GetPostBody} [catalogTierPriceStorageV1GetPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody?: CatalogTierPriceStorageV1GetPostBody, options?: any) {
            return CatalogTierPriceStorageV1ApiFp(configuration).catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody, options)(fetch, basePath);
        },
        /**
         * Remove existing tier prices and replace them with the new ones. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from replace list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1ReplacePutBody} [catalogTierPriceStorageV1ReplacePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody?: CatalogTierPriceStorageV1ReplacePutBody, options?: any) {
            return CatalogTierPriceStorageV1ApiFp(configuration).catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody, options)(fetch, basePath);
        },
        /**
         * Add or update product prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
         * @param {CatalogTierPriceStorageV1UpdatePostBody} [catalogTierPriceStorageV1UpdatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody?: CatalogTierPriceStorageV1UpdatePostBody, options?: any) {
            return CatalogTierPriceStorageV1ApiFp(configuration).catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogTierPriceStorageV1Api - object-oriented interface
 * @export
 * @class CatalogTierPriceStorageV1Api
 * @extends {BaseAPI}
 */
export class CatalogTierPriceStorageV1Api extends BaseAPI {
    /**
     * Delete product tier prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from delete list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
     * @param {CatalogTierPriceStorageV1DeletePostBody} [catalogTierPriceStorageV1DeletePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogTierPriceStorageV1Api
     */
    public catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody?: CatalogTierPriceStorageV1DeletePostBody, options?: any) {
        return CatalogTierPriceStorageV1ApiFp(this.configuration).catalogTierPriceStorageV1DeletePost(catalogTierPriceStorageV1DeletePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return product prices. In case of at least one of skus is not found exception will be thrown.
     * @param {CatalogTierPriceStorageV1GetPostBody} [catalogTierPriceStorageV1GetPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogTierPriceStorageV1Api
     */
    public catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody?: CatalogTierPriceStorageV1GetPostBody, options?: any) {
        return CatalogTierPriceStorageV1ApiFp(this.configuration).catalogTierPriceStorageV1GetPost(catalogTierPriceStorageV1GetPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Remove existing tier prices and replace them with the new ones. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from replace list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
     * @param {CatalogTierPriceStorageV1ReplacePutBody} [catalogTierPriceStorageV1ReplacePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogTierPriceStorageV1Api
     */
    public catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody?: CatalogTierPriceStorageV1ReplacePutBody, options?: any) {
        return CatalogTierPriceStorageV1ApiFp(this.configuration).catalogTierPriceStorageV1ReplacePut(catalogTierPriceStorageV1ReplacePutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add or update product prices. If any items will have invalid price, price type, website id, sku, customer group or quantity, they will be marked as failed and excluded from update list and \\Magento\\Catalog\\Api\\Data\\PriceUpdateResultInterface[] with problem description will be returned. If there were no failed items during update empty array will be returned. If error occurred during the update exception will be thrown.
     * @param {CatalogTierPriceStorageV1UpdatePostBody} [catalogTierPriceStorageV1UpdatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogTierPriceStorageV1Api
     */
    public catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody?: CatalogTierPriceStorageV1UpdatePostBody, options?: any) {
        return CatalogTierPriceStorageV1ApiFp(this.configuration).catalogTierPriceStorageV1UpdatePost(catalogTierPriceStorageV1UpdatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutAgreementsCheckoutAgreementsRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CheckoutAgreementsCheckoutAgreementsRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists active checkout agreements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/licence`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutAgreementsCheckoutAgreementsRepositoryV1Api - functional programming interface
 * @export
 */
export const CheckoutAgreementsCheckoutAgreementsRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists active checkout agreements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CheckoutAgreementsDataAgreementInterface>> {
            const localVarFetchArgs = CheckoutAgreementsCheckoutAgreementsRepositoryV1ApiFetchParamCreator(configuration).checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutAgreementsCheckoutAgreementsRepositoryV1Api - factory interface
 * @export
 */
export const CheckoutAgreementsCheckoutAgreementsRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists active checkout agreements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options?: any) {
            return CheckoutAgreementsCheckoutAgreementsRepositoryV1ApiFp(configuration).checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutAgreementsCheckoutAgreementsRepositoryV1Api - object-oriented interface
 * @export
 * @class CheckoutAgreementsCheckoutAgreementsRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CheckoutAgreementsCheckoutAgreementsRepositoryV1Api extends BaseAPI {
    /**
     * Lists active checkout agreements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutAgreementsCheckoutAgreementsRepositoryV1Api
     */
    public checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options?: any) {
        return CheckoutAgreementsCheckoutAgreementsRepositoryV1ApiFp(this.configuration).checkoutAgreementsCheckoutAgreementsRepositoryV1GetListGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutGuestPaymentInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const CheckoutGuestPaymentInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payment information
         * @param {string} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {string} cartId
         * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody || {}) : (checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payment information for a specified cart.
         * @param {string} cartId
         * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/set-payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody || {}) : (checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutGuestPaymentInformationManagementV1Api - functional programming interface
 * @export
 */
export const CheckoutGuestPaymentInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get payment information
         * @param {string} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = CheckoutGuestPaymentInformationManagementV1ApiFetchParamCreator(configuration).checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {string} cartId
         * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CheckoutGuestPaymentInformationManagementV1ApiFetchParamCreator(configuration).checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set payment information for a specified cart.
         * @param {string} cartId
         * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CheckoutGuestPaymentInformationManagementV1ApiFetchParamCreator(configuration).checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutGuestPaymentInformationManagementV1Api - factory interface
 * @export
 */
export const CheckoutGuestPaymentInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get payment information
         * @param {string} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId: string, options?: any) {
            return CheckoutGuestPaymentInformationManagementV1ApiFp(configuration).checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId, options)(fetch, basePath);
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {string} cartId
         * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
            return CheckoutGuestPaymentInformationManagementV1ApiFp(configuration).checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options)(fetch, basePath);
        },
        /**
         * Set payment information for a specified cart.
         * @param {string} cartId
         * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options?: any) {
            return CheckoutGuestPaymentInformationManagementV1ApiFp(configuration).checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutGuestPaymentInformationManagementV1Api - object-oriented interface
 * @export
 * @class CheckoutGuestPaymentInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class CheckoutGuestPaymentInformationManagementV1Api extends BaseAPI {
    /**
     * Get payment information
     * @param {string} cartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutGuestPaymentInformationManagementV1Api
     */
    public checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId: string, options?: any) {
        return CheckoutGuestPaymentInformationManagementV1ApiFp(this.configuration).checkoutGuestPaymentInformationManagementV1GetPaymentInformationGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Set payment information and place order for a specified cart.
     * @param {string} cartId
     * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutGuestPaymentInformationManagementV1Api
     */
    public checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
        return CheckoutGuestPaymentInformationManagementV1ApiFp(this.configuration).checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId, checkoutGuestPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Set payment information for a specified cart.
     * @param {string} cartId
     * @param {CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutGuestPaymentInformationManagementV1Api
     */
    public checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId: string, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options?: any) {
        return CheckoutGuestPaymentInformationManagementV1ApiFp(this.configuration).checkoutGuestPaymentInformationManagementV1SavePaymentInformationPost(cartId, checkoutGuestPaymentInformationManagementV1SavePaymentInformationPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutGuestShippingInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const CheckoutGuestShippingInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} cartId
         * @param {CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId: string, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutGuestShippingInformationManagementV1SaveAddressInformationPost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/shipping-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody || {}) : (checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutGuestShippingInformationManagementV1Api - functional programming interface
 * @export
 */
export const CheckoutGuestShippingInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} cartId
         * @param {CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId: string, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = CheckoutGuestShippingInformationManagementV1ApiFetchParamCreator(configuration).checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutGuestShippingInformationManagementV1Api - factory interface
 * @export
 */
export const CheckoutGuestShippingInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} cartId
         * @param {CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId: string, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options?: any) {
            return CheckoutGuestShippingInformationManagementV1ApiFp(configuration).checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutGuestShippingInformationManagementV1Api - object-oriented interface
 * @export
 * @class CheckoutGuestShippingInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class CheckoutGuestShippingInformationManagementV1Api extends BaseAPI {
    /**
     *
     * @param {string} cartId
     * @param {CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutGuestShippingInformationManagementV1Api
     */
    public checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId: string, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options?: any) {
        return CheckoutGuestShippingInformationManagementV1ApiFp(this.configuration).checkoutGuestShippingInformationManagementV1SaveAddressInformationPost(cartId, checkoutGuestShippingInformationManagementV1SaveAddressInformationPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutGuestTotalsInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const CheckoutGuestTotalsInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {string} cartId
         * @param {CheckoutGuestTotalsInformationManagementV1CalculatePostBody} [checkoutGuestTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestTotalsInformationManagementV1CalculatePost(cartId: string, checkoutGuestTotalsInformationManagementV1CalculatePostBody?: CheckoutGuestTotalsInformationManagementV1CalculatePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutGuestTotalsInformationManagementV1CalculatePost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/totals-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutGuestTotalsInformationManagementV1CalculatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutGuestTotalsInformationManagementV1CalculatePostBody || {}) : (checkoutGuestTotalsInformationManagementV1CalculatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutGuestTotalsInformationManagementV1Api - functional programming interface
 * @export
 */
export const CheckoutGuestTotalsInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {string} cartId
         * @param {CheckoutGuestTotalsInformationManagementV1CalculatePostBody} [checkoutGuestTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestTotalsInformationManagementV1CalculatePost(cartId: string, checkoutGuestTotalsInformationManagementV1CalculatePostBody?: CheckoutGuestTotalsInformationManagementV1CalculatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = CheckoutGuestTotalsInformationManagementV1ApiFetchParamCreator(configuration).checkoutGuestTotalsInformationManagementV1CalculatePost(cartId, checkoutGuestTotalsInformationManagementV1CalculatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutGuestTotalsInformationManagementV1Api - factory interface
 * @export
 */
export const CheckoutGuestTotalsInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {string} cartId
         * @param {CheckoutGuestTotalsInformationManagementV1CalculatePostBody} [checkoutGuestTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutGuestTotalsInformationManagementV1CalculatePost(cartId: string, checkoutGuestTotalsInformationManagementV1CalculatePostBody?: CheckoutGuestTotalsInformationManagementV1CalculatePostBody, options?: any) {
            return CheckoutGuestTotalsInformationManagementV1ApiFp(configuration).checkoutGuestTotalsInformationManagementV1CalculatePost(cartId, checkoutGuestTotalsInformationManagementV1CalculatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutGuestTotalsInformationManagementV1Api - object-oriented interface
 * @export
 * @class CheckoutGuestTotalsInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class CheckoutGuestTotalsInformationManagementV1Api extends BaseAPI {
    /**
     * Calculate quote totals based on address and shipping method.
     * @param {string} cartId
     * @param {CheckoutGuestTotalsInformationManagementV1CalculatePostBody} [checkoutGuestTotalsInformationManagementV1CalculatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutGuestTotalsInformationManagementV1Api
     */
    public checkoutGuestTotalsInformationManagementV1CalculatePost(cartId: string, checkoutGuestTotalsInformationManagementV1CalculatePostBody?: CheckoutGuestTotalsInformationManagementV1CalculatePostBody, options?: any) {
        return CheckoutGuestTotalsInformationManagementV1ApiFp(this.configuration).checkoutGuestTotalsInformationManagementV1CalculatePost(cartId, checkoutGuestTotalsInformationManagementV1CalculatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutPaymentInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const CheckoutPaymentInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1GetPaymentInformationGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/payment-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/payment-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody || {}) : (checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payment information for a specified cart.
         * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/set-payment-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody || {}) : (checkoutPaymentInformationManagementV1SavePaymentInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutPaymentInformationManagementV1Api - functional programming interface
 * @export
 */
export const CheckoutPaymentInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get payment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1GetPaymentInformationGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = CheckoutPaymentInformationManagementV1ApiFetchParamCreator(configuration).checkoutPaymentInformationManagementV1GetPaymentInformationGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CheckoutPaymentInformationManagementV1ApiFetchParamCreator(configuration).checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set payment information for a specified cart.
         * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CheckoutPaymentInformationManagementV1ApiFetchParamCreator(configuration).checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutPaymentInformationManagementV1Api - factory interface
 * @export
 */
export const CheckoutPaymentInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get payment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1GetPaymentInformationGet(options?: any) {
            return CheckoutPaymentInformationManagementV1ApiFp(configuration).checkoutPaymentInformationManagementV1GetPaymentInformationGet(options)(fetch, basePath);
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
            return CheckoutPaymentInformationManagementV1ApiFp(configuration).checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options)(fetch, basePath);
        },
        /**
         * Set payment information for a specified cart.
         * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody, options?: any) {
            return CheckoutPaymentInformationManagementV1ApiFp(configuration).checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutPaymentInformationManagementV1Api - object-oriented interface
 * @export
 * @class CheckoutPaymentInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class CheckoutPaymentInformationManagementV1Api extends BaseAPI {
    /**
     * Get payment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutPaymentInformationManagementV1Api
     */
    public checkoutPaymentInformationManagementV1GetPaymentInformationGet(options?: any) {
        return CheckoutPaymentInformationManagementV1ApiFp(this.configuration).checkoutPaymentInformationManagementV1GetPaymentInformationGet(options)(this.fetch, this.basePath);
    }

    /**
     * Set payment information and place order for a specified cart.
     * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutPaymentInformationManagementV1Api
     */
    public checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
        return CheckoutPaymentInformationManagementV1ApiFp(this.configuration).checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(checkoutPaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Set payment information for a specified cart.
     * @param {CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody} [checkoutPaymentInformationManagementV1SavePaymentInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutPaymentInformationManagementV1Api
     */
    public checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody?: CheckoutPaymentInformationManagementV1SavePaymentInformationPostBody, options?: any) {
        return CheckoutPaymentInformationManagementV1ApiFp(this.configuration).checkoutPaymentInformationManagementV1SavePaymentInformationPost(checkoutPaymentInformationManagementV1SavePaymentInformationPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutShippingInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const CheckoutShippingInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/shipping-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutShippingInformationManagementV1SaveAddressInformationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutShippingInformationManagementV1SaveAddressInformationPostBody || {}) : (checkoutShippingInformationManagementV1SaveAddressInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} cartId
         * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId: number, checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutShippingInformationManagementV1SaveAddressInformationPost_1.');
            }
            const localVarPath = `/V1/carts/{cartId}/shipping-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutShippingInformationManagementV1SaveAddressInformationPostBody || {}) : (checkoutShippingInformationManagementV1SaveAddressInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutShippingInformationManagementV1Api - functional programming interface
 * @export
 */
export const CheckoutShippingInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = CheckoutShippingInformationManagementV1ApiFetchParamCreator(configuration).checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} cartId
         * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId: number, checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = CheckoutShippingInformationManagementV1ApiFetchParamCreator(configuration).checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId, checkoutShippingInformationManagementV1SaveAddressInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutShippingInformationManagementV1Api - factory interface
 * @export
 */
export const CheckoutShippingInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody, options?: any) {
            return CheckoutShippingInformationManagementV1ApiFp(configuration).checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} cartId
         * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId: number, checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1, options?: any) {
            return CheckoutShippingInformationManagementV1ApiFp(configuration).checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId, checkoutShippingInformationManagementV1SaveAddressInformationPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutShippingInformationManagementV1Api - object-oriented interface
 * @export
 * @class CheckoutShippingInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class CheckoutShippingInformationManagementV1Api extends BaseAPI {
    /**
     *
     * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutShippingInformationManagementV1Api
     */
    public checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody, options?: any) {
        return CheckoutShippingInformationManagementV1ApiFp(this.configuration).checkoutShippingInformationManagementV1SaveAddressInformationPost(checkoutShippingInformationManagementV1SaveAddressInformationPostBody, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} cartId
     * @param {CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1} [checkoutShippingInformationManagementV1SaveAddressInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutShippingInformationManagementV1Api
     */
    public checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId: number, checkoutShippingInformationManagementV1SaveAddressInformationPostBody?: CheckoutShippingInformationManagementV1SaveAddressInformationPostBody1, options?: any) {
        return CheckoutShippingInformationManagementV1ApiFp(this.configuration).checkoutShippingInformationManagementV1SaveAddressInformationPost_1(cartId, checkoutShippingInformationManagementV1SaveAddressInformationPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutTotalsInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const CheckoutTotalsInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {number} cartId
         * @param {CheckoutTotalsInformationManagementV1CalculatePostBody} [checkoutTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutTotalsInformationManagementV1CalculatePost(cartId: number, checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling checkoutTotalsInformationManagementV1CalculatePost.');
            }
            const localVarPath = `/V1/carts/{cartId}/totals-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutTotalsInformationManagementV1CalculatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutTotalsInformationManagementV1CalculatePostBody || {}) : (checkoutTotalsInformationManagementV1CalculatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {CheckoutTotalsInformationManagementV1CalculatePostBody1} [checkoutTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/totals-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutTotalsInformationManagementV1CalculatePostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(checkoutTotalsInformationManagementV1CalculatePostBody || {}) : (checkoutTotalsInformationManagementV1CalculatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutTotalsInformationManagementV1Api - functional programming interface
 * @export
 */
export const CheckoutTotalsInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {number} cartId
         * @param {CheckoutTotalsInformationManagementV1CalculatePostBody} [checkoutTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutTotalsInformationManagementV1CalculatePost(cartId: number, checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = CheckoutTotalsInformationManagementV1ApiFetchParamCreator(configuration).checkoutTotalsInformationManagementV1CalculatePost(cartId, checkoutTotalsInformationManagementV1CalculatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {CheckoutTotalsInformationManagementV1CalculatePostBody1} [checkoutTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = CheckoutTotalsInformationManagementV1ApiFetchParamCreator(configuration).checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutTotalsInformationManagementV1Api - factory interface
 * @export
 */
export const CheckoutTotalsInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {number} cartId
         * @param {CheckoutTotalsInformationManagementV1CalculatePostBody} [checkoutTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutTotalsInformationManagementV1CalculatePost(cartId: number, checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody, options?: any) {
            return CheckoutTotalsInformationManagementV1ApiFp(configuration).checkoutTotalsInformationManagementV1CalculatePost(cartId, checkoutTotalsInformationManagementV1CalculatePostBody, options)(fetch, basePath);
        },
        /**
         * Calculate quote totals based on address and shipping method.
         * @param {CheckoutTotalsInformationManagementV1CalculatePostBody1} [checkoutTotalsInformationManagementV1CalculatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody1, options?: any) {
            return CheckoutTotalsInformationManagementV1ApiFp(configuration).checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutTotalsInformationManagementV1Api - object-oriented interface
 * @export
 * @class CheckoutTotalsInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class CheckoutTotalsInformationManagementV1Api extends BaseAPI {
    /**
     * Calculate quote totals based on address and shipping method.
     * @param {number} cartId
     * @param {CheckoutTotalsInformationManagementV1CalculatePostBody} [checkoutTotalsInformationManagementV1CalculatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutTotalsInformationManagementV1Api
     */
    public checkoutTotalsInformationManagementV1CalculatePost(cartId: number, checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody, options?: any) {
        return CheckoutTotalsInformationManagementV1ApiFp(this.configuration).checkoutTotalsInformationManagementV1CalculatePost(cartId, checkoutTotalsInformationManagementV1CalculatePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Calculate quote totals based on address and shipping method.
     * @param {CheckoutTotalsInformationManagementV1CalculatePostBody1} [checkoutTotalsInformationManagementV1CalculatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutTotalsInformationManagementV1Api
     */
    public checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody?: CheckoutTotalsInformationManagementV1CalculatePostBody1, options?: any) {
        return CheckoutTotalsInformationManagementV1ApiFp(this.configuration).checkoutTotalsInformationManagementV1CalculatePost_1(checkoutTotalsInformationManagementV1CalculatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CmsBlockRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CmsBlockRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete block by ID.
         * @param {number} blockId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1DeleteByIdDelete(blockId: number, options: any = {}): FetchArgs {
            // verify required parameter 'blockId' is not null or undefined
            if (blockId === null || blockId === undefined) {
                throw new RequiredError('blockId','Required parameter blockId was null or undefined when calling cmsBlockRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/cmsBlock/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve block.
         * @param {number} blockId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1GetByIdGet(blockId: number, options: any = {}): FetchArgs {
            // verify required parameter 'blockId' is not null or undefined
            if (blockId === null || blockId === undefined) {
                throw new RequiredError('blockId','Required parameter blockId was null or undefined when calling cmsBlockRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/cmsBlock/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve blocks matching the specified criteria.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/cmsBlock/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save block.
         * @param {CmsBlockRepositoryV1SavePostBody} [cmsBlockRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody?: CmsBlockRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/cmsBlock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CmsBlockRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cmsBlockRepositoryV1SavePostBody || {}) : (cmsBlockRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save block.
         * @param {string} id
         * @param {CmsBlockRepositoryV1SavePutBody} [cmsBlockRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1SavePut(id: string, cmsBlockRepositoryV1SavePutBody?: CmsBlockRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cmsBlockRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/cmsBlock/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CmsBlockRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cmsBlockRepositoryV1SavePutBody || {}) : (cmsBlockRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CmsBlockRepositoryV1Api - functional programming interface
 * @export
 */
export const CmsBlockRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete block by ID.
         * @param {number} blockId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1DeleteByIdDelete(blockId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CmsBlockRepositoryV1ApiFetchParamCreator(configuration).cmsBlockRepositoryV1DeleteByIdDelete(blockId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve block.
         * @param {number} blockId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1GetByIdGet(blockId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataBlockInterface> {
            const localVarFetchArgs = CmsBlockRepositoryV1ApiFetchParamCreator(configuration).cmsBlockRepositoryV1GetByIdGet(blockId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve blocks matching the specified criteria.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataBlockSearchResultsInterface> {
            const localVarFetchArgs = CmsBlockRepositoryV1ApiFetchParamCreator(configuration).cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save block.
         * @param {CmsBlockRepositoryV1SavePostBody} [cmsBlockRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody?: CmsBlockRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataBlockInterface> {
            const localVarFetchArgs = CmsBlockRepositoryV1ApiFetchParamCreator(configuration).cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save block.
         * @param {string} id
         * @param {CmsBlockRepositoryV1SavePutBody} [cmsBlockRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1SavePut(id: string, cmsBlockRepositoryV1SavePutBody?: CmsBlockRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataBlockInterface> {
            const localVarFetchArgs = CmsBlockRepositoryV1ApiFetchParamCreator(configuration).cmsBlockRepositoryV1SavePut(id, cmsBlockRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CmsBlockRepositoryV1Api - factory interface
 * @export
 */
export const CmsBlockRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete block by ID.
         * @param {number} blockId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1DeleteByIdDelete(blockId: number, options?: any) {
            return CmsBlockRepositoryV1ApiFp(configuration).cmsBlockRepositoryV1DeleteByIdDelete(blockId, options)(fetch, basePath);
        },
        /**
         * Retrieve block.
         * @param {number} blockId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1GetByIdGet(blockId: number, options?: any) {
            return CmsBlockRepositoryV1ApiFp(configuration).cmsBlockRepositoryV1GetByIdGet(blockId, options)(fetch, basePath);
        },
        /**
         * Retrieve blocks matching the specified criteria.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CmsBlockRepositoryV1ApiFp(configuration).cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save block.
         * @param {CmsBlockRepositoryV1SavePostBody} [cmsBlockRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody?: CmsBlockRepositoryV1SavePostBody, options?: any) {
            return CmsBlockRepositoryV1ApiFp(configuration).cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save block.
         * @param {string} id
         * @param {CmsBlockRepositoryV1SavePutBody} [cmsBlockRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsBlockRepositoryV1SavePut(id: string, cmsBlockRepositoryV1SavePutBody?: CmsBlockRepositoryV1SavePutBody, options?: any) {
            return CmsBlockRepositoryV1ApiFp(configuration).cmsBlockRepositoryV1SavePut(id, cmsBlockRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CmsBlockRepositoryV1Api - object-oriented interface
 * @export
 * @class CmsBlockRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CmsBlockRepositoryV1Api extends BaseAPI {
    /**
     * Delete block by ID.
     * @param {number} blockId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsBlockRepositoryV1Api
     */
    public cmsBlockRepositoryV1DeleteByIdDelete(blockId: number, options?: any) {
        return CmsBlockRepositoryV1ApiFp(this.configuration).cmsBlockRepositoryV1DeleteByIdDelete(blockId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve block.
     * @param {number} blockId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsBlockRepositoryV1Api
     */
    public cmsBlockRepositoryV1GetByIdGet(blockId: number, options?: any) {
        return CmsBlockRepositoryV1ApiFp(this.configuration).cmsBlockRepositoryV1GetByIdGet(blockId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve blocks matching the specified criteria.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsBlockRepositoryV1Api
     */
    public cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CmsBlockRepositoryV1ApiFp(this.configuration).cmsBlockRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save block.
     * @param {CmsBlockRepositoryV1SavePostBody} [cmsBlockRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsBlockRepositoryV1Api
     */
    public cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody?: CmsBlockRepositoryV1SavePostBody, options?: any) {
        return CmsBlockRepositoryV1ApiFp(this.configuration).cmsBlockRepositoryV1SavePost(cmsBlockRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save block.
     * @param {string} id
     * @param {CmsBlockRepositoryV1SavePutBody} [cmsBlockRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsBlockRepositoryV1Api
     */
    public cmsBlockRepositoryV1SavePut(id: string, cmsBlockRepositoryV1SavePutBody?: CmsBlockRepositoryV1SavePutBody, options?: any) {
        return CmsBlockRepositoryV1ApiFp(this.configuration).cmsBlockRepositoryV1SavePut(id, cmsBlockRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CmsPageRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CmsPageRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete page by ID.
         * @param {number} pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1DeleteByIdDelete(pageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling cmsPageRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/cmsPage/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve page.
         * @param {number} pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1GetByIdGet(pageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling cmsPageRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/cmsPage/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pages matching the specified criteria.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/cmsPage/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save page.
         * @param {CmsPageRepositoryV1SavePostBody} [cmsPageRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody?: CmsPageRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/cmsPage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CmsPageRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cmsPageRepositoryV1SavePostBody || {}) : (cmsPageRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save page.
         * @param {string} id
         * @param {CmsPageRepositoryV1SavePutBody} [cmsPageRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1SavePut(id: string, cmsPageRepositoryV1SavePutBody?: CmsPageRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cmsPageRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/cmsPage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CmsPageRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cmsPageRepositoryV1SavePutBody || {}) : (cmsPageRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CmsPageRepositoryV1Api - functional programming interface
 * @export
 */
export const CmsPageRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete page by ID.
         * @param {number} pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1DeleteByIdDelete(pageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CmsPageRepositoryV1ApiFetchParamCreator(configuration).cmsPageRepositoryV1DeleteByIdDelete(pageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve page.
         * @param {number} pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1GetByIdGet(pageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataPageInterface> {
            const localVarFetchArgs = CmsPageRepositoryV1ApiFetchParamCreator(configuration).cmsPageRepositoryV1GetByIdGet(pageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve pages matching the specified criteria.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataPageSearchResultsInterface> {
            const localVarFetchArgs = CmsPageRepositoryV1ApiFetchParamCreator(configuration).cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save page.
         * @param {CmsPageRepositoryV1SavePostBody} [cmsPageRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody?: CmsPageRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataPageInterface> {
            const localVarFetchArgs = CmsPageRepositoryV1ApiFetchParamCreator(configuration).cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save page.
         * @param {string} id
         * @param {CmsPageRepositoryV1SavePutBody} [cmsPageRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1SavePut(id: string, cmsPageRepositoryV1SavePutBody?: CmsPageRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CmsDataPageInterface> {
            const localVarFetchArgs = CmsPageRepositoryV1ApiFetchParamCreator(configuration).cmsPageRepositoryV1SavePut(id, cmsPageRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CmsPageRepositoryV1Api - factory interface
 * @export
 */
export const CmsPageRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete page by ID.
         * @param {number} pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1DeleteByIdDelete(pageId: number, options?: any) {
            return CmsPageRepositoryV1ApiFp(configuration).cmsPageRepositoryV1DeleteByIdDelete(pageId, options)(fetch, basePath);
        },
        /**
         * Retrieve page.
         * @param {number} pageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1GetByIdGet(pageId: number, options?: any) {
            return CmsPageRepositoryV1ApiFp(configuration).cmsPageRepositoryV1GetByIdGet(pageId, options)(fetch, basePath);
        },
        /**
         * Retrieve pages matching the specified criteria.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CmsPageRepositoryV1ApiFp(configuration).cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save page.
         * @param {CmsPageRepositoryV1SavePostBody} [cmsPageRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody?: CmsPageRepositoryV1SavePostBody, options?: any) {
            return CmsPageRepositoryV1ApiFp(configuration).cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save page.
         * @param {string} id
         * @param {CmsPageRepositoryV1SavePutBody} [cmsPageRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmsPageRepositoryV1SavePut(id: string, cmsPageRepositoryV1SavePutBody?: CmsPageRepositoryV1SavePutBody, options?: any) {
            return CmsPageRepositoryV1ApiFp(configuration).cmsPageRepositoryV1SavePut(id, cmsPageRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CmsPageRepositoryV1Api - object-oriented interface
 * @export
 * @class CmsPageRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CmsPageRepositoryV1Api extends BaseAPI {
    /**
     * Delete page by ID.
     * @param {number} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsPageRepositoryV1Api
     */
    public cmsPageRepositoryV1DeleteByIdDelete(pageId: number, options?: any) {
        return CmsPageRepositoryV1ApiFp(this.configuration).cmsPageRepositoryV1DeleteByIdDelete(pageId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve page.
     * @param {number} pageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsPageRepositoryV1Api
     */
    public cmsPageRepositoryV1GetByIdGet(pageId: number, options?: any) {
        return CmsPageRepositoryV1ApiFp(this.configuration).cmsPageRepositoryV1GetByIdGet(pageId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve pages matching the specified criteria.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsPageRepositoryV1Api
     */
    public cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CmsPageRepositoryV1ApiFp(this.configuration).cmsPageRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save page.
     * @param {CmsPageRepositoryV1SavePostBody} [cmsPageRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsPageRepositoryV1Api
     */
    public cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody?: CmsPageRepositoryV1SavePostBody, options?: any) {
        return CmsPageRepositoryV1ApiFp(this.configuration).cmsPageRepositoryV1SavePost(cmsPageRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save page.
     * @param {string} id
     * @param {CmsPageRepositoryV1SavePutBody} [cmsPageRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CmsPageRepositoryV1Api
     */
    public cmsPageRepositoryV1SavePut(id: string, cmsPageRepositoryV1SavePutBody?: CmsPageRepositoryV1SavePutBody, options?: any) {
        return CmsPageRepositoryV1ApiFp(this.configuration).cmsPageRepositoryV1SavePut(id, cmsPageRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyAclV1Api - fetch parameter creator
 * @export
 */
export const CompanyAclV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change a role for a company user.
         * @param {CompanyAclV1AssignRolesPutBody} [companyAclV1AssignRolesPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody?: CompanyAclV1AssignRolesPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/company/assignRoles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyAclV1AssignRolesPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyAclV1AssignRolesPutBody || {}) : (companyAclV1AssignRolesPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the list of company users assigned to a specified role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAclV1GetUsersByRoleIdGet(roleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling companyAclV1GetUsersByRoleIdGet.');
            }
            const localVarPath = `/V1/company/role/{roleId}/users`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyAclV1Api - functional programming interface
 * @export
 */
export const CompanyAclV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Change a role for a company user.
         * @param {CompanyAclV1AssignRolesPutBody} [companyAclV1AssignRolesPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody?: CompanyAclV1AssignRolesPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyAclV1ApiFetchParamCreator(configuration).companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View the list of company users assigned to a specified role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAclV1GetUsersByRoleIdGet(roleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataCustomerInterface>> {
            const localVarFetchArgs = CompanyAclV1ApiFetchParamCreator(configuration).companyAclV1GetUsersByRoleIdGet(roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyAclV1Api - factory interface
 * @export
 */
export const CompanyAclV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Change a role for a company user.
         * @param {CompanyAclV1AssignRolesPutBody} [companyAclV1AssignRolesPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody?: CompanyAclV1AssignRolesPutBody, options?: any) {
            return CompanyAclV1ApiFp(configuration).companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody, options)(fetch, basePath);
        },
        /**
         * View the list of company users assigned to a specified role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAclV1GetUsersByRoleIdGet(roleId: number, options?: any) {
            return CompanyAclV1ApiFp(configuration).companyAclV1GetUsersByRoleIdGet(roleId, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyAclV1Api - object-oriented interface
 * @export
 * @class CompanyAclV1Api
 * @extends {BaseAPI}
 */
export class CompanyAclV1Api extends BaseAPI {
    /**
     * Change a role for a company user.
     * @param {CompanyAclV1AssignRolesPutBody} [companyAclV1AssignRolesPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyAclV1Api
     */
    public companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody?: CompanyAclV1AssignRolesPutBody, options?: any) {
        return CompanyAclV1ApiFp(this.configuration).companyAclV1AssignRolesPut(companyAclV1AssignRolesPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * View the list of company users assigned to a specified role.
     * @param {number} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyAclV1Api
     */
    public companyAclV1GetUsersByRoleIdGet(roleId: number, options?: any) {
        return CompanyAclV1ApiFp(this.configuration).companyAclV1GetUsersByRoleIdGet(roleId, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyCompanyHierarchyV1Api - fetch parameter creator
 * @export
 */
export const CompanyCompanyHierarchyV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of teams and company users in the company structure.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyHierarchyV1GetCompanyHierarchyGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling companyCompanyHierarchyV1GetCompanyHierarchyGet.');
            }
            const localVarPath = `/V1/hierarchy/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves teams and users within the company structure.
         * @param {number} id
         * @param {CompanyCompanyHierarchyV1MoveNodePutBody} [companyCompanyHierarchyV1MoveNodePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyHierarchyV1MoveNodePut(id: number, companyCompanyHierarchyV1MoveNodePutBody?: CompanyCompanyHierarchyV1MoveNodePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling companyCompanyHierarchyV1MoveNodePut.');
            }
            const localVarPath = `/V1/hierarchy/move/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCompanyHierarchyV1MoveNodePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCompanyHierarchyV1MoveNodePutBody || {}) : (companyCompanyHierarchyV1MoveNodePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCompanyHierarchyV1Api - functional programming interface
 * @export
 */
export const CompanyCompanyHierarchyV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the list of teams and company users in the company structure.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyHierarchyV1GetCompanyHierarchyGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CompanyDataHierarchyInterface>> {
            const localVarFetchArgs = CompanyCompanyHierarchyV1ApiFetchParamCreator(configuration).companyCompanyHierarchyV1GetCompanyHierarchyGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Moves teams and users within the company structure.
         * @param {number} id
         * @param {CompanyCompanyHierarchyV1MoveNodePutBody} [companyCompanyHierarchyV1MoveNodePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyHierarchyV1MoveNodePut(id: number, companyCompanyHierarchyV1MoveNodePutBody?: CompanyCompanyHierarchyV1MoveNodePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ErrorResponse> {
            const localVarFetchArgs = CompanyCompanyHierarchyV1ApiFetchParamCreator(configuration).companyCompanyHierarchyV1MoveNodePut(id, companyCompanyHierarchyV1MoveNodePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyCompanyHierarchyV1Api - factory interface
 * @export
 */
export const CompanyCompanyHierarchyV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the list of teams and company users in the company structure.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyHierarchyV1GetCompanyHierarchyGet(id: number, options?: any) {
            return CompanyCompanyHierarchyV1ApiFp(configuration).companyCompanyHierarchyV1GetCompanyHierarchyGet(id, options)(fetch, basePath);
        },
        /**
         * Moves teams and users within the company structure.
         * @param {number} id
         * @param {CompanyCompanyHierarchyV1MoveNodePutBody} [companyCompanyHierarchyV1MoveNodePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyHierarchyV1MoveNodePut(id: number, companyCompanyHierarchyV1MoveNodePutBody?: CompanyCompanyHierarchyV1MoveNodePutBody, options?: any) {
            return CompanyCompanyHierarchyV1ApiFp(configuration).companyCompanyHierarchyV1MoveNodePut(id, companyCompanyHierarchyV1MoveNodePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyCompanyHierarchyV1Api - object-oriented interface
 * @export
 * @class CompanyCompanyHierarchyV1Api
 * @extends {BaseAPI}
 */
export class CompanyCompanyHierarchyV1Api extends BaseAPI {
    /**
     * Returns the list of teams and company users in the company structure.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyHierarchyV1Api
     */
    public companyCompanyHierarchyV1GetCompanyHierarchyGet(id: number, options?: any) {
        return CompanyCompanyHierarchyV1ApiFp(this.configuration).companyCompanyHierarchyV1GetCompanyHierarchyGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Moves teams and users within the company structure.
     * @param {number} id
     * @param {CompanyCompanyHierarchyV1MoveNodePutBody} [companyCompanyHierarchyV1MoveNodePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyHierarchyV1Api
     */
    public companyCompanyHierarchyV1MoveNodePut(id: number, companyCompanyHierarchyV1MoveNodePutBody?: CompanyCompanyHierarchyV1MoveNodePutBody, options?: any) {
        return CompanyCompanyHierarchyV1ApiFp(this.configuration).companyCompanyHierarchyV1MoveNodePut(id, companyCompanyHierarchyV1MoveNodePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyCompanyRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CompanyCompanyRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a company. Customers belonging to a company are not deleted with this request.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1DeleteByIdDelete(companyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new RequiredError('companyId','Required parameter companyId was null or undefined when calling companyCompanyRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/company/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns company details.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1GetGet(companyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new RequiredError('companyId','Required parameter companyId was null or undefined when calling companyCompanyRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/company/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of companies. The list is an array of objects, and detailed information about item attributes might not be included.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/company/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a company account.
         * @param {CompanyCompanyRepositoryV1SavePostBody} [companyCompanyRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody?: CompanyCompanyRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/company/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCompanyRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCompanyRepositoryV1SavePostBody || {}) : (companyCompanyRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a company account.
         * @param {string} companyId
         * @param {CompanyCompanyRepositoryV1SavePutBody} [companyCompanyRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1SavePut(companyId: string, companyCompanyRepositoryV1SavePutBody?: CompanyCompanyRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new RequiredError('companyId','Required parameter companyId was null or undefined when calling companyCompanyRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/company/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCompanyRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCompanyRepositoryV1SavePutBody || {}) : (companyCompanyRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCompanyRepositoryV1Api - functional programming interface
 * @export
 */
export const CompanyCompanyRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a company. Customers belonging to a company are not deleted with this request.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1DeleteByIdDelete(companyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyCompanyRepositoryV1ApiFetchParamCreator(configuration).companyCompanyRepositoryV1DeleteByIdDelete(companyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns company details.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1GetGet(companyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataCompanyInterface> {
            const localVarFetchArgs = CompanyCompanyRepositoryV1ApiFetchParamCreator(configuration).companyCompanyRepositoryV1GetGet(companyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of companies. The list is an array of objects, and detailed information about item attributes might not be included.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataCompanySearchResultsInterface> {
            const localVarFetchArgs = CompanyCompanyRepositoryV1ApiFetchParamCreator(configuration).companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update a company account.
         * @param {CompanyCompanyRepositoryV1SavePostBody} [companyCompanyRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody?: CompanyCompanyRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataCompanyInterface> {
            const localVarFetchArgs = CompanyCompanyRepositoryV1ApiFetchParamCreator(configuration).companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update a company account.
         * @param {string} companyId
         * @param {CompanyCompanyRepositoryV1SavePutBody} [companyCompanyRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1SavePut(companyId: string, companyCompanyRepositoryV1SavePutBody?: CompanyCompanyRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataCompanyInterface> {
            const localVarFetchArgs = CompanyCompanyRepositoryV1ApiFetchParamCreator(configuration).companyCompanyRepositoryV1SavePut(companyId, companyCompanyRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyCompanyRepositoryV1Api - factory interface
 * @export
 */
export const CompanyCompanyRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a company. Customers belonging to a company are not deleted with this request.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1DeleteByIdDelete(companyId: number, options?: any) {
            return CompanyCompanyRepositoryV1ApiFp(configuration).companyCompanyRepositoryV1DeleteByIdDelete(companyId, options)(fetch, basePath);
        },
        /**
         * Returns company details.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1GetGet(companyId: number, options?: any) {
            return CompanyCompanyRepositoryV1ApiFp(configuration).companyCompanyRepositoryV1GetGet(companyId, options)(fetch, basePath);
        },
        /**
         * Returns the list of companies. The list is an array of objects, and detailed information about item attributes might not be included.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CompanyCompanyRepositoryV1ApiFp(configuration).companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create or update a company account.
         * @param {CompanyCompanyRepositoryV1SavePostBody} [companyCompanyRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody?: CompanyCompanyRepositoryV1SavePostBody, options?: any) {
            return CompanyCompanyRepositoryV1ApiFp(configuration).companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create or update a company account.
         * @param {string} companyId
         * @param {CompanyCompanyRepositoryV1SavePutBody} [companyCompanyRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCompanyRepositoryV1SavePut(companyId: string, companyCompanyRepositoryV1SavePutBody?: CompanyCompanyRepositoryV1SavePutBody, options?: any) {
            return CompanyCompanyRepositoryV1ApiFp(configuration).companyCompanyRepositoryV1SavePut(companyId, companyCompanyRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyCompanyRepositoryV1Api - object-oriented interface
 * @export
 * @class CompanyCompanyRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CompanyCompanyRepositoryV1Api extends BaseAPI {
    /**
     * Delete a company. Customers belonging to a company are not deleted with this request.
     * @param {number} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyRepositoryV1Api
     */
    public companyCompanyRepositoryV1DeleteByIdDelete(companyId: number, options?: any) {
        return CompanyCompanyRepositoryV1ApiFp(this.configuration).companyCompanyRepositoryV1DeleteByIdDelete(companyId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns company details.
     * @param {number} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyRepositoryV1Api
     */
    public companyCompanyRepositoryV1GetGet(companyId: number, options?: any) {
        return CompanyCompanyRepositoryV1ApiFp(this.configuration).companyCompanyRepositoryV1GetGet(companyId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the list of companies. The list is an array of objects, and detailed information about item attributes might not be included.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyRepositoryV1Api
     */
    public companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CompanyCompanyRepositoryV1ApiFp(this.configuration).companyCompanyRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update a company account.
     * @param {CompanyCompanyRepositoryV1SavePostBody} [companyCompanyRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyRepositoryV1Api
     */
    public companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody?: CompanyCompanyRepositoryV1SavePostBody, options?: any) {
        return CompanyCompanyRepositoryV1ApiFp(this.configuration).companyCompanyRepositoryV1SavePost(companyCompanyRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update a company account.
     * @param {string} companyId
     * @param {CompanyCompanyRepositoryV1SavePutBody} [companyCompanyRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCompanyRepositoryV1Api
     */
    public companyCompanyRepositoryV1SavePut(companyId: string, companyCompanyRepositoryV1SavePutBody?: CompanyCompanyRepositoryV1SavePutBody, options?: any) {
        return CompanyCompanyRepositoryV1ApiFp(this.configuration).companyCompanyRepositoryV1SavePut(companyId, companyCompanyRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyCreditCreditBalanceManagementV1Api - fetch parameter creator
 * @export
 */
export const CompanyCreditCreditBalanceManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Decreases the company credit with an Update, Reimburse, or Purchase transaction. This transaction increases company's outstanding balance and decreases company's available credit.
         * @param {number} creditId
         * @param {CompanyCreditCreditBalanceManagementV1DecreasePostBody} [companyCreditCreditBalanceManagementV1DecreasePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditBalanceManagementV1DecreasePost(creditId: number, companyCreditCreditBalanceManagementV1DecreasePostBody?: CompanyCreditCreditBalanceManagementV1DecreasePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'creditId' is not null or undefined
            if (creditId === null || creditId === undefined) {
                throw new RequiredError('creditId','Required parameter creditId was null or undefined when calling companyCreditCreditBalanceManagementV1DecreasePost.');
            }
            const localVarPath = `/V1/companyCredits/{creditId}/decreaseBalance`
                .replace(`{${"creditId"}}`, encodeURIComponent(String(creditId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCreditCreditBalanceManagementV1DecreasePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCreditCreditBalanceManagementV1DecreasePostBody || {}) : (companyCreditCreditBalanceManagementV1DecreasePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Increases the company credit with an Allocate, Update, Refund, Revert, or Reimburse transaction. This transaction decreases company's outstanding balance and increases company's available credit.
         * @param {number} creditId
         * @param {CompanyCreditCreditBalanceManagementV1IncreasePostBody} [companyCreditCreditBalanceManagementV1IncreasePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditBalanceManagementV1IncreasePost(creditId: number, companyCreditCreditBalanceManagementV1IncreasePostBody?: CompanyCreditCreditBalanceManagementV1IncreasePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'creditId' is not null or undefined
            if (creditId === null || creditId === undefined) {
                throw new RequiredError('creditId','Required parameter creditId was null or undefined when calling companyCreditCreditBalanceManagementV1IncreasePost.');
            }
            const localVarPath = `/V1/companyCredits/{creditId}/increaseBalance`
                .replace(`{${"creditId"}}`, encodeURIComponent(String(creditId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCreditCreditBalanceManagementV1IncreasePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCreditCreditBalanceManagementV1IncreasePostBody || {}) : (companyCreditCreditBalanceManagementV1IncreasePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCreditCreditBalanceManagementV1Api - functional programming interface
 * @export
 */
export const CompanyCreditCreditBalanceManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Decreases the company credit with an Update, Reimburse, or Purchase transaction. This transaction increases company's outstanding balance and decreases company's available credit.
         * @param {number} creditId
         * @param {CompanyCreditCreditBalanceManagementV1DecreasePostBody} [companyCreditCreditBalanceManagementV1DecreasePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditBalanceManagementV1DecreasePost(creditId: number, companyCreditCreditBalanceManagementV1DecreasePostBody?: CompanyCreditCreditBalanceManagementV1DecreasePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyCreditCreditBalanceManagementV1ApiFetchParamCreator(configuration).companyCreditCreditBalanceManagementV1DecreasePost(creditId, companyCreditCreditBalanceManagementV1DecreasePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Increases the company credit with an Allocate, Update, Refund, Revert, or Reimburse transaction. This transaction decreases company's outstanding balance and increases company's available credit.
         * @param {number} creditId
         * @param {CompanyCreditCreditBalanceManagementV1IncreasePostBody} [companyCreditCreditBalanceManagementV1IncreasePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditBalanceManagementV1IncreasePost(creditId: number, companyCreditCreditBalanceManagementV1IncreasePostBody?: CompanyCreditCreditBalanceManagementV1IncreasePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyCreditCreditBalanceManagementV1ApiFetchParamCreator(configuration).companyCreditCreditBalanceManagementV1IncreasePost(creditId, companyCreditCreditBalanceManagementV1IncreasePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyCreditCreditBalanceManagementV1Api - factory interface
 * @export
 */
export const CompanyCreditCreditBalanceManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Decreases the company credit with an Update, Reimburse, or Purchase transaction. This transaction increases company's outstanding balance and decreases company's available credit.
         * @param {number} creditId
         * @param {CompanyCreditCreditBalanceManagementV1DecreasePostBody} [companyCreditCreditBalanceManagementV1DecreasePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditBalanceManagementV1DecreasePost(creditId: number, companyCreditCreditBalanceManagementV1DecreasePostBody?: CompanyCreditCreditBalanceManagementV1DecreasePostBody, options?: any) {
            return CompanyCreditCreditBalanceManagementV1ApiFp(configuration).companyCreditCreditBalanceManagementV1DecreasePost(creditId, companyCreditCreditBalanceManagementV1DecreasePostBody, options)(fetch, basePath);
        },
        /**
         * Increases the company credit with an Allocate, Update, Refund, Revert, or Reimburse transaction. This transaction decreases company's outstanding balance and increases company's available credit.
         * @param {number} creditId
         * @param {CompanyCreditCreditBalanceManagementV1IncreasePostBody} [companyCreditCreditBalanceManagementV1IncreasePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditBalanceManagementV1IncreasePost(creditId: number, companyCreditCreditBalanceManagementV1IncreasePostBody?: CompanyCreditCreditBalanceManagementV1IncreasePostBody, options?: any) {
            return CompanyCreditCreditBalanceManagementV1ApiFp(configuration).companyCreditCreditBalanceManagementV1IncreasePost(creditId, companyCreditCreditBalanceManagementV1IncreasePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyCreditCreditBalanceManagementV1Api - object-oriented interface
 * @export
 * @class CompanyCreditCreditBalanceManagementV1Api
 * @extends {BaseAPI}
 */
export class CompanyCreditCreditBalanceManagementV1Api extends BaseAPI {
    /**
     * Decreases the company credit with an Update, Reimburse, or Purchase transaction. This transaction increases company's outstanding balance and decreases company's available credit.
     * @param {number} creditId
     * @param {CompanyCreditCreditBalanceManagementV1DecreasePostBody} [companyCreditCreditBalanceManagementV1DecreasePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditBalanceManagementV1Api
     */
    public companyCreditCreditBalanceManagementV1DecreasePost(creditId: number, companyCreditCreditBalanceManagementV1DecreasePostBody?: CompanyCreditCreditBalanceManagementV1DecreasePostBody, options?: any) {
        return CompanyCreditCreditBalanceManagementV1ApiFp(this.configuration).companyCreditCreditBalanceManagementV1DecreasePost(creditId, companyCreditCreditBalanceManagementV1DecreasePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Increases the company credit with an Allocate, Update, Refund, Revert, or Reimburse transaction. This transaction decreases company's outstanding balance and increases company's available credit.
     * @param {number} creditId
     * @param {CompanyCreditCreditBalanceManagementV1IncreasePostBody} [companyCreditCreditBalanceManagementV1IncreasePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditBalanceManagementV1Api
     */
    public companyCreditCreditBalanceManagementV1IncreasePost(creditId: number, companyCreditCreditBalanceManagementV1IncreasePostBody?: CompanyCreditCreditBalanceManagementV1IncreasePostBody, options?: any) {
        return CompanyCreditCreditBalanceManagementV1ApiFp(this.configuration).companyCreditCreditBalanceManagementV1IncreasePost(creditId, companyCreditCreditBalanceManagementV1IncreasePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyCreditCreditHistoryManagementV1Api - fetch parameter creator
 * @export
 */
export const CompanyCreditCreditHistoryManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the credit history for one or more companies.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/companyCredits/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the PO Number and/or comment for a Reimburse transaction.
         * @param {number} historyId
         * @param {CompanyCreditCreditHistoryManagementV1UpdatePutBody} [companyCreditCreditHistoryManagementV1UpdatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditHistoryManagementV1UpdatePut(historyId: number, companyCreditCreditHistoryManagementV1UpdatePutBody?: CompanyCreditCreditHistoryManagementV1UpdatePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'historyId' is not null or undefined
            if (historyId === null || historyId === undefined) {
                throw new RequiredError('historyId','Required parameter historyId was null or undefined when calling companyCreditCreditHistoryManagementV1UpdatePut.');
            }
            const localVarPath = `/V1/companyCredits/history/{historyId}`
                .replace(`{${"historyId"}}`, encodeURIComponent(String(historyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCreditCreditHistoryManagementV1UpdatePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCreditCreditHistoryManagementV1UpdatePutBody || {}) : (companyCreditCreditHistoryManagementV1UpdatePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCreditCreditHistoryManagementV1Api - functional programming interface
 * @export
 */
export const CompanyCreditCreditHistoryManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the credit history for one or more companies.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyCreditDataHistorySearchResultsInterface> {
            const localVarFetchArgs = CompanyCreditCreditHistoryManagementV1ApiFetchParamCreator(configuration).companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the PO Number and/or comment for a Reimburse transaction.
         * @param {number} historyId
         * @param {CompanyCreditCreditHistoryManagementV1UpdatePutBody} [companyCreditCreditHistoryManagementV1UpdatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditHistoryManagementV1UpdatePut(historyId: number, companyCreditCreditHistoryManagementV1UpdatePutBody?: CompanyCreditCreditHistoryManagementV1UpdatePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyCreditCreditHistoryManagementV1ApiFetchParamCreator(configuration).companyCreditCreditHistoryManagementV1UpdatePut(historyId, companyCreditCreditHistoryManagementV1UpdatePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyCreditCreditHistoryManagementV1Api - factory interface
 * @export
 */
export const CompanyCreditCreditHistoryManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the credit history for one or more companies.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CompanyCreditCreditHistoryManagementV1ApiFp(configuration).companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Update the PO Number and/or comment for a Reimburse transaction.
         * @param {number} historyId
         * @param {CompanyCreditCreditHistoryManagementV1UpdatePutBody} [companyCreditCreditHistoryManagementV1UpdatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditHistoryManagementV1UpdatePut(historyId: number, companyCreditCreditHistoryManagementV1UpdatePutBody?: CompanyCreditCreditHistoryManagementV1UpdatePutBody, options?: any) {
            return CompanyCreditCreditHistoryManagementV1ApiFp(configuration).companyCreditCreditHistoryManagementV1UpdatePut(historyId, companyCreditCreditHistoryManagementV1UpdatePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyCreditCreditHistoryManagementV1Api - object-oriented interface
 * @export
 * @class CompanyCreditCreditHistoryManagementV1Api
 * @extends {BaseAPI}
 */
export class CompanyCreditCreditHistoryManagementV1Api extends BaseAPI {
    /**
     * Returns the credit history for one or more companies.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditHistoryManagementV1Api
     */
    public companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CompanyCreditCreditHistoryManagementV1ApiFp(this.configuration).companyCreditCreditHistoryManagementV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Update the PO Number and/or comment for a Reimburse transaction.
     * @param {number} historyId
     * @param {CompanyCreditCreditHistoryManagementV1UpdatePutBody} [companyCreditCreditHistoryManagementV1UpdatePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditHistoryManagementV1Api
     */
    public companyCreditCreditHistoryManagementV1UpdatePut(historyId: number, companyCreditCreditHistoryManagementV1UpdatePutBody?: CompanyCreditCreditHistoryManagementV1UpdatePutBody, options?: any) {
        return CompanyCreditCreditHistoryManagementV1ApiFp(this.configuration).companyCreditCreditHistoryManagementV1UpdatePut(historyId, companyCreditCreditHistoryManagementV1UpdatePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyCreditCreditLimitManagementV1Api - fetch parameter creator
 * @export
 */
export const CompanyCreditCreditLimitManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data on the credit limit for a specified company.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new RequiredError('companyId','Required parameter companyId was null or undefined when calling companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet.');
            }
            const localVarPath = `/V1/companyCredits/company/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCreditCreditLimitManagementV1Api - functional programming interface
 * @export
 */
export const CompanyCreditCreditLimitManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns data on the credit limit for a specified company.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyCreditDataCreditLimitInterface> {
            const localVarFetchArgs = CompanyCreditCreditLimitManagementV1ApiFetchParamCreator(configuration).companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyCreditCreditLimitManagementV1Api - factory interface
 * @export
 */
export const CompanyCreditCreditLimitManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns data on the credit limit for a specified company.
         * @param {number} companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId: number, options?: any) {
            return CompanyCreditCreditLimitManagementV1ApiFp(configuration).companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyCreditCreditLimitManagementV1Api - object-oriented interface
 * @export
 * @class CompanyCreditCreditLimitManagementV1Api
 * @extends {BaseAPI}
 */
export class CompanyCreditCreditLimitManagementV1Api extends BaseAPI {
    /**
     * Returns data on the credit limit for a specified company.
     * @param {number} companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditLimitManagementV1Api
     */
    public companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId: number, options?: any) {
        return CompanyCreditCreditLimitManagementV1ApiFp(this.configuration).companyCreditCreditLimitManagementV1GetCreditByCompanyIdGet(companyId, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyCreditCreditLimitRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CompanyCreditCreditLimitRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data on the credit limit for a specified credit limit ID.
         * @param {number} creditId
         * @param {boolean} [reload] [optional]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1GetGet(creditId: number, reload?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'creditId' is not null or undefined
            if (creditId === null || creditId === undefined) {
                throw new RequiredError('creditId','Required parameter creditId was null or undefined when calling companyCreditCreditLimitRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/companyCredits/{creditId}`
                .replace(`{${"creditId"}}`, encodeURIComponent(String(creditId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reload !== undefined) {
                localVarQueryParameter['reload'] = reload;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of credits for specified companies.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/companyCredits/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the following company credit attributes: credit currency, credit limit and setting to exceed credit.
         * @param {string} id
         * @param {CompanyCreditCreditLimitRepositoryV1SavePutBody} [companyCreditCreditLimitRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1SavePut(id: string, companyCreditCreditLimitRepositoryV1SavePutBody?: CompanyCreditCreditLimitRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling companyCreditCreditLimitRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/companyCredits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyCreditCreditLimitRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyCreditCreditLimitRepositoryV1SavePutBody || {}) : (companyCreditCreditLimitRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyCreditCreditLimitRepositoryV1Api - functional programming interface
 * @export
 */
export const CompanyCreditCreditLimitRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns data on the credit limit for a specified credit limit ID.
         * @param {number} creditId
         * @param {boolean} [reload] [optional]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1GetGet(creditId: number, reload?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyCreditDataCreditLimitInterface> {
            const localVarFetchArgs = CompanyCreditCreditLimitRepositoryV1ApiFetchParamCreator(configuration).companyCreditCreditLimitRepositoryV1GetGet(creditId, reload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of credits for specified companies.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyCreditDataCreditLimitSearchResultsInterface> {
            const localVarFetchArgs = CompanyCreditCreditLimitRepositoryV1ApiFetchParamCreator(configuration).companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the following company credit attributes: credit currency, credit limit and setting to exceed credit.
         * @param {string} id
         * @param {CompanyCreditCreditLimitRepositoryV1SavePutBody} [companyCreditCreditLimitRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1SavePut(id: string, companyCreditCreditLimitRepositoryV1SavePutBody?: CompanyCreditCreditLimitRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyCreditDataCreditLimitInterface> {
            const localVarFetchArgs = CompanyCreditCreditLimitRepositoryV1ApiFetchParamCreator(configuration).companyCreditCreditLimitRepositoryV1SavePut(id, companyCreditCreditLimitRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyCreditCreditLimitRepositoryV1Api - factory interface
 * @export
 */
export const CompanyCreditCreditLimitRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns data on the credit limit for a specified credit limit ID.
         * @param {number} creditId
         * @param {boolean} [reload] [optional]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1GetGet(creditId: number, reload?: boolean, options?: any) {
            return CompanyCreditCreditLimitRepositoryV1ApiFp(configuration).companyCreditCreditLimitRepositoryV1GetGet(creditId, reload, options)(fetch, basePath);
        },
        /**
         * Returns the list of credits for specified companies.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CompanyCreditCreditLimitRepositoryV1ApiFp(configuration).companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Update the following company credit attributes: credit currency, credit limit and setting to exceed credit.
         * @param {string} id
         * @param {CompanyCreditCreditLimitRepositoryV1SavePutBody} [companyCreditCreditLimitRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyCreditCreditLimitRepositoryV1SavePut(id: string, companyCreditCreditLimitRepositoryV1SavePutBody?: CompanyCreditCreditLimitRepositoryV1SavePutBody, options?: any) {
            return CompanyCreditCreditLimitRepositoryV1ApiFp(configuration).companyCreditCreditLimitRepositoryV1SavePut(id, companyCreditCreditLimitRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyCreditCreditLimitRepositoryV1Api - object-oriented interface
 * @export
 * @class CompanyCreditCreditLimitRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CompanyCreditCreditLimitRepositoryV1Api extends BaseAPI {
    /**
     * Returns data on the credit limit for a specified credit limit ID.
     * @param {number} creditId
     * @param {boolean} [reload] [optional]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditLimitRepositoryV1Api
     */
    public companyCreditCreditLimitRepositoryV1GetGet(creditId: number, reload?: boolean, options?: any) {
        return CompanyCreditCreditLimitRepositoryV1ApiFp(this.configuration).companyCreditCreditLimitRepositoryV1GetGet(creditId, reload, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the list of credits for specified companies.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditLimitRepositoryV1Api
     */
    public companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CompanyCreditCreditLimitRepositoryV1ApiFp(this.configuration).companyCreditCreditLimitRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Update the following company credit attributes: credit currency, credit limit and setting to exceed credit.
     * @param {string} id
     * @param {CompanyCreditCreditLimitRepositoryV1SavePutBody} [companyCreditCreditLimitRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyCreditCreditLimitRepositoryV1Api
     */
    public companyCreditCreditLimitRepositoryV1SavePut(id: string, companyCreditCreditLimitRepositoryV1SavePutBody?: CompanyCreditCreditLimitRepositoryV1SavePutBody, options?: any) {
        return CompanyCreditCreditLimitRepositoryV1ApiFp(this.configuration).companyCreditCreditLimitRepositoryV1SavePut(id, companyCreditCreditLimitRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyRoleRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CompanyRoleRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1DeleteDelete(roleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling companyRoleRepositoryV1DeleteDelete.');
            }
            const localVarPath = `/V1/company/role/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of permissions for a specified role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1GetGet(roleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling companyRoleRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/company/role/{roleId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of roles and permissions for a specified company.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/company/role/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a role for a selected company.
         * @param {CompanyRoleRepositoryV1SavePostBody} [companyRoleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody?: CompanyRoleRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/company/role/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyRoleRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyRoleRepositoryV1SavePostBody || {}) : (companyRoleRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a role for a selected company.
         * @param {string} id
         * @param {CompanyRoleRepositoryV1SavePutBody} [companyRoleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1SavePut(id: string, companyRoleRepositoryV1SavePutBody?: CompanyRoleRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling companyRoleRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/company/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyRoleRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyRoleRepositoryV1SavePutBody || {}) : (companyRoleRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyRoleRepositoryV1Api - functional programming interface
 * @export
 */
export const CompanyRoleRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1DeleteDelete(roleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyRoleRepositoryV1ApiFetchParamCreator(configuration).companyRoleRepositoryV1DeleteDelete(roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of permissions for a specified role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1GetGet(roleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataRoleInterface> {
            const localVarFetchArgs = CompanyRoleRepositoryV1ApiFetchParamCreator(configuration).companyRoleRepositoryV1GetGet(roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of roles and permissions for a specified company.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataRoleSearchResultsInterface> {
            const localVarFetchArgs = CompanyRoleRepositoryV1ApiFetchParamCreator(configuration).companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update a role for a selected company.
         * @param {CompanyRoleRepositoryV1SavePostBody} [companyRoleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody?: CompanyRoleRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataRoleInterface> {
            const localVarFetchArgs = CompanyRoleRepositoryV1ApiFetchParamCreator(configuration).companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update a role for a selected company.
         * @param {string} id
         * @param {CompanyRoleRepositoryV1SavePutBody} [companyRoleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1SavePut(id: string, companyRoleRepositoryV1SavePutBody?: CompanyRoleRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataRoleInterface> {
            const localVarFetchArgs = CompanyRoleRepositoryV1ApiFetchParamCreator(configuration).companyRoleRepositoryV1SavePut(id, companyRoleRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyRoleRepositoryV1Api - factory interface
 * @export
 */
export const CompanyRoleRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1DeleteDelete(roleId: number, options?: any) {
            return CompanyRoleRepositoryV1ApiFp(configuration).companyRoleRepositoryV1DeleteDelete(roleId, options)(fetch, basePath);
        },
        /**
         * Returns the list of permissions for a specified role.
         * @param {number} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1GetGet(roleId: number, options?: any) {
            return CompanyRoleRepositoryV1ApiFp(configuration).companyRoleRepositoryV1GetGet(roleId, options)(fetch, basePath);
        },
        /**
         * Returns the list of roles and permissions for a specified company.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CompanyRoleRepositoryV1ApiFp(configuration).companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create or update a role for a selected company.
         * @param {CompanyRoleRepositoryV1SavePostBody} [companyRoleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody?: CompanyRoleRepositoryV1SavePostBody, options?: any) {
            return CompanyRoleRepositoryV1ApiFp(configuration).companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create or update a role for a selected company.
         * @param {string} id
         * @param {CompanyRoleRepositoryV1SavePutBody} [companyRoleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyRoleRepositoryV1SavePut(id: string, companyRoleRepositoryV1SavePutBody?: CompanyRoleRepositoryV1SavePutBody, options?: any) {
            return CompanyRoleRepositoryV1ApiFp(configuration).companyRoleRepositoryV1SavePut(id, companyRoleRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyRoleRepositoryV1Api - object-oriented interface
 * @export
 * @class CompanyRoleRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CompanyRoleRepositoryV1Api extends BaseAPI {
    /**
     * Delete a role.
     * @param {number} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyRoleRepositoryV1Api
     */
    public companyRoleRepositoryV1DeleteDelete(roleId: number, options?: any) {
        return CompanyRoleRepositoryV1ApiFp(this.configuration).companyRoleRepositoryV1DeleteDelete(roleId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the list of permissions for a specified role.
     * @param {number} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyRoleRepositoryV1Api
     */
    public companyRoleRepositoryV1GetGet(roleId: number, options?: any) {
        return CompanyRoleRepositoryV1ApiFp(this.configuration).companyRoleRepositoryV1GetGet(roleId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the list of roles and permissions for a specified company.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyRoleRepositoryV1Api
     */
    public companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CompanyRoleRepositoryV1ApiFp(this.configuration).companyRoleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update a role for a selected company.
     * @param {CompanyRoleRepositoryV1SavePostBody} [companyRoleRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyRoleRepositoryV1Api
     */
    public companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody?: CompanyRoleRepositoryV1SavePostBody, options?: any) {
        return CompanyRoleRepositoryV1ApiFp(this.configuration).companyRoleRepositoryV1SavePost(companyRoleRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update a role for a selected company.
     * @param {string} id
     * @param {CompanyRoleRepositoryV1SavePutBody} [companyRoleRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyRoleRepositoryV1Api
     */
    public companyRoleRepositoryV1SavePut(id: string, companyRoleRepositoryV1SavePutBody?: CompanyRoleRepositoryV1SavePutBody, options?: any) {
        return CompanyRoleRepositoryV1ApiFp(this.configuration).companyRoleRepositoryV1SavePut(id, companyRoleRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CompanyTeamRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CompanyTeamRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a team in the company structure.
         * @param {number} companyId
         * @param {CompanyTeamRepositoryV1CreatePostBody} [companyTeamRepositoryV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1CreatePost(companyId: number, companyTeamRepositoryV1CreatePostBody?: CompanyTeamRepositoryV1CreatePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new RequiredError('companyId','Required parameter companyId was null or undefined when calling companyTeamRepositoryV1CreatePost.');
            }
            const localVarPath = `/V1/team/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyTeamRepositoryV1CreatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyTeamRepositoryV1CreatePostBody || {}) : (companyTeamRepositoryV1CreatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a team from the company structure.
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1DeleteByIdDelete(teamId: number, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling companyTeamRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data for a team in the company, by entity id.
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1GetGet(teamId: number, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling companyTeamRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of teams for the specified search criteria (team name or description).
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/team/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team in the company structure.
         * @param {string} teamId
         * @param {CompanyTeamRepositoryV1SavePutBody} [companyTeamRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1SavePut(teamId: string, companyTeamRepositoryV1SavePutBody?: CompanyTeamRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling companyTeamRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompanyTeamRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(companyTeamRepositoryV1SavePutBody || {}) : (companyTeamRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyTeamRepositoryV1Api - functional programming interface
 * @export
 */
export const CompanyTeamRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a team in the company structure.
         * @param {number} companyId
         * @param {CompanyTeamRepositoryV1CreatePostBody} [companyTeamRepositoryV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1CreatePost(companyId: number, companyTeamRepositoryV1CreatePostBody?: CompanyTeamRepositoryV1CreatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ErrorResponse> {
            const localVarFetchArgs = CompanyTeamRepositoryV1ApiFetchParamCreator(configuration).companyTeamRepositoryV1CreatePost(companyId, companyTeamRepositoryV1CreatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a team from the company structure.
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1DeleteByIdDelete(teamId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ErrorResponse> {
            const localVarFetchArgs = CompanyTeamRepositoryV1ApiFetchParamCreator(configuration).companyTeamRepositoryV1DeleteByIdDelete(teamId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data for a team in the company, by entity id.
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1GetGet(teamId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataTeamInterface> {
            const localVarFetchArgs = CompanyTeamRepositoryV1ApiFetchParamCreator(configuration).companyTeamRepositoryV1GetGet(teamId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of teams for the specified search criteria (team name or description).
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CompanyDataTeamSearchResultsInterface> {
            const localVarFetchArgs = CompanyTeamRepositoryV1ApiFetchParamCreator(configuration).companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a team in the company structure.
         * @param {string} teamId
         * @param {CompanyTeamRepositoryV1SavePutBody} [companyTeamRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1SavePut(teamId: string, companyTeamRepositoryV1SavePutBody?: CompanyTeamRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CompanyTeamRepositoryV1ApiFetchParamCreator(configuration).companyTeamRepositoryV1SavePut(teamId, companyTeamRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CompanyTeamRepositoryV1Api - factory interface
 * @export
 */
export const CompanyTeamRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a team in the company structure.
         * @param {number} companyId
         * @param {CompanyTeamRepositoryV1CreatePostBody} [companyTeamRepositoryV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1CreatePost(companyId: number, companyTeamRepositoryV1CreatePostBody?: CompanyTeamRepositoryV1CreatePostBody, options?: any) {
            return CompanyTeamRepositoryV1ApiFp(configuration).companyTeamRepositoryV1CreatePost(companyId, companyTeamRepositoryV1CreatePostBody, options)(fetch, basePath);
        },
        /**
         * Delete a team from the company structure.
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1DeleteByIdDelete(teamId: number, options?: any) {
            return CompanyTeamRepositoryV1ApiFp(configuration).companyTeamRepositoryV1DeleteByIdDelete(teamId, options)(fetch, basePath);
        },
        /**
         * Returns data for a team in the company, by entity id.
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1GetGet(teamId: number, options?: any) {
            return CompanyTeamRepositoryV1ApiFp(configuration).companyTeamRepositoryV1GetGet(teamId, options)(fetch, basePath);
        },
        /**
         * Returns the list of teams for the specified search criteria (team name or description).
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CompanyTeamRepositoryV1ApiFp(configuration).companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Update a team in the company structure.
         * @param {string} teamId
         * @param {CompanyTeamRepositoryV1SavePutBody} [companyTeamRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyTeamRepositoryV1SavePut(teamId: string, companyTeamRepositoryV1SavePutBody?: CompanyTeamRepositoryV1SavePutBody, options?: any) {
            return CompanyTeamRepositoryV1ApiFp(configuration).companyTeamRepositoryV1SavePut(teamId, companyTeamRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CompanyTeamRepositoryV1Api - object-oriented interface
 * @export
 * @class CompanyTeamRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CompanyTeamRepositoryV1Api extends BaseAPI {
    /**
     * Create a team in the company structure.
     * @param {number} companyId
     * @param {CompanyTeamRepositoryV1CreatePostBody} [companyTeamRepositoryV1CreatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyTeamRepositoryV1Api
     */
    public companyTeamRepositoryV1CreatePost(companyId: number, companyTeamRepositoryV1CreatePostBody?: CompanyTeamRepositoryV1CreatePostBody, options?: any) {
        return CompanyTeamRepositoryV1ApiFp(this.configuration).companyTeamRepositoryV1CreatePost(companyId, companyTeamRepositoryV1CreatePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a team from the company structure.
     * @param {number} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyTeamRepositoryV1Api
     */
    public companyTeamRepositoryV1DeleteByIdDelete(teamId: number, options?: any) {
        return CompanyTeamRepositoryV1ApiFp(this.configuration).companyTeamRepositoryV1DeleteByIdDelete(teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data for a team in the company, by entity id.
     * @param {number} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyTeamRepositoryV1Api
     */
    public companyTeamRepositoryV1GetGet(teamId: number, options?: any) {
        return CompanyTeamRepositoryV1ApiFp(this.configuration).companyTeamRepositoryV1GetGet(teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the list of teams for the specified search criteria (team name or description).
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyTeamRepositoryV1Api
     */
    public companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CompanyTeamRepositoryV1ApiFp(this.configuration).companyTeamRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Update a team in the company structure.
     * @param {string} teamId
     * @param {CompanyTeamRepositoryV1SavePutBody} [companyTeamRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyTeamRepositoryV1Api
     */
    public companyTeamRepositoryV1SavePut(teamId: string, companyTeamRepositoryV1SavePutBody?: CompanyTeamRepositoryV1SavePutBody, options?: any) {
        return CompanyTeamRepositoryV1ApiFp(this.configuration).companyTeamRepositoryV1SavePut(teamId, companyTeamRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigurableProductConfigurableProductManagementV1Api - fetch parameter creator
 * @export
 */
export const ConfigurableProductConfigurableProductManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate variation based on same product
         * @param {ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody} [configurableProductConfigurableProductManagementV1GenerateVariationPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody?: ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/configurable-products/variation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(configurableProductConfigurableProductManagementV1GenerateVariationPutBody || {}) : (configurableProductConfigurableProductManagementV1GenerateVariationPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurableProductConfigurableProductManagementV1Api - functional programming interface
 * @export
 */
export const ConfigurableProductConfigurableProductManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generate variation based on same product
         * @param {ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody} [configurableProductConfigurableProductManagementV1GenerateVariationPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody?: ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductInterface>> {
            const localVarFetchArgs = ConfigurableProductConfigurableProductManagementV1ApiFetchParamCreator(configuration).configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigurableProductConfigurableProductManagementV1Api - factory interface
 * @export
 */
export const ConfigurableProductConfigurableProductManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generate variation based on same product
         * @param {ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody} [configurableProductConfigurableProductManagementV1GenerateVariationPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody?: ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody, options?: any) {
            return ConfigurableProductConfigurableProductManagementV1ApiFp(configuration).configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigurableProductConfigurableProductManagementV1Api - object-oriented interface
 * @export
 * @class ConfigurableProductConfigurableProductManagementV1Api
 * @extends {BaseAPI}
 */
export class ConfigurableProductConfigurableProductManagementV1Api extends BaseAPI {
    /**
     * Generate variation based on same product
     * @param {ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody} [configurableProductConfigurableProductManagementV1GenerateVariationPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductConfigurableProductManagementV1Api
     */
    public configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody?: ConfigurableProductConfigurableProductManagementV1GenerateVariationPutBody, options?: any) {
        return ConfigurableProductConfigurableProductManagementV1ApiFp(this.configuration).configurableProductConfigurableProductManagementV1GenerateVariationPut(configurableProductConfigurableProductManagementV1GenerateVariationPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigurableProductLinkManagementV1Api - fetch parameter creator
 * @export
 */
export const ConfigurableProductLinkManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {ConfigurableProductLinkManagementV1AddChildPostBody} [configurableProductLinkManagementV1AddChildPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1AddChildPost(sku: string, configurableProductLinkManagementV1AddChildPostBody?: ConfigurableProductLinkManagementV1AddChildPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductLinkManagementV1AddChildPost.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/child`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfigurableProductLinkManagementV1AddChildPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(configurableProductLinkManagementV1AddChildPostBody || {}) : (configurableProductLinkManagementV1AddChildPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all children for Configurable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1GetChildrenGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductLinkManagementV1GetChildrenGet.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/children`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove configurable product option
         * @param {string} sku
         * @param {string} childSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1RemoveChildDelete(sku: string, childSku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductLinkManagementV1RemoveChildDelete.');
            }
            // verify required parameter 'childSku' is not null or undefined
            if (childSku === null || childSku === undefined) {
                throw new RequiredError('childSku','Required parameter childSku was null or undefined when calling configurableProductLinkManagementV1RemoveChildDelete.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/children/{childSku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"childSku"}}`, encodeURIComponent(String(childSku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurableProductLinkManagementV1Api - functional programming interface
 * @export
 */
export const ConfigurableProductLinkManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} sku
         * @param {ConfigurableProductLinkManagementV1AddChildPostBody} [configurableProductLinkManagementV1AddChildPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1AddChildPost(sku: string, configurableProductLinkManagementV1AddChildPostBody?: ConfigurableProductLinkManagementV1AddChildPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ConfigurableProductLinkManagementV1ApiFetchParamCreator(configuration).configurableProductLinkManagementV1AddChildPost(sku, configurableProductLinkManagementV1AddChildPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all children for Configurable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1GetChildrenGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatalogDataProductInterface>> {
            const localVarFetchArgs = ConfigurableProductLinkManagementV1ApiFetchParamCreator(configuration).configurableProductLinkManagementV1GetChildrenGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove configurable product option
         * @param {string} sku
         * @param {string} childSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1RemoveChildDelete(sku: string, childSku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ConfigurableProductLinkManagementV1ApiFetchParamCreator(configuration).configurableProductLinkManagementV1RemoveChildDelete(sku, childSku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigurableProductLinkManagementV1Api - factory interface
 * @export
 */
export const ConfigurableProductLinkManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} sku
         * @param {ConfigurableProductLinkManagementV1AddChildPostBody} [configurableProductLinkManagementV1AddChildPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1AddChildPost(sku: string, configurableProductLinkManagementV1AddChildPostBody?: ConfigurableProductLinkManagementV1AddChildPostBody, options?: any) {
            return ConfigurableProductLinkManagementV1ApiFp(configuration).configurableProductLinkManagementV1AddChildPost(sku, configurableProductLinkManagementV1AddChildPostBody, options)(fetch, basePath);
        },
        /**
         * Get all children for Configurable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1GetChildrenGet(sku: string, options?: any) {
            return ConfigurableProductLinkManagementV1ApiFp(configuration).configurableProductLinkManagementV1GetChildrenGet(sku, options)(fetch, basePath);
        },
        /**
         * Remove configurable product option
         * @param {string} sku
         * @param {string} childSku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductLinkManagementV1RemoveChildDelete(sku: string, childSku: string, options?: any) {
            return ConfigurableProductLinkManagementV1ApiFp(configuration).configurableProductLinkManagementV1RemoveChildDelete(sku, childSku, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigurableProductLinkManagementV1Api - object-oriented interface
 * @export
 * @class ConfigurableProductLinkManagementV1Api
 * @extends {BaseAPI}
 */
export class ConfigurableProductLinkManagementV1Api extends BaseAPI {
    /**
     *
     * @param {string} sku
     * @param {ConfigurableProductLinkManagementV1AddChildPostBody} [configurableProductLinkManagementV1AddChildPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductLinkManagementV1Api
     */
    public configurableProductLinkManagementV1AddChildPost(sku: string, configurableProductLinkManagementV1AddChildPostBody?: ConfigurableProductLinkManagementV1AddChildPostBody, options?: any) {
        return ConfigurableProductLinkManagementV1ApiFp(this.configuration).configurableProductLinkManagementV1AddChildPost(sku, configurableProductLinkManagementV1AddChildPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Get all children for Configurable product
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductLinkManagementV1Api
     */
    public configurableProductLinkManagementV1GetChildrenGet(sku: string, options?: any) {
        return ConfigurableProductLinkManagementV1ApiFp(this.configuration).configurableProductLinkManagementV1GetChildrenGet(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Remove configurable product option
     * @param {string} sku
     * @param {string} childSku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductLinkManagementV1Api
     */
    public configurableProductLinkManagementV1RemoveChildDelete(sku: string, childSku: string, options?: any) {
        return ConfigurableProductLinkManagementV1ApiFp(this.configuration).configurableProductLinkManagementV1RemoveChildDelete(sku, childSku, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigurableProductOptionRepositoryV1Api - fetch parameter creator
 * @export
 */
export const ConfigurableProductOptionRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove option from configurable product
         * @param {string} sku
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1DeleteByIdDelete(sku: string, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductOptionRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configurableProductOptionRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/options/{id}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get option for configurable product
         * @param {string} sku
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1GetGet(sku: string, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductOptionRepositoryV1GetGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configurableProductOptionRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/options/{id}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all options for configurable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1GetListGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductOptionRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/options/all`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save option
         * @param {string} sku
         * @param {ConfigurableProductOptionRepositoryV1SavePostBody} [configurableProductOptionRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1SavePost(sku: string, configurableProductOptionRepositoryV1SavePostBody?: ConfigurableProductOptionRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductOptionRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/options`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfigurableProductOptionRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(configurableProductOptionRepositoryV1SavePostBody || {}) : (configurableProductOptionRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save option
         * @param {string} sku
         * @param {string} id
         * @param {ConfigurableProductOptionRepositoryV1SavePutBody} [configurableProductOptionRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1SavePut(sku: string, id: string, configurableProductOptionRepositoryV1SavePutBody?: ConfigurableProductOptionRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling configurableProductOptionRepositoryV1SavePut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configurableProductOptionRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/configurable-products/{sku}/options/{id}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfigurableProductOptionRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(configurableProductOptionRepositoryV1SavePutBody || {}) : (configurableProductOptionRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurableProductOptionRepositoryV1Api - functional programming interface
 * @export
 */
export const ConfigurableProductOptionRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove option from configurable product
         * @param {string} sku
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1DeleteByIdDelete(sku: string, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ConfigurableProductOptionRepositoryV1ApiFetchParamCreator(configuration).configurableProductOptionRepositoryV1DeleteByIdDelete(sku, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get option for configurable product
         * @param {string} sku
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1GetGet(sku: string, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConfigurableProductDataOptionInterface> {
            const localVarFetchArgs = ConfigurableProductOptionRepositoryV1ApiFetchParamCreator(configuration).configurableProductOptionRepositoryV1GetGet(sku, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all options for configurable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1GetListGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConfigurableProductDataOptionInterface>> {
            const localVarFetchArgs = ConfigurableProductOptionRepositoryV1ApiFetchParamCreator(configuration).configurableProductOptionRepositoryV1GetListGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save option
         * @param {string} sku
         * @param {ConfigurableProductOptionRepositoryV1SavePostBody} [configurableProductOptionRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1SavePost(sku: string, configurableProductOptionRepositoryV1SavePostBody?: ConfigurableProductOptionRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = ConfigurableProductOptionRepositoryV1ApiFetchParamCreator(configuration).configurableProductOptionRepositoryV1SavePost(sku, configurableProductOptionRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save option
         * @param {string} sku
         * @param {string} id
         * @param {ConfigurableProductOptionRepositoryV1SavePutBody} [configurableProductOptionRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1SavePut(sku: string, id: string, configurableProductOptionRepositoryV1SavePutBody?: ConfigurableProductOptionRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = ConfigurableProductOptionRepositoryV1ApiFetchParamCreator(configuration).configurableProductOptionRepositoryV1SavePut(sku, id, configurableProductOptionRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigurableProductOptionRepositoryV1Api - factory interface
 * @export
 */
export const ConfigurableProductOptionRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove option from configurable product
         * @param {string} sku
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1DeleteByIdDelete(sku: string, id: number, options?: any) {
            return ConfigurableProductOptionRepositoryV1ApiFp(configuration).configurableProductOptionRepositoryV1DeleteByIdDelete(sku, id, options)(fetch, basePath);
        },
        /**
         * Get option for configurable product
         * @param {string} sku
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1GetGet(sku: string, id: number, options?: any) {
            return ConfigurableProductOptionRepositoryV1ApiFp(configuration).configurableProductOptionRepositoryV1GetGet(sku, id, options)(fetch, basePath);
        },
        /**
         * Get all options for configurable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1GetListGet(sku: string, options?: any) {
            return ConfigurableProductOptionRepositoryV1ApiFp(configuration).configurableProductOptionRepositoryV1GetListGet(sku, options)(fetch, basePath);
        },
        /**
         * Save option
         * @param {string} sku
         * @param {ConfigurableProductOptionRepositoryV1SavePostBody} [configurableProductOptionRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1SavePost(sku: string, configurableProductOptionRepositoryV1SavePostBody?: ConfigurableProductOptionRepositoryV1SavePostBody, options?: any) {
            return ConfigurableProductOptionRepositoryV1ApiFp(configuration).configurableProductOptionRepositoryV1SavePost(sku, configurableProductOptionRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save option
         * @param {string} sku
         * @param {string} id
         * @param {ConfigurableProductOptionRepositoryV1SavePutBody} [configurableProductOptionRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurableProductOptionRepositoryV1SavePut(sku: string, id: string, configurableProductOptionRepositoryV1SavePutBody?: ConfigurableProductOptionRepositoryV1SavePutBody, options?: any) {
            return ConfigurableProductOptionRepositoryV1ApiFp(configuration).configurableProductOptionRepositoryV1SavePut(sku, id, configurableProductOptionRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigurableProductOptionRepositoryV1Api - object-oriented interface
 * @export
 * @class ConfigurableProductOptionRepositoryV1Api
 * @extends {BaseAPI}
 */
export class ConfigurableProductOptionRepositoryV1Api extends BaseAPI {
    /**
     * Remove option from configurable product
     * @param {string} sku
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductOptionRepositoryV1Api
     */
    public configurableProductOptionRepositoryV1DeleteByIdDelete(sku: string, id: number, options?: any) {
        return ConfigurableProductOptionRepositoryV1ApiFp(this.configuration).configurableProductOptionRepositoryV1DeleteByIdDelete(sku, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get option for configurable product
     * @param {string} sku
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductOptionRepositoryV1Api
     */
    public configurableProductOptionRepositoryV1GetGet(sku: string, id: number, options?: any) {
        return ConfigurableProductOptionRepositoryV1ApiFp(this.configuration).configurableProductOptionRepositoryV1GetGet(sku, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get all options for configurable product
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductOptionRepositoryV1Api
     */
    public configurableProductOptionRepositoryV1GetListGet(sku: string, options?: any) {
        return ConfigurableProductOptionRepositoryV1ApiFp(this.configuration).configurableProductOptionRepositoryV1GetListGet(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Save option
     * @param {string} sku
     * @param {ConfigurableProductOptionRepositoryV1SavePostBody} [configurableProductOptionRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductOptionRepositoryV1Api
     */
    public configurableProductOptionRepositoryV1SavePost(sku: string, configurableProductOptionRepositoryV1SavePostBody?: ConfigurableProductOptionRepositoryV1SavePostBody, options?: any) {
        return ConfigurableProductOptionRepositoryV1ApiFp(this.configuration).configurableProductOptionRepositoryV1SavePost(sku, configurableProductOptionRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save option
     * @param {string} sku
     * @param {string} id
     * @param {ConfigurableProductOptionRepositoryV1SavePutBody} [configurableProductOptionRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurableProductOptionRepositoryV1Api
     */
    public configurableProductOptionRepositoryV1SavePut(sku: string, id: string, configurableProductOptionRepositoryV1SavePutBody?: ConfigurableProductOptionRepositoryV1SavePutBody, options?: any) {
        return ConfigurableProductOptionRepositoryV1ApiFp(this.configuration).configurableProductOptionRepositoryV1SavePut(sku, id, configurableProductOptionRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerAccountManagementV1Api - fetch parameter creator
 * @export
 */
export const CustomerAccountManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a customer account using a key that was sent in a confirmation email.
         * @param {CustomerAccountManagementV1ActivateByIdPutBody} [customerAccountManagementV1ActivateByIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody?: CustomerAccountManagementV1ActivateByIdPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/me/activate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1ActivateByIdPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1ActivateByIdPutBody || {}) : (customerAccountManagementV1ActivateByIdPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate a customer account using a key that was sent in a confirmation email.
         * @param {string} email
         * @param {CustomerAccountManagementV1ActivatePutBody} [customerAccountManagementV1ActivatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ActivatePut(email: string, customerAccountManagementV1ActivatePutBody?: CustomerAccountManagementV1ActivatePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling customerAccountManagementV1ActivatePut.');
            }
            const localVarPath = `/V1/customers/{email}/activate`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1ActivatePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1ActivatePutBody || {}) : (customerAccountManagementV1ActivatePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change customer password.
         * @param {CustomerAccountManagementV1ChangePasswordByIdPutBody} [customerAccountManagementV1ChangePasswordByIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody?: CustomerAccountManagementV1ChangePasswordByIdPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/me/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1ChangePasswordByIdPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1ChangePasswordByIdPutBody || {}) : (customerAccountManagementV1ChangePasswordByIdPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create customer account. Perform necessary business operations like sending email.
         * @param {CustomerAccountManagementV1CreateAccountPostBody} [customerAccountManagementV1CreateAccountPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody?: CustomerAccountManagementV1CreateAccountPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1CreateAccountPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1CreateAccountPostBody || {}) : (customerAccountManagementV1CreateAccountPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the account confirmation status.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetConfirmationStatusGet(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerAccountManagementV1GetConfirmationStatusGet.');
            }
            const localVarPath = `/V1/customers/{customerId}/confirm`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve default billing address for the given customerId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultBillingAddressGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/me/billingAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve default billing address for the given customerId.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerAccountManagementV1GetDefaultBillingAddressGet_1.');
            }
            const localVarPath = `/V1/customers/{customerId}/billingAddress`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve default shipping address for the given customerId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultShippingAddressGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/me/shippingAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve default shipping address for the given customerId.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerAccountManagementV1GetDefaultShippingAddressGet_2.');
            }
            const localVarPath = `/V1/customers/{customerId}/shippingAddress`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email to the customer with a password reset link.
         * @param {CustomerAccountManagementV1InitiatePasswordResetPutBody} [customerAccountManagementV1InitiatePasswordResetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody?: CustomerAccountManagementV1InitiatePasswordResetPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1InitiatePasswordResetPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1InitiatePasswordResetPutBody || {}) : (customerAccountManagementV1InitiatePasswordResetPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if given email is associated with a customer account in given website.
         * @param {CustomerAccountManagementV1IsEmailAvailablePostBody} [customerAccountManagementV1IsEmailAvailablePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody?: CustomerAccountManagementV1IsEmailAvailablePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/isEmailAvailable`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1IsEmailAvailablePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1IsEmailAvailablePostBody || {}) : (customerAccountManagementV1IsEmailAvailablePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if customer can be deleted.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1IsReadonlyGet(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerAccountManagementV1IsReadonlyGet.');
            }
            const localVarPath = `/V1/customers/{customerId}/permissions/readonly`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend confirmation email.
         * @param {CustomerAccountManagementV1ResendConfirmationPostBody} [customerAccountManagementV1ResendConfirmationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody?: CustomerAccountManagementV1ResendConfirmationPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/confirm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1ResendConfirmationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1ResendConfirmationPostBody || {}) : (customerAccountManagementV1ResendConfirmationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset customer password.
         * @param {CustomerAccountManagementV1ResetPasswordPostBody} [customerAccountManagementV1ResetPasswordPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody?: CustomerAccountManagementV1ResetPasswordPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/resetPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1ResetPasswordPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1ResetPasswordPostBody || {}) : (customerAccountManagementV1ResetPasswordPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate customer data.
         * @param {CustomerAccountManagementV1ValidatePutBody} [customerAccountManagementV1ValidatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody?: CustomerAccountManagementV1ValidatePutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerAccountManagementV1ValidatePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerAccountManagementV1ValidatePutBody || {}) : (customerAccountManagementV1ValidatePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if password reset token is valid.
         * @param {number} customerId
         * @param {string} resetPasswordLinkToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId: number, resetPasswordLinkToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerAccountManagementV1ValidateResetPasswordLinkTokenGet.');
            }
            // verify required parameter 'resetPasswordLinkToken' is not null or undefined
            if (resetPasswordLinkToken === null || resetPasswordLinkToken === undefined) {
                throw new RequiredError('resetPasswordLinkToken','Required parameter resetPasswordLinkToken was null or undefined when calling customerAccountManagementV1ValidateResetPasswordLinkTokenGet.');
            }
            const localVarPath = `/V1/customers/{customerId}/password/resetLinkToken/{resetPasswordLinkToken}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"resetPasswordLinkToken"}}`, encodeURIComponent(String(resetPasswordLinkToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerAccountManagementV1Api - functional programming interface
 * @export
 */
export const CustomerAccountManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activate a customer account using a key that was sent in a confirmation email.
         * @param {CustomerAccountManagementV1ActivateByIdPutBody} [customerAccountManagementV1ActivateByIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody?: CustomerAccountManagementV1ActivateByIdPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activate a customer account using a key that was sent in a confirmation email.
         * @param {string} email
         * @param {CustomerAccountManagementV1ActivatePutBody} [customerAccountManagementV1ActivatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ActivatePut(email: string, customerAccountManagementV1ActivatePutBody?: CustomerAccountManagementV1ActivatePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ActivatePut(email, customerAccountManagementV1ActivatePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change customer password.
         * @param {CustomerAccountManagementV1ChangePasswordByIdPutBody} [customerAccountManagementV1ChangePasswordByIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody?: CustomerAccountManagementV1ChangePasswordByIdPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create customer account. Perform necessary business operations like sending email.
         * @param {CustomerAccountManagementV1CreateAccountPostBody} [customerAccountManagementV1CreateAccountPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody?: CustomerAccountManagementV1CreateAccountPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the account confirmation status.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetConfirmationStatusGet(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1GetConfirmationStatusGet(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve default billing address for the given customerId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultBillingAddressGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAddressInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1GetDefaultBillingAddressGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve default billing address for the given customerId.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAddressInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve default shipping address for the given customerId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultShippingAddressGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAddressInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1GetDefaultShippingAddressGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve default shipping address for the given customerId.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAddressInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email to the customer with a password reset link.
         * @param {CustomerAccountManagementV1InitiatePasswordResetPutBody} [customerAccountManagementV1InitiatePasswordResetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody?: CustomerAccountManagementV1InitiatePasswordResetPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if given email is associated with a customer account in given website.
         * @param {CustomerAccountManagementV1IsEmailAvailablePostBody} [customerAccountManagementV1IsEmailAvailablePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody?: CustomerAccountManagementV1IsEmailAvailablePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if customer can be deleted.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1IsReadonlyGet(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1IsReadonlyGet(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resend confirmation email.
         * @param {CustomerAccountManagementV1ResendConfirmationPostBody} [customerAccountManagementV1ResendConfirmationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody?: CustomerAccountManagementV1ResendConfirmationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reset customer password.
         * @param {CustomerAccountManagementV1ResetPasswordPostBody} [customerAccountManagementV1ResetPasswordPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody?: CustomerAccountManagementV1ResetPasswordPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate customer data.
         * @param {CustomerAccountManagementV1ValidatePutBody} [customerAccountManagementV1ValidatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody?: CustomerAccountManagementV1ValidatePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataValidationResultsInterface> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if password reset token is valid.
         * @param {number} customerId
         * @param {string} resetPasswordLinkToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId: number, resetPasswordLinkToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAccountManagementV1ApiFetchParamCreator(configuration).customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId, resetPasswordLinkToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerAccountManagementV1Api - factory interface
 * @export
 */
export const CustomerAccountManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate a customer account using a key that was sent in a confirmation email.
         * @param {CustomerAccountManagementV1ActivateByIdPutBody} [customerAccountManagementV1ActivateByIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody?: CustomerAccountManagementV1ActivateByIdPutBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody, options)(fetch, basePath);
        },
        /**
         * Activate a customer account using a key that was sent in a confirmation email.
         * @param {string} email
         * @param {CustomerAccountManagementV1ActivatePutBody} [customerAccountManagementV1ActivatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ActivatePut(email: string, customerAccountManagementV1ActivatePutBody?: CustomerAccountManagementV1ActivatePutBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ActivatePut(email, customerAccountManagementV1ActivatePutBody, options)(fetch, basePath);
        },
        /**
         * Change customer password.
         * @param {CustomerAccountManagementV1ChangePasswordByIdPutBody} [customerAccountManagementV1ChangePasswordByIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody?: CustomerAccountManagementV1ChangePasswordByIdPutBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody, options)(fetch, basePath);
        },
        /**
         * Create customer account. Perform necessary business operations like sending email.
         * @param {CustomerAccountManagementV1CreateAccountPostBody} [customerAccountManagementV1CreateAccountPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody?: CustomerAccountManagementV1CreateAccountPostBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody, options)(fetch, basePath);
        },
        /**
         * Gets the account confirmation status.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetConfirmationStatusGet(customerId: number, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1GetConfirmationStatusGet(customerId, options)(fetch, basePath);
        },
        /**
         * Retrieve default billing address for the given customerId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultBillingAddressGet(options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1GetDefaultBillingAddressGet(options)(fetch, basePath);
        },
        /**
         * Retrieve default billing address for the given customerId.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId: number, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId, options)(fetch, basePath);
        },
        /**
         * Retrieve default shipping address for the given customerId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultShippingAddressGet(options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1GetDefaultShippingAddressGet(options)(fetch, basePath);
        },
        /**
         * Retrieve default shipping address for the given customerId.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId: number, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId, options)(fetch, basePath);
        },
        /**
         * Send an email to the customer with a password reset link.
         * @param {CustomerAccountManagementV1InitiatePasswordResetPutBody} [customerAccountManagementV1InitiatePasswordResetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody?: CustomerAccountManagementV1InitiatePasswordResetPutBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody, options)(fetch, basePath);
        },
        /**
         * Check if given email is associated with a customer account in given website.
         * @param {CustomerAccountManagementV1IsEmailAvailablePostBody} [customerAccountManagementV1IsEmailAvailablePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody?: CustomerAccountManagementV1IsEmailAvailablePostBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody, options)(fetch, basePath);
        },
        /**
         * Check if customer can be deleted.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1IsReadonlyGet(customerId: number, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1IsReadonlyGet(customerId, options)(fetch, basePath);
        },
        /**
         * Resend confirmation email.
         * @param {CustomerAccountManagementV1ResendConfirmationPostBody} [customerAccountManagementV1ResendConfirmationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody?: CustomerAccountManagementV1ResendConfirmationPostBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody, options)(fetch, basePath);
        },
        /**
         * Reset customer password.
         * @param {CustomerAccountManagementV1ResetPasswordPostBody} [customerAccountManagementV1ResetPasswordPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody?: CustomerAccountManagementV1ResetPasswordPostBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody, options)(fetch, basePath);
        },
        /**
         * Validate customer data.
         * @param {CustomerAccountManagementV1ValidatePutBody} [customerAccountManagementV1ValidatePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody?: CustomerAccountManagementV1ValidatePutBody, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody, options)(fetch, basePath);
        },
        /**
         * Check if password reset token is valid.
         * @param {number} customerId
         * @param {string} resetPasswordLinkToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId: number, resetPasswordLinkToken: string, options?: any) {
            return CustomerAccountManagementV1ApiFp(configuration).customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId, resetPasswordLinkToken, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerAccountManagementV1Api - object-oriented interface
 * @export
 * @class CustomerAccountManagementV1Api
 * @extends {BaseAPI}
 */
export class CustomerAccountManagementV1Api extends BaseAPI {
    /**
     * Activate a customer account using a key that was sent in a confirmation email.
     * @param {CustomerAccountManagementV1ActivateByIdPutBody} [customerAccountManagementV1ActivateByIdPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody?: CustomerAccountManagementV1ActivateByIdPutBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ActivateByIdPut(customerAccountManagementV1ActivateByIdPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Activate a customer account using a key that was sent in a confirmation email.
     * @param {string} email
     * @param {CustomerAccountManagementV1ActivatePutBody} [customerAccountManagementV1ActivatePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ActivatePut(email: string, customerAccountManagementV1ActivatePutBody?: CustomerAccountManagementV1ActivatePutBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ActivatePut(email, customerAccountManagementV1ActivatePutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Change customer password.
     * @param {CustomerAccountManagementV1ChangePasswordByIdPutBody} [customerAccountManagementV1ChangePasswordByIdPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody?: CustomerAccountManagementV1ChangePasswordByIdPutBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ChangePasswordByIdPut(customerAccountManagementV1ChangePasswordByIdPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create customer account. Perform necessary business operations like sending email.
     * @param {CustomerAccountManagementV1CreateAccountPostBody} [customerAccountManagementV1CreateAccountPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody?: CustomerAccountManagementV1CreateAccountPostBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1CreateAccountPost(customerAccountManagementV1CreateAccountPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the account confirmation status.
     * @param {number} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1GetConfirmationStatusGet(customerId: number, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1GetConfirmationStatusGet(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve default billing address for the given customerId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1GetDefaultBillingAddressGet(options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1GetDefaultBillingAddressGet(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve default billing address for the given customerId.
     * @param {number} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId: number, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1GetDefaultBillingAddressGet_1(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve default shipping address for the given customerId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1GetDefaultShippingAddressGet(options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1GetDefaultShippingAddressGet(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve default shipping address for the given customerId.
     * @param {number} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId: number, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1GetDefaultShippingAddressGet_2(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Send an email to the customer with a password reset link.
     * @param {CustomerAccountManagementV1InitiatePasswordResetPutBody} [customerAccountManagementV1InitiatePasswordResetPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody?: CustomerAccountManagementV1InitiatePasswordResetPutBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1InitiatePasswordResetPut(customerAccountManagementV1InitiatePasswordResetPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Check if given email is associated with a customer account in given website.
     * @param {CustomerAccountManagementV1IsEmailAvailablePostBody} [customerAccountManagementV1IsEmailAvailablePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody?: CustomerAccountManagementV1IsEmailAvailablePostBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1IsEmailAvailablePost(customerAccountManagementV1IsEmailAvailablePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Check if customer can be deleted.
     * @param {number} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1IsReadonlyGet(customerId: number, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1IsReadonlyGet(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Resend confirmation email.
     * @param {CustomerAccountManagementV1ResendConfirmationPostBody} [customerAccountManagementV1ResendConfirmationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody?: CustomerAccountManagementV1ResendConfirmationPostBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ResendConfirmationPost(customerAccountManagementV1ResendConfirmationPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Reset customer password.
     * @param {CustomerAccountManagementV1ResetPasswordPostBody} [customerAccountManagementV1ResetPasswordPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody?: CustomerAccountManagementV1ResetPasswordPostBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ResetPasswordPost(customerAccountManagementV1ResetPasswordPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Validate customer data.
     * @param {CustomerAccountManagementV1ValidatePutBody} [customerAccountManagementV1ValidatePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody?: CustomerAccountManagementV1ValidatePutBody, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ValidatePut(customerAccountManagementV1ValidatePutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Check if password reset token is valid.
     * @param {number} customerId
     * @param {string} resetPasswordLinkToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountManagementV1Api
     */
    public customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId: number, resetPasswordLinkToken: string, options?: any) {
        return CustomerAccountManagementV1ApiFp(this.configuration).customerAccountManagementV1ValidateResetPasswordLinkTokenGet(customerId, resetPasswordLinkToken, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerAddressMetadataV1Api - fetch parameter creator
 * @export
 */
export const CustomerAddressMetadataV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAllAttributesMetadataGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/attributeMetadata/customerAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAttributeMetadataGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling customerAddressMetadataV1GetAttributeMetadataGet.');
            }
            const localVarPath = `/V1/attributeMetadata/customerAddress/attribute/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAttributesGet(formCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'formCode' is not null or undefined
            if (formCode === null || formCode === undefined) {
                throw new RequiredError('formCode','Required parameter formCode was null or undefined when calling customerAddressMetadataV1GetAttributesGet.');
            }
            const localVarPath = `/V1/attributeMetadata/customerAddress/form/{formCode}`
                .replace(`{${"formCode"}}`, encodeURIComponent(String(formCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom attributes metadata for the given data interface.
         * @param {string} [dataInterfaceName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/V1/attributeMetadata/customerAddress/custom`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataInterfaceName !== undefined) {
                localVarQueryParameter['dataInterfaceName'] = dataInterfaceName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerAddressMetadataV1Api - functional programming interface
 * @export
 */
export const CustomerAddressMetadataV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAllAttributesMetadataGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = CustomerAddressMetadataV1ApiFetchParamCreator(configuration).customerAddressMetadataV1GetAllAttributesMetadataGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAttributeMetadataGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAttributeMetadataInterface> {
            const localVarFetchArgs = CustomerAddressMetadataV1ApiFetchParamCreator(configuration).customerAddressMetadataV1GetAttributeMetadataGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAttributesGet(formCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = CustomerAddressMetadataV1ApiFetchParamCreator(configuration).customerAddressMetadataV1GetAttributesGet(formCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get custom attributes metadata for the given data interface.
         * @param {string} [dataInterfaceName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = CustomerAddressMetadataV1ApiFetchParamCreator(configuration).customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerAddressMetadataV1Api - factory interface
 * @export
 */
export const CustomerAddressMetadataV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAllAttributesMetadataGet(options?: any) {
            return CustomerAddressMetadataV1ApiFp(configuration).customerAddressMetadataV1GetAllAttributesMetadataGet(options)(fetch, basePath);
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAttributeMetadataGet(attributeCode: string, options?: any) {
            return CustomerAddressMetadataV1ApiFp(configuration).customerAddressMetadataV1GetAttributeMetadataGet(attributeCode, options)(fetch, basePath);
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetAttributesGet(formCode: string, options?: any) {
            return CustomerAddressMetadataV1ApiFp(configuration).customerAddressMetadataV1GetAttributesGet(formCode, options)(fetch, basePath);
        },
        /**
         * Get custom attributes metadata for the given data interface.
         * @param {string} [dataInterfaceName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options?: any) {
            return CustomerAddressMetadataV1ApiFp(configuration).customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerAddressMetadataV1Api - object-oriented interface
 * @export
 * @class CustomerAddressMetadataV1Api
 * @extends {BaseAPI}
 */
export class CustomerAddressMetadataV1Api extends BaseAPI {
    /**
     * Get all attribute metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAddressMetadataV1Api
     */
    public customerAddressMetadataV1GetAllAttributesMetadataGet(options?: any) {
        return CustomerAddressMetadataV1ApiFp(this.configuration).customerAddressMetadataV1GetAllAttributesMetadataGet(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve attribute metadata.
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAddressMetadataV1Api
     */
    public customerAddressMetadataV1GetAttributeMetadataGet(attributeCode: string, options?: any) {
        return CustomerAddressMetadataV1ApiFp(this.configuration).customerAddressMetadataV1GetAttributeMetadataGet(attributeCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all attributes filtered by form code
     * @param {string} formCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAddressMetadataV1Api
     */
    public customerAddressMetadataV1GetAttributesGet(formCode: string, options?: any) {
        return CustomerAddressMetadataV1ApiFp(this.configuration).customerAddressMetadataV1GetAttributesGet(formCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get custom attributes metadata for the given data interface.
     * @param {string} [dataInterfaceName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAddressMetadataV1Api
     */
    public customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options?: any) {
        return CustomerAddressMetadataV1ApiFp(this.configuration).customerAddressMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerAddressRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CustomerAddressRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete customer address by ID.
         * @param {number} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressRepositoryV1DeleteByIdDelete(addressId: number, options: any = {}): FetchArgs {
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling customerAddressRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customer address.
         * @param {number} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressRepositoryV1GetByIdGet(addressId: number, options: any = {}): FetchArgs {
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling customerAddressRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/customers/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerAddressRepositoryV1Api - functional programming interface
 * @export
 */
export const CustomerAddressRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete customer address by ID.
         * @param {number} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressRepositoryV1DeleteByIdDelete(addressId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerAddressRepositoryV1ApiFetchParamCreator(configuration).customerAddressRepositoryV1DeleteByIdDelete(addressId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve customer address.
         * @param {number} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressRepositoryV1GetByIdGet(addressId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAddressInterface> {
            const localVarFetchArgs = CustomerAddressRepositoryV1ApiFetchParamCreator(configuration).customerAddressRepositoryV1GetByIdGet(addressId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerAddressRepositoryV1Api - factory interface
 * @export
 */
export const CustomerAddressRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete customer address by ID.
         * @param {number} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressRepositoryV1DeleteByIdDelete(addressId: number, options?: any) {
            return CustomerAddressRepositoryV1ApiFp(configuration).customerAddressRepositoryV1DeleteByIdDelete(addressId, options)(fetch, basePath);
        },
        /**
         * Retrieve customer address.
         * @param {number} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerAddressRepositoryV1GetByIdGet(addressId: number, options?: any) {
            return CustomerAddressRepositoryV1ApiFp(configuration).customerAddressRepositoryV1GetByIdGet(addressId, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerAddressRepositoryV1Api - object-oriented interface
 * @export
 * @class CustomerAddressRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CustomerAddressRepositoryV1Api extends BaseAPI {
    /**
     * Delete customer address by ID.
     * @param {number} addressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAddressRepositoryV1Api
     */
    public customerAddressRepositoryV1DeleteByIdDelete(addressId: number, options?: any) {
        return CustomerAddressRepositoryV1ApiFp(this.configuration).customerAddressRepositoryV1DeleteByIdDelete(addressId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve customer address.
     * @param {number} addressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAddressRepositoryV1Api
     */
    public customerAddressRepositoryV1GetByIdGet(addressId: number, options?: any) {
        return CustomerAddressRepositoryV1ApiFp(this.configuration).customerAddressRepositoryV1GetByIdGet(addressId, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerBalanceBalanceManagementV1Api - fetch parameter creator
 * @export
 */
export const CustomerBalanceBalanceManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Apply store credit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerBalanceBalanceManagementV1ApplyPost(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/balance/apply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerBalanceBalanceManagementV1Api - functional programming interface
 * @export
 */
export const CustomerBalanceBalanceManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Apply store credit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerBalanceBalanceManagementV1ApplyPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerBalanceBalanceManagementV1ApiFetchParamCreator(configuration).customerBalanceBalanceManagementV1ApplyPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerBalanceBalanceManagementV1Api - factory interface
 * @export
 */
export const CustomerBalanceBalanceManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Apply store credit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerBalanceBalanceManagementV1ApplyPost(options?: any) {
            return CustomerBalanceBalanceManagementV1ApiFp(configuration).customerBalanceBalanceManagementV1ApplyPost(options)(fetch, basePath);
        },
    };
};

/**
 * CustomerBalanceBalanceManagementV1Api - object-oriented interface
 * @export
 * @class CustomerBalanceBalanceManagementV1Api
 * @extends {BaseAPI}
 */
export class CustomerBalanceBalanceManagementV1Api extends BaseAPI {
    /**
     * Apply store credit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerBalanceBalanceManagementV1Api
     */
    public customerBalanceBalanceManagementV1ApplyPost(options?: any) {
        return CustomerBalanceBalanceManagementV1ApiFp(this.configuration).customerBalanceBalanceManagementV1ApplyPost(options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerCustomerGroupConfigV1Api - fetch parameter creator
 * @export
 */
export const CustomerCustomerGroupConfigV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set system default customer group.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customerCustomerGroupConfigV1SetDefaultCustomerGroupPut.');
            }
            const localVarPath = `/V1/customerGroups/default/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerCustomerGroupConfigV1Api - functional programming interface
 * @export
 */
export const CustomerCustomerGroupConfigV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Set system default customer group.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CustomerCustomerGroupConfigV1ApiFetchParamCreator(configuration).customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerCustomerGroupConfigV1Api - factory interface
 * @export
 */
export const CustomerCustomerGroupConfigV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Set system default customer group.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id: number, options?: any) {
            return CustomerCustomerGroupConfigV1ApiFp(configuration).customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerCustomerGroupConfigV1Api - object-oriented interface
 * @export
 * @class CustomerCustomerGroupConfigV1Api
 * @extends {BaseAPI}
 */
export class CustomerCustomerGroupConfigV1Api extends BaseAPI {
    /**
     * Set system default customer group.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerGroupConfigV1Api
     */
    public customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id: number, options?: any) {
        return CustomerCustomerGroupConfigV1ApiFp(this.configuration).customerCustomerGroupConfigV1SetDefaultCustomerGroupPut(id, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerCustomerMetadataV1Api - fetch parameter creator
 * @export
 */
export const CustomerCustomerMetadataV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAllAttributesMetadataGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/attributeMetadata/customer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling customerCustomerMetadataV1GetAttributeMetadataGet.');
            }
            const localVarPath = `/V1/attributeMetadata/customer/attribute/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAttributesGet(formCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'formCode' is not null or undefined
            if (formCode === null || formCode === undefined) {
                throw new RequiredError('formCode','Required parameter formCode was null or undefined when calling customerCustomerMetadataV1GetAttributesGet.');
            }
            const localVarPath = `/V1/attributeMetadata/customer/form/{formCode}`
                .replace(`{${"formCode"}}`, encodeURIComponent(String(formCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom attributes metadata for the given data interface.
         * @param {string} [dataInterfaceName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/V1/attributeMetadata/customer/custom`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataInterfaceName !== undefined) {
                localVarQueryParameter['dataInterfaceName'] = dataInterfaceName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerCustomerMetadataV1Api - functional programming interface
 * @export
 */
export const CustomerCustomerMetadataV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAllAttributesMetadataGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = CustomerCustomerMetadataV1ApiFetchParamCreator(configuration).customerCustomerMetadataV1GetAllAttributesMetadataGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAttributeMetadataInterface> {
            const localVarFetchArgs = CustomerCustomerMetadataV1ApiFetchParamCreator(configuration).customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAttributesGet(formCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = CustomerCustomerMetadataV1ApiFetchParamCreator(configuration).customerCustomerMetadataV1GetAttributesGet(formCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get custom attributes metadata for the given data interface.
         * @param {string} [dataInterfaceName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = CustomerCustomerMetadataV1ApiFetchParamCreator(configuration).customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerCustomerMetadataV1Api - factory interface
 * @export
 */
export const CustomerCustomerMetadataV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAllAttributesMetadataGet(options?: any) {
            return CustomerCustomerMetadataV1ApiFp(configuration).customerCustomerMetadataV1GetAllAttributesMetadataGet(options)(fetch, basePath);
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode: string, options?: any) {
            return CustomerCustomerMetadataV1ApiFp(configuration).customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode, options)(fetch, basePath);
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetAttributesGet(formCode: string, options?: any) {
            return CustomerCustomerMetadataV1ApiFp(configuration).customerCustomerMetadataV1GetAttributesGet(formCode, options)(fetch, basePath);
        },
        /**
         * Get custom attributes metadata for the given data interface.
         * @param {string} [dataInterfaceName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options?: any) {
            return CustomerCustomerMetadataV1ApiFp(configuration).customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerCustomerMetadataV1Api - object-oriented interface
 * @export
 * @class CustomerCustomerMetadataV1Api
 * @extends {BaseAPI}
 */
export class CustomerCustomerMetadataV1Api extends BaseAPI {
    /**
     * Get all attribute metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerMetadataV1Api
     */
    public customerCustomerMetadataV1GetAllAttributesMetadataGet(options?: any) {
        return CustomerCustomerMetadataV1ApiFp(this.configuration).customerCustomerMetadataV1GetAllAttributesMetadataGet(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve attribute metadata.
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerMetadataV1Api
     */
    public customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode: string, options?: any) {
        return CustomerCustomerMetadataV1ApiFp(this.configuration).customerCustomerMetadataV1GetAttributeMetadataGet(attributeCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all attributes filtered by form code
     * @param {string} formCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerMetadataV1Api
     */
    public customerCustomerMetadataV1GetAttributesGet(formCode: string, options?: any) {
        return CustomerCustomerMetadataV1ApiFp(this.configuration).customerCustomerMetadataV1GetAttributesGet(formCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get custom attributes metadata for the given data interface.
     * @param {string} [dataInterfaceName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerMetadataV1Api
     */
    public customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName?: string, options?: any) {
        return CustomerCustomerMetadataV1ApiFp(this.configuration).customerCustomerMetadataV1GetCustomAttributesMetadataGet(dataInterfaceName, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerCustomerRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CustomerCustomerRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete customer by Customer ID.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1DeleteByIdDelete(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerCustomerRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer by Customer ID.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetByIdGet(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerCustomerRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer by Customer ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetByIdGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customers which match a specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CustomerRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a customer.
         * @param {string} customerId
         * @param {CustomerCustomerRepositoryV1SavePutBody} [customerCustomerRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1SavePut(customerId: string, customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerCustomerRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerCustomerRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerCustomerRepositoryV1SavePutBody || {}) : (customerCustomerRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a customer.
         * @param {CustomerCustomerRepositoryV1SavePutBody1} [customerCustomerRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customers/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerCustomerRepositoryV1SavePutBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerCustomerRepositoryV1SavePutBody || {}) : (customerCustomerRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerCustomerRepositoryV1Api - functional programming interface
 * @export
 */
export const CustomerCustomerRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete customer by Customer ID.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1DeleteByIdDelete(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerCustomerRepositoryV1ApiFetchParamCreator(configuration).customerCustomerRepositoryV1DeleteByIdDelete(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get customer by Customer ID.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetByIdGet(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerCustomerRepositoryV1ApiFetchParamCreator(configuration).customerCustomerRepositoryV1GetByIdGet(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get customer by Customer ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetByIdGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerCustomerRepositoryV1ApiFetchParamCreator(configuration).customerCustomerRepositoryV1GetByIdGet_1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve customers which match a specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CustomerRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerSearchResultsInterface> {
            const localVarFetchArgs = CustomerCustomerRepositoryV1ApiFetchParamCreator(configuration).customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update a customer.
         * @param {string} customerId
         * @param {CustomerCustomerRepositoryV1SavePutBody} [customerCustomerRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1SavePut(customerId: string, customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerCustomerRepositoryV1ApiFetchParamCreator(configuration).customerCustomerRepositoryV1SavePut(customerId, customerCustomerRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update a customer.
         * @param {CustomerCustomerRepositoryV1SavePutBody1} [customerCustomerRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataCustomerInterface> {
            const localVarFetchArgs = CustomerCustomerRepositoryV1ApiFetchParamCreator(configuration).customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerCustomerRepositoryV1Api - factory interface
 * @export
 */
export const CustomerCustomerRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete customer by Customer ID.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1DeleteByIdDelete(customerId: number, options?: any) {
            return CustomerCustomerRepositoryV1ApiFp(configuration).customerCustomerRepositoryV1DeleteByIdDelete(customerId, options)(fetch, basePath);
        },
        /**
         * Get customer by Customer ID.
         * @param {number} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetByIdGet(customerId: number, options?: any) {
            return CustomerCustomerRepositoryV1ApiFp(configuration).customerCustomerRepositoryV1GetByIdGet(customerId, options)(fetch, basePath);
        },
        /**
         * Get customer by Customer ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetByIdGet_1(options?: any) {
            return CustomerCustomerRepositoryV1ApiFp(configuration).customerCustomerRepositoryV1GetByIdGet_1(options)(fetch, basePath);
        },
        /**
         * Retrieve customers which match a specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CustomerRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CustomerCustomerRepositoryV1ApiFp(configuration).customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create or update a customer.
         * @param {string} customerId
         * @param {CustomerCustomerRepositoryV1SavePutBody} [customerCustomerRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1SavePut(customerId: string, customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody, options?: any) {
            return CustomerCustomerRepositoryV1ApiFp(configuration).customerCustomerRepositoryV1SavePut(customerId, customerCustomerRepositoryV1SavePutBody, options)(fetch, basePath);
        },
        /**
         * Create or update a customer.
         * @param {CustomerCustomerRepositoryV1SavePutBody1} [customerCustomerRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody1, options?: any) {
            return CustomerCustomerRepositoryV1ApiFp(configuration).customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerCustomerRepositoryV1Api - object-oriented interface
 * @export
 * @class CustomerCustomerRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CustomerCustomerRepositoryV1Api extends BaseAPI {
    /**
     * Delete customer by Customer ID.
     * @param {number} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerRepositoryV1Api
     */
    public customerCustomerRepositoryV1DeleteByIdDelete(customerId: number, options?: any) {
        return CustomerCustomerRepositoryV1ApiFp(this.configuration).customerCustomerRepositoryV1DeleteByIdDelete(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get customer by Customer ID.
     * @param {number} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerRepositoryV1Api
     */
    public customerCustomerRepositoryV1GetByIdGet(customerId: number, options?: any) {
        return CustomerCustomerRepositoryV1ApiFp(this.configuration).customerCustomerRepositoryV1GetByIdGet(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Get customer by Customer ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerRepositoryV1Api
     */
    public customerCustomerRepositoryV1GetByIdGet_1(options?: any) {
        return CustomerCustomerRepositoryV1ApiFp(this.configuration).customerCustomerRepositoryV1GetByIdGet_1(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve customers which match a specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CustomerRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerRepositoryV1Api
     */
    public customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CustomerCustomerRepositoryV1ApiFp(this.configuration).customerCustomerRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update a customer.
     * @param {string} customerId
     * @param {CustomerCustomerRepositoryV1SavePutBody} [customerCustomerRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerRepositoryV1Api
     */
    public customerCustomerRepositoryV1SavePut(customerId: string, customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody, options?: any) {
        return CustomerCustomerRepositoryV1ApiFp(this.configuration).customerCustomerRepositoryV1SavePut(customerId, customerCustomerRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update a customer.
     * @param {CustomerCustomerRepositoryV1SavePutBody1} [customerCustomerRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCustomerRepositoryV1Api
     */
    public customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody?: CustomerCustomerRepositoryV1SavePutBody1, options?: any) {
        return CustomerCustomerRepositoryV1ApiFp(this.configuration).customerCustomerRepositoryV1SavePut_2(customerCustomerRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerGroupManagementV1Api - fetch parameter creator
 * @export
 */
export const CustomerGroupManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get default customer group.
         * @param {number} storeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1GetDefaultGroupGet(storeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId','Required parameter storeId was null or undefined when calling customerGroupManagementV1GetDefaultGroupGet.');
            }
            const localVarPath = `/V1/customerGroups/default/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get default customer group.
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1GetDefaultGroupGet_1(storeId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customerGroups/default`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if customer group can be deleted.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1IsReadonlyGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customerGroupManagementV1IsReadonlyGet.');
            }
            const localVarPath = `/V1/customerGroups/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerGroupManagementV1Api - functional programming interface
 * @export
 */
export const CustomerGroupManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get default customer group.
         * @param {number} storeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1GetDefaultGroupGet(storeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataGroupInterface> {
            const localVarFetchArgs = CustomerGroupManagementV1ApiFetchParamCreator(configuration).customerGroupManagementV1GetDefaultGroupGet(storeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get default customer group.
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1GetDefaultGroupGet_1(storeId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataGroupInterface> {
            const localVarFetchArgs = CustomerGroupManagementV1ApiFetchParamCreator(configuration).customerGroupManagementV1GetDefaultGroupGet_1(storeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if customer group can be deleted.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1IsReadonlyGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerGroupManagementV1ApiFetchParamCreator(configuration).customerGroupManagementV1IsReadonlyGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerGroupManagementV1Api - factory interface
 * @export
 */
export const CustomerGroupManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get default customer group.
         * @param {number} storeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1GetDefaultGroupGet(storeId: number, options?: any) {
            return CustomerGroupManagementV1ApiFp(configuration).customerGroupManagementV1GetDefaultGroupGet(storeId, options)(fetch, basePath);
        },
        /**
         * Get default customer group.
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1GetDefaultGroupGet_1(storeId?: number, options?: any) {
            return CustomerGroupManagementV1ApiFp(configuration).customerGroupManagementV1GetDefaultGroupGet_1(storeId, options)(fetch, basePath);
        },
        /**
         * Check if customer group can be deleted.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupManagementV1IsReadonlyGet(id: number, options?: any) {
            return CustomerGroupManagementV1ApiFp(configuration).customerGroupManagementV1IsReadonlyGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerGroupManagementV1Api - object-oriented interface
 * @export
 * @class CustomerGroupManagementV1Api
 * @extends {BaseAPI}
 */
export class CustomerGroupManagementV1Api extends BaseAPI {
    /**
     * Get default customer group.
     * @param {number} storeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupManagementV1Api
     */
    public customerGroupManagementV1GetDefaultGroupGet(storeId: number, options?: any) {
        return CustomerGroupManagementV1ApiFp(this.configuration).customerGroupManagementV1GetDefaultGroupGet(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get default customer group.
     * @param {number} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupManagementV1Api
     */
    public customerGroupManagementV1GetDefaultGroupGet_1(storeId?: number, options?: any) {
        return CustomerGroupManagementV1ApiFp(this.configuration).customerGroupManagementV1GetDefaultGroupGet_1(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Check if customer group can be deleted.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupManagementV1Api
     */
    public customerGroupManagementV1IsReadonlyGet(id: number, options?: any) {
        return CustomerGroupManagementV1ApiFp(this.configuration).customerGroupManagementV1IsReadonlyGet(id, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerGroupRepositoryV1Api - fetch parameter creator
 * @export
 */
export const CustomerGroupRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete customer group by ID.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1DeleteByIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customerGroupRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/customerGroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customer group by group ID.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1GetByIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customerGroupRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/customerGroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customer groups. The list of groups can be filtered to exclude the NOT_LOGGED_IN group using the first parameter and/or it can be filtered by tax class. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#GroupRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customerGroups/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save customer group.
         * @param {CustomerGroupRepositoryV1SavePostBody} [customerGroupRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody?: CustomerGroupRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/customerGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerGroupRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerGroupRepositoryV1SavePostBody || {}) : (customerGroupRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save customer group.
         * @param {string} id
         * @param {CustomerGroupRepositoryV1SavePutBody} [customerGroupRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1SavePut(id: string, customerGroupRepositoryV1SavePutBody?: CustomerGroupRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customerGroupRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/customerGroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerGroupRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerGroupRepositoryV1SavePutBody || {}) : (customerGroupRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerGroupRepositoryV1Api - functional programming interface
 * @export
 */
export const CustomerGroupRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete customer group by ID.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1DeleteByIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CustomerGroupRepositoryV1ApiFetchParamCreator(configuration).customerGroupRepositoryV1DeleteByIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get customer group by group ID.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1GetByIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataGroupInterface> {
            const localVarFetchArgs = CustomerGroupRepositoryV1ApiFetchParamCreator(configuration).customerGroupRepositoryV1GetByIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve customer groups. The list of groups can be filtered to exclude the NOT_LOGGED_IN group using the first parameter and/or it can be filtered by tax class. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#GroupRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataGroupSearchResultsInterface> {
            const localVarFetchArgs = CustomerGroupRepositoryV1ApiFetchParamCreator(configuration).customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save customer group.
         * @param {CustomerGroupRepositoryV1SavePostBody} [customerGroupRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody?: CustomerGroupRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataGroupInterface> {
            const localVarFetchArgs = CustomerGroupRepositoryV1ApiFetchParamCreator(configuration).customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save customer group.
         * @param {string} id
         * @param {CustomerGroupRepositoryV1SavePutBody} [customerGroupRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1SavePut(id: string, customerGroupRepositoryV1SavePutBody?: CustomerGroupRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataGroupInterface> {
            const localVarFetchArgs = CustomerGroupRepositoryV1ApiFetchParamCreator(configuration).customerGroupRepositoryV1SavePut(id, customerGroupRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerGroupRepositoryV1Api - factory interface
 * @export
 */
export const CustomerGroupRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete customer group by ID.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1DeleteByIdDelete(id: number, options?: any) {
            return CustomerGroupRepositoryV1ApiFp(configuration).customerGroupRepositoryV1DeleteByIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get customer group by group ID.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1GetByIdGet(id: number, options?: any) {
            return CustomerGroupRepositoryV1ApiFp(configuration).customerGroupRepositoryV1GetByIdGet(id, options)(fetch, basePath);
        },
        /**
         * Retrieve customer groups. The list of groups can be filtered to exclude the NOT_LOGGED_IN group using the first parameter and/or it can be filtered by tax class. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#GroupRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return CustomerGroupRepositoryV1ApiFp(configuration).customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save customer group.
         * @param {CustomerGroupRepositoryV1SavePostBody} [customerGroupRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody?: CustomerGroupRepositoryV1SavePostBody, options?: any) {
            return CustomerGroupRepositoryV1ApiFp(configuration).customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save customer group.
         * @param {string} id
         * @param {CustomerGroupRepositoryV1SavePutBody} [customerGroupRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupRepositoryV1SavePut(id: string, customerGroupRepositoryV1SavePutBody?: CustomerGroupRepositoryV1SavePutBody, options?: any) {
            return CustomerGroupRepositoryV1ApiFp(configuration).customerGroupRepositoryV1SavePut(id, customerGroupRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerGroupRepositoryV1Api - object-oriented interface
 * @export
 * @class CustomerGroupRepositoryV1Api
 * @extends {BaseAPI}
 */
export class CustomerGroupRepositoryV1Api extends BaseAPI {
    /**
     * Delete customer group by ID.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupRepositoryV1Api
     */
    public customerGroupRepositoryV1DeleteByIdDelete(id: number, options?: any) {
        return CustomerGroupRepositoryV1ApiFp(this.configuration).customerGroupRepositoryV1DeleteByIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get customer group by group ID.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupRepositoryV1Api
     */
    public customerGroupRepositoryV1GetByIdGet(id: number, options?: any) {
        return CustomerGroupRepositoryV1ApiFp(this.configuration).customerGroupRepositoryV1GetByIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve customer groups. The list of groups can be filtered to exclude the NOT_LOGGED_IN group using the first parameter and/or it can be filtered by tax class. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#GroupRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupRepositoryV1Api
     */
    public customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return CustomerGroupRepositoryV1ApiFp(this.configuration).customerGroupRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save customer group.
     * @param {CustomerGroupRepositoryV1SavePostBody} [customerGroupRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupRepositoryV1Api
     */
    public customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody?: CustomerGroupRepositoryV1SavePostBody, options?: any) {
        return CustomerGroupRepositoryV1ApiFp(this.configuration).customerGroupRepositoryV1SavePost(customerGroupRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save customer group.
     * @param {string} id
     * @param {CustomerGroupRepositoryV1SavePutBody} [customerGroupRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupRepositoryV1Api
     */
    public customerGroupRepositoryV1SavePut(id: string, customerGroupRepositoryV1SavePutBody?: CustomerGroupRepositoryV1SavePutBody, options?: any) {
        return CustomerGroupRepositoryV1ApiFp(this.configuration).customerGroupRepositoryV1SavePut(id, customerGroupRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * DirectoryCountryInformationAcquirerV1Api - fetch parameter creator
 * @export
 */
export const DirectoryCountryInformationAcquirerV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all countries and regions information for the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCountryInformationAcquirerV1GetCountriesInfoGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/directory/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get country and region information for the store.
         * @param {string} countryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new RequiredError('countryId','Required parameter countryId was null or undefined when calling directoryCountryInformationAcquirerV1GetCountryInfoGet.');
            }
            const localVarPath = `/V1/directory/countries/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectoryCountryInformationAcquirerV1Api - functional programming interface
 * @export
 */
export const DirectoryCountryInformationAcquirerV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all countries and regions information for the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCountryInformationAcquirerV1GetCountriesInfoGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DirectoryDataCountryInformationInterface>> {
            const localVarFetchArgs = DirectoryCountryInformationAcquirerV1ApiFetchParamCreator(configuration).directoryCountryInformationAcquirerV1GetCountriesInfoGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get country and region information for the store.
         * @param {string} countryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectoryDataCountryInformationInterface> {
            const localVarFetchArgs = DirectoryCountryInformationAcquirerV1ApiFetchParamCreator(configuration).directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DirectoryCountryInformationAcquirerV1Api - factory interface
 * @export
 */
export const DirectoryCountryInformationAcquirerV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all countries and regions information for the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCountryInformationAcquirerV1GetCountriesInfoGet(options?: any) {
            return DirectoryCountryInformationAcquirerV1ApiFp(configuration).directoryCountryInformationAcquirerV1GetCountriesInfoGet(options)(fetch, basePath);
        },
        /**
         * Get country and region information for the store.
         * @param {string} countryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId: string, options?: any) {
            return DirectoryCountryInformationAcquirerV1ApiFp(configuration).directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId, options)(fetch, basePath);
        },
    };
};

/**
 * DirectoryCountryInformationAcquirerV1Api - object-oriented interface
 * @export
 * @class DirectoryCountryInformationAcquirerV1Api
 * @extends {BaseAPI}
 */
export class DirectoryCountryInformationAcquirerV1Api extends BaseAPI {
    /**
     * Get all countries and regions information for the store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectoryCountryInformationAcquirerV1Api
     */
    public directoryCountryInformationAcquirerV1GetCountriesInfoGet(options?: any) {
        return DirectoryCountryInformationAcquirerV1ApiFp(this.configuration).directoryCountryInformationAcquirerV1GetCountriesInfoGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get country and region information for the store.
     * @param {string} countryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectoryCountryInformationAcquirerV1Api
     */
    public directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId: string, options?: any) {
        return DirectoryCountryInformationAcquirerV1ApiFp(this.configuration).directoryCountryInformationAcquirerV1GetCountryInfoGet(countryId, options)(this.fetch, this.basePath);
    }

}

/**
 * DirectoryCurrencyInformationAcquirerV1Api - fetch parameter creator
 * @export
 */
export const DirectoryCurrencyInformationAcquirerV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get currency information for the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/directory/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectoryCurrencyInformationAcquirerV1Api - functional programming interface
 * @export
 */
export const DirectoryCurrencyInformationAcquirerV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get currency information for the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectoryDataCurrencyInformationInterface> {
            const localVarFetchArgs = DirectoryCurrencyInformationAcquirerV1ApiFetchParamCreator(configuration).directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DirectoryCurrencyInformationAcquirerV1Api - factory interface
 * @export
 */
export const DirectoryCurrencyInformationAcquirerV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get currency information for the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options?: any) {
            return DirectoryCurrencyInformationAcquirerV1ApiFp(configuration).directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options)(fetch, basePath);
        },
    };
};

/**
 * DirectoryCurrencyInformationAcquirerV1Api - object-oriented interface
 * @export
 * @class DirectoryCurrencyInformationAcquirerV1Api
 * @extends {BaseAPI}
 */
export class DirectoryCurrencyInformationAcquirerV1Api extends BaseAPI {
    /**
     * Get currency information for the store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectoryCurrencyInformationAcquirerV1Api
     */
    public directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options?: any) {
        return DirectoryCurrencyInformationAcquirerV1ApiFp(this.configuration).directoryCurrencyInformationAcquirerV1GetCurrencyInfoGet(options)(this.fetch, this.basePath);
    }

}

/**
 * DownloadableLinkRepositoryV1Api - fetch parameter creator
 * @export
 */
export const DownloadableLinkRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete downloadable link
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1DeleteDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadableLinkRepositoryV1DeleteDelete.');
            }
            const localVarPath = `/V1/products/downloadable-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of links with associated samples
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1GetListGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling downloadableLinkRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/products/{sku}/downloadable-links`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update downloadable link of the given product (link type and its resources cannot be changed)
         * @param {string} sku
         * @param {DownloadableLinkRepositoryV1SavePostBody} [downloadableLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1SavePost(sku: string, downloadableLinkRepositoryV1SavePostBody?: DownloadableLinkRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling downloadableLinkRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/products/{sku}/downloadable-links`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DownloadableLinkRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(downloadableLinkRepositoryV1SavePostBody || {}) : (downloadableLinkRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update downloadable link of the given product (link type and its resources cannot be changed)
         * @param {string} sku
         * @param {string} id
         * @param {DownloadableLinkRepositoryV1SavePutBody} [downloadableLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1SavePut(sku: string, id: string, downloadableLinkRepositoryV1SavePutBody?: DownloadableLinkRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling downloadableLinkRepositoryV1SavePut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadableLinkRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/{sku}/downloadable-links/{id}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DownloadableLinkRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(downloadableLinkRepositoryV1SavePutBody || {}) : (downloadableLinkRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DownloadableLinkRepositoryV1Api - functional programming interface
 * @export
 */
export const DownloadableLinkRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete downloadable link
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1DeleteDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = DownloadableLinkRepositoryV1ApiFetchParamCreator(configuration).downloadableLinkRepositoryV1DeleteDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of links with associated samples
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1GetListGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DownloadableDataLinkInterface>> {
            const localVarFetchArgs = DownloadableLinkRepositoryV1ApiFetchParamCreator(configuration).downloadableLinkRepositoryV1GetListGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update downloadable link of the given product (link type and its resources cannot be changed)
         * @param {string} sku
         * @param {DownloadableLinkRepositoryV1SavePostBody} [downloadableLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1SavePost(sku: string, downloadableLinkRepositoryV1SavePostBody?: DownloadableLinkRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = DownloadableLinkRepositoryV1ApiFetchParamCreator(configuration).downloadableLinkRepositoryV1SavePost(sku, downloadableLinkRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update downloadable link of the given product (link type and its resources cannot be changed)
         * @param {string} sku
         * @param {string} id
         * @param {DownloadableLinkRepositoryV1SavePutBody} [downloadableLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1SavePut(sku: string, id: string, downloadableLinkRepositoryV1SavePutBody?: DownloadableLinkRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = DownloadableLinkRepositoryV1ApiFetchParamCreator(configuration).downloadableLinkRepositoryV1SavePut(sku, id, downloadableLinkRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DownloadableLinkRepositoryV1Api - factory interface
 * @export
 */
export const DownloadableLinkRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete downloadable link
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1DeleteDelete(id: number, options?: any) {
            return DownloadableLinkRepositoryV1ApiFp(configuration).downloadableLinkRepositoryV1DeleteDelete(id, options)(fetch, basePath);
        },
        /**
         * List of links with associated samples
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1GetListGet(sku: string, options?: any) {
            return DownloadableLinkRepositoryV1ApiFp(configuration).downloadableLinkRepositoryV1GetListGet(sku, options)(fetch, basePath);
        },
        /**
         * Update downloadable link of the given product (link type and its resources cannot be changed)
         * @param {string} sku
         * @param {DownloadableLinkRepositoryV1SavePostBody} [downloadableLinkRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1SavePost(sku: string, downloadableLinkRepositoryV1SavePostBody?: DownloadableLinkRepositoryV1SavePostBody, options?: any) {
            return DownloadableLinkRepositoryV1ApiFp(configuration).downloadableLinkRepositoryV1SavePost(sku, downloadableLinkRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Update downloadable link of the given product (link type and its resources cannot be changed)
         * @param {string} sku
         * @param {string} id
         * @param {DownloadableLinkRepositoryV1SavePutBody} [downloadableLinkRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableLinkRepositoryV1SavePut(sku: string, id: string, downloadableLinkRepositoryV1SavePutBody?: DownloadableLinkRepositoryV1SavePutBody, options?: any) {
            return DownloadableLinkRepositoryV1ApiFp(configuration).downloadableLinkRepositoryV1SavePut(sku, id, downloadableLinkRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * DownloadableLinkRepositoryV1Api - object-oriented interface
 * @export
 * @class DownloadableLinkRepositoryV1Api
 * @extends {BaseAPI}
 */
export class DownloadableLinkRepositoryV1Api extends BaseAPI {
    /**
     * Delete downloadable link
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableLinkRepositoryV1Api
     */
    public downloadableLinkRepositoryV1DeleteDelete(id: number, options?: any) {
        return DownloadableLinkRepositoryV1ApiFp(this.configuration).downloadableLinkRepositoryV1DeleteDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * List of links with associated samples
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableLinkRepositoryV1Api
     */
    public downloadableLinkRepositoryV1GetListGet(sku: string, options?: any) {
        return DownloadableLinkRepositoryV1ApiFp(this.configuration).downloadableLinkRepositoryV1GetListGet(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Update downloadable link of the given product (link type and its resources cannot be changed)
     * @param {string} sku
     * @param {DownloadableLinkRepositoryV1SavePostBody} [downloadableLinkRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableLinkRepositoryV1Api
     */
    public downloadableLinkRepositoryV1SavePost(sku: string, downloadableLinkRepositoryV1SavePostBody?: DownloadableLinkRepositoryV1SavePostBody, options?: any) {
        return DownloadableLinkRepositoryV1ApiFp(this.configuration).downloadableLinkRepositoryV1SavePost(sku, downloadableLinkRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Update downloadable link of the given product (link type and its resources cannot be changed)
     * @param {string} sku
     * @param {string} id
     * @param {DownloadableLinkRepositoryV1SavePutBody} [downloadableLinkRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableLinkRepositoryV1Api
     */
    public downloadableLinkRepositoryV1SavePut(sku: string, id: string, downloadableLinkRepositoryV1SavePutBody?: DownloadableLinkRepositoryV1SavePutBody, options?: any) {
        return DownloadableLinkRepositoryV1ApiFp(this.configuration).downloadableLinkRepositoryV1SavePut(sku, id, downloadableLinkRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * DownloadableSampleRepositoryV1Api - fetch parameter creator
 * @export
 */
export const DownloadableSampleRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete downloadable sample
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1DeleteDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadableSampleRepositoryV1DeleteDelete.');
            }
            const localVarPath = `/V1/products/downloadable-links/samples/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of samples for downloadable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1GetListGet(sku: string, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling downloadableSampleRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/products/{sku}/downloadable-links/samples`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update downloadable sample of the given product
         * @param {string} sku
         * @param {DownloadableSampleRepositoryV1SavePostBody} [downloadableSampleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1SavePost(sku: string, downloadableSampleRepositoryV1SavePostBody?: DownloadableSampleRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling downloadableSampleRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/products/{sku}/downloadable-links/samples`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DownloadableSampleRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(downloadableSampleRepositoryV1SavePostBody || {}) : (downloadableSampleRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update downloadable sample of the given product
         * @param {string} sku
         * @param {string} id
         * @param {DownloadableSampleRepositoryV1SavePutBody} [downloadableSampleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1SavePut(sku: string, id: string, downloadableSampleRepositoryV1SavePutBody?: DownloadableSampleRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling downloadableSampleRepositoryV1SavePut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadableSampleRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/products/{sku}/downloadable-links/samples/{id}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DownloadableSampleRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(downloadableSampleRepositoryV1SavePutBody || {}) : (downloadableSampleRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DownloadableSampleRepositoryV1Api - functional programming interface
 * @export
 */
export const DownloadableSampleRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete downloadable sample
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1DeleteDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = DownloadableSampleRepositoryV1ApiFetchParamCreator(configuration).downloadableSampleRepositoryV1DeleteDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of samples for downloadable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1GetListGet(sku: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DownloadableDataSampleInterface>> {
            const localVarFetchArgs = DownloadableSampleRepositoryV1ApiFetchParamCreator(configuration).downloadableSampleRepositoryV1GetListGet(sku, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update downloadable sample of the given product
         * @param {string} sku
         * @param {DownloadableSampleRepositoryV1SavePostBody} [downloadableSampleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1SavePost(sku: string, downloadableSampleRepositoryV1SavePostBody?: DownloadableSampleRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = DownloadableSampleRepositoryV1ApiFetchParamCreator(configuration).downloadableSampleRepositoryV1SavePost(sku, downloadableSampleRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update downloadable sample of the given product
         * @param {string} sku
         * @param {string} id
         * @param {DownloadableSampleRepositoryV1SavePutBody} [downloadableSampleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1SavePut(sku: string, id: string, downloadableSampleRepositoryV1SavePutBody?: DownloadableSampleRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = DownloadableSampleRepositoryV1ApiFetchParamCreator(configuration).downloadableSampleRepositoryV1SavePut(sku, id, downloadableSampleRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DownloadableSampleRepositoryV1Api - factory interface
 * @export
 */
export const DownloadableSampleRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete downloadable sample
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1DeleteDelete(id: number, options?: any) {
            return DownloadableSampleRepositoryV1ApiFp(configuration).downloadableSampleRepositoryV1DeleteDelete(id, options)(fetch, basePath);
        },
        /**
         * List of samples for downloadable product
         * @param {string} sku
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1GetListGet(sku: string, options?: any) {
            return DownloadableSampleRepositoryV1ApiFp(configuration).downloadableSampleRepositoryV1GetListGet(sku, options)(fetch, basePath);
        },
        /**
         * Update downloadable sample of the given product
         * @param {string} sku
         * @param {DownloadableSampleRepositoryV1SavePostBody} [downloadableSampleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1SavePost(sku: string, downloadableSampleRepositoryV1SavePostBody?: DownloadableSampleRepositoryV1SavePostBody, options?: any) {
            return DownloadableSampleRepositoryV1ApiFp(configuration).downloadableSampleRepositoryV1SavePost(sku, downloadableSampleRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Update downloadable sample of the given product
         * @param {string} sku
         * @param {string} id
         * @param {DownloadableSampleRepositoryV1SavePutBody} [downloadableSampleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadableSampleRepositoryV1SavePut(sku: string, id: string, downloadableSampleRepositoryV1SavePutBody?: DownloadableSampleRepositoryV1SavePutBody, options?: any) {
            return DownloadableSampleRepositoryV1ApiFp(configuration).downloadableSampleRepositoryV1SavePut(sku, id, downloadableSampleRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * DownloadableSampleRepositoryV1Api - object-oriented interface
 * @export
 * @class DownloadableSampleRepositoryV1Api
 * @extends {BaseAPI}
 */
export class DownloadableSampleRepositoryV1Api extends BaseAPI {
    /**
     * Delete downloadable sample
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableSampleRepositoryV1Api
     */
    public downloadableSampleRepositoryV1DeleteDelete(id: number, options?: any) {
        return DownloadableSampleRepositoryV1ApiFp(this.configuration).downloadableSampleRepositoryV1DeleteDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * List of samples for downloadable product
     * @param {string} sku
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableSampleRepositoryV1Api
     */
    public downloadableSampleRepositoryV1GetListGet(sku: string, options?: any) {
        return DownloadableSampleRepositoryV1ApiFp(this.configuration).downloadableSampleRepositoryV1GetListGet(sku, options)(this.fetch, this.basePath);
    }

    /**
     * Update downloadable sample of the given product
     * @param {string} sku
     * @param {DownloadableSampleRepositoryV1SavePostBody} [downloadableSampleRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableSampleRepositoryV1Api
     */
    public downloadableSampleRepositoryV1SavePost(sku: string, downloadableSampleRepositoryV1SavePostBody?: DownloadableSampleRepositoryV1SavePostBody, options?: any) {
        return DownloadableSampleRepositoryV1ApiFp(this.configuration).downloadableSampleRepositoryV1SavePost(sku, downloadableSampleRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Update downloadable sample of the given product
     * @param {string} sku
     * @param {string} id
     * @param {DownloadableSampleRepositoryV1SavePutBody} [downloadableSampleRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DownloadableSampleRepositoryV1Api
     */
    public downloadableSampleRepositoryV1SavePut(sku: string, id: string, downloadableSampleRepositoryV1SavePutBody?: DownloadableSampleRepositoryV1SavePutBody, options?: any) {
        return DownloadableSampleRepositoryV1ApiFp(this.configuration).downloadableSampleRepositoryV1SavePut(sku, id, downloadableSampleRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * EavAttributeSetManagementV1Api - fetch parameter creator
 * @export
 */
export const EavAttributeSetManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create attribute set from data
         * @param {EavAttributeSetManagementV1CreatePostBody} [eavAttributeSetManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody?: EavAttributeSetManagementV1CreatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/eav/attribute-sets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EavAttributeSetManagementV1CreatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(eavAttributeSetManagementV1CreatePostBody || {}) : (eavAttributeSetManagementV1CreatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EavAttributeSetManagementV1Api - functional programming interface
 * @export
 */
export const EavAttributeSetManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create attribute set from data
         * @param {EavAttributeSetManagementV1CreatePostBody} [eavAttributeSetManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody?: EavAttributeSetManagementV1CreatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetInterface> {
            const localVarFetchArgs = EavAttributeSetManagementV1ApiFetchParamCreator(configuration).eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EavAttributeSetManagementV1Api - factory interface
 * @export
 */
export const EavAttributeSetManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create attribute set from data
         * @param {EavAttributeSetManagementV1CreatePostBody} [eavAttributeSetManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody?: EavAttributeSetManagementV1CreatePostBody, options?: any) {
            return EavAttributeSetManagementV1ApiFp(configuration).eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * EavAttributeSetManagementV1Api - object-oriented interface
 * @export
 * @class EavAttributeSetManagementV1Api
 * @extends {BaseAPI}
 */
export class EavAttributeSetManagementV1Api extends BaseAPI {
    /**
     * Create attribute set from data
     * @param {EavAttributeSetManagementV1CreatePostBody} [eavAttributeSetManagementV1CreatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EavAttributeSetManagementV1Api
     */
    public eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody?: EavAttributeSetManagementV1CreatePostBody, options?: any) {
        return EavAttributeSetManagementV1ApiFp(this.configuration).eavAttributeSetManagementV1CreatePost(eavAttributeSetManagementV1CreatePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * EavAttributeSetRepositoryV1Api - fetch parameter creator
 * @export
 */
export const EavAttributeSetRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove attribute set by given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling eavAttributeSetRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/eav/attribute-sets/{attributeSetId}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve attribute set information based on given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1GetGet(attributeSetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling eavAttributeSetRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/eav/attribute-sets/{attributeSetId}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of Attribute Sets This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#AttributeSetRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/eav/attribute-sets/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save attribute set data
         * @param {string} attributeSetId
         * @param {EavAttributeSetRepositoryV1SavePutBody} [eavAttributeSetRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1SavePut(attributeSetId: string, eavAttributeSetRepositoryV1SavePutBody?: EavAttributeSetRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'attributeSetId' is not null or undefined
            if (attributeSetId === null || attributeSetId === undefined) {
                throw new RequiredError('attributeSetId','Required parameter attributeSetId was null or undefined when calling eavAttributeSetRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/eav/attribute-sets/{attributeSetId}`
                .replace(`{${"attributeSetId"}}`, encodeURIComponent(String(attributeSetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EavAttributeSetRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(eavAttributeSetRepositoryV1SavePutBody || {}) : (eavAttributeSetRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EavAttributeSetRepositoryV1Api - functional programming interface
 * @export
 */
export const EavAttributeSetRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove attribute set by given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = EavAttributeSetRepositoryV1ApiFetchParamCreator(configuration).eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve attribute set information based on given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1GetGet(attributeSetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetInterface> {
            const localVarFetchArgs = EavAttributeSetRepositoryV1ApiFetchParamCreator(configuration).eavAttributeSetRepositoryV1GetGet(attributeSetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve list of Attribute Sets This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#AttributeSetRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetSearchResultsInterface> {
            const localVarFetchArgs = EavAttributeSetRepositoryV1ApiFetchParamCreator(configuration).eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save attribute set data
         * @param {string} attributeSetId
         * @param {EavAttributeSetRepositoryV1SavePutBody} [eavAttributeSetRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1SavePut(attributeSetId: string, eavAttributeSetRepositoryV1SavePutBody?: EavAttributeSetRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EavDataAttributeSetInterface> {
            const localVarFetchArgs = EavAttributeSetRepositoryV1ApiFetchParamCreator(configuration).eavAttributeSetRepositoryV1SavePut(attributeSetId, eavAttributeSetRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EavAttributeSetRepositoryV1Api - factory interface
 * @export
 */
export const EavAttributeSetRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove attribute set by given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options?: any) {
            return EavAttributeSetRepositoryV1ApiFp(configuration).eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId, options)(fetch, basePath);
        },
        /**
         * Retrieve attribute set information based on given ID
         * @param {number} attributeSetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1GetGet(attributeSetId: number, options?: any) {
            return EavAttributeSetRepositoryV1ApiFp(configuration).eavAttributeSetRepositoryV1GetGet(attributeSetId, options)(fetch, basePath);
        },
        /**
         * Retrieve list of Attribute Sets This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#AttributeSetRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return EavAttributeSetRepositoryV1ApiFp(configuration).eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save attribute set data
         * @param {string} attributeSetId
         * @param {EavAttributeSetRepositoryV1SavePutBody} [eavAttributeSetRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eavAttributeSetRepositoryV1SavePut(attributeSetId: string, eavAttributeSetRepositoryV1SavePutBody?: EavAttributeSetRepositoryV1SavePutBody, options?: any) {
            return EavAttributeSetRepositoryV1ApiFp(configuration).eavAttributeSetRepositoryV1SavePut(attributeSetId, eavAttributeSetRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * EavAttributeSetRepositoryV1Api - object-oriented interface
 * @export
 * @class EavAttributeSetRepositoryV1Api
 * @extends {BaseAPI}
 */
export class EavAttributeSetRepositoryV1Api extends BaseAPI {
    /**
     * Remove attribute set by given ID
     * @param {number} attributeSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EavAttributeSetRepositoryV1Api
     */
    public eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId: number, options?: any) {
        return EavAttributeSetRepositoryV1ApiFp(this.configuration).eavAttributeSetRepositoryV1DeleteByIdDelete(attributeSetId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve attribute set information based on given ID
     * @param {number} attributeSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EavAttributeSetRepositoryV1Api
     */
    public eavAttributeSetRepositoryV1GetGet(attributeSetId: number, options?: any) {
        return EavAttributeSetRepositoryV1ApiFp(this.configuration).eavAttributeSetRepositoryV1GetGet(attributeSetId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve list of Attribute Sets This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#AttributeSetRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EavAttributeSetRepositoryV1Api
     */
    public eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return EavAttributeSetRepositoryV1ApiFp(this.configuration).eavAttributeSetRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save attribute set data
     * @param {string} attributeSetId
     * @param {EavAttributeSetRepositoryV1SavePutBody} [eavAttributeSetRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EavAttributeSetRepositoryV1Api
     */
    public eavAttributeSetRepositoryV1SavePut(attributeSetId: string, eavAttributeSetRepositoryV1SavePutBody?: EavAttributeSetRepositoryV1SavePutBody, options?: any) {
        return EavAttributeSetRepositoryV1ApiFp(this.configuration).eavAttributeSetRepositoryV1SavePut(attributeSetId, eavAttributeSetRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftCardAccountGiftCardAccountManagementV1Api - fetch parameter creator
 * @export
 */
export const GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'giftCardCode' is not null or undefined
            if (giftCardCode === null || giftCardCode === undefined) {
                throw new RequiredError('giftCardCode','Required parameter giftCardCode was null or undefined when calling giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet.');
            }
            const localVarPath = `/V1/carts/mine/checkGiftCard/{giftCardCode}`
                .replace(`{${"giftCardCode"}}`, encodeURIComponent(String(giftCardCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove GiftCard Account entity
         * @param {number} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete.');
            }
            // verify required parameter 'giftCardCode' is not null or undefined
            if (giftCardCode === null || giftCardCode === undefined) {
                throw new RequiredError('giftCardCode','Required parameter giftCardCode was null or undefined when calling giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete.');
            }
            const localVarPath = `/V1/carts/{cartId}/giftCards/{giftCardCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"giftCardCode"}}`, encodeURIComponent(String(giftCardCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove GiftCard Account entity
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'giftCardCode' is not null or undefined
            if (giftCardCode === null || giftCardCode === undefined) {
                throw new RequiredError('giftCardCode','Required parameter giftCardCode was null or undefined when calling giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1.');
            }
            const localVarPath = `/V1/carts/mine/giftCards/{giftCardCode}`
                .replace(`{${"giftCardCode"}}`, encodeURIComponent(String(giftCardCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return GiftCard Account cards
         * @param {number} quoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId: number, options: any = {}): FetchArgs {
            // verify required parameter 'quoteId' is not null or undefined
            if (quoteId === null || quoteId === undefined) {
                throw new RequiredError('quoteId','Required parameter quoteId was null or undefined when calling giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet.');
            }
            const localVarPath = `/V1/carts/{quoteId}/giftCards`
                .replace(`{${"quoteId"}}`, encodeURIComponent(String(quoteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/giftCards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody || {}) : (giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} cartId
         * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId: number, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut.');
            }
            const localVarPath = `/V1/carts/{cartId}/giftCards`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody || {}) : (giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftCardAccountGiftCardAccountManagementV1Api - functional programming interface
 * @export
 */
export const GiftCardAccountGiftCardAccountManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove GiftCard Account entity
         * @param {number} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove GiftCard Account entity
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return GiftCard Account cards
         * @param {number} quoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftCardAccountDataGiftCardAccountInterface> {
            const localVarFetchArgs = GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} cartId
         * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId: number, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftCardAccountGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftCardAccountGiftCardAccountManagementV1Api - factory interface
 * @export
 */
export const GiftCardAccountGiftCardAccountManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode: string, options?: any) {
            return GiftCardAccountGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode, options)(fetch, basePath);
        },
        /**
         * Remove GiftCard Account entity
         * @param {number} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options?: any) {
            return GiftCardAccountGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options)(fetch, basePath);
        },
        /**
         * Remove GiftCard Account entity
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode: string, options?: any) {
            return GiftCardAccountGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode, options)(fetch, basePath);
        },
        /**
         * Return GiftCard Account cards
         * @param {number} quoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId: number, options?: any) {
            return GiftCardAccountGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId, options)(fetch, basePath);
        },
        /**
         *
         * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options?: any) {
            return GiftCardAccountGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} cartId
         * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId: number, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options?: any) {
            return GiftCardAccountGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftCardAccountGiftCardAccountManagementV1Api - object-oriented interface
 * @export
 * @class GiftCardAccountGiftCardAccountManagementV1Api
 * @extends {BaseAPI}
 */
export class GiftCardAccountGiftCardAccountManagementV1Api extends BaseAPI {
    /**
     *
     * @param {string} giftCardCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGiftCardAccountManagementV1Api
     */
    public giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode: string, options?: any) {
        return GiftCardAccountGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGiftCardAccountManagementV1CheckGiftCardGet(giftCardCode, options)(this.fetch, this.basePath);
    }

    /**
     * Remove GiftCard Account entity
     * @param {number} cartId
     * @param {string} giftCardCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGiftCardAccountManagementV1Api
     */
    public giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options?: any) {
        return GiftCardAccountGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options)(this.fetch, this.basePath);
    }

    /**
     * Remove GiftCard Account entity
     * @param {string} giftCardCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGiftCardAccountManagementV1Api
     */
    public giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode: string, options?: any) {
        return GiftCardAccountGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGiftCardAccountManagementV1DeleteByQuoteIdDelete_1(giftCardCode, options)(this.fetch, this.basePath);
    }

    /**
     * Return GiftCard Account cards
     * @param {number} quoteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGiftCardAccountManagementV1Api
     */
    public giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId: number, options?: any) {
        return GiftCardAccountGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGiftCardAccountManagementV1GetListByQuoteIdGet(quoteId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGiftCardAccountManagementV1Api
     */
    public giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options?: any) {
        return GiftCardAccountGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPost(giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPostBody, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} cartId
     * @param {GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody} [giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGiftCardAccountManagementV1Api
     */
    public giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId: number, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody?: GiftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options?: any) {
        return GiftCardAccountGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPut(cartId, giftCardAccountGiftCardAccountManagementV1SaveByQuoteIdPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftCardAccountGuestGiftCardAccountManagementV1Api - fetch parameter creator
 * @export
 */
export const GiftCardAccountGuestGiftCardAccountManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} cartId
         * @param {GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody} [giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId: string, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody?: GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost.');
            }
            const localVarPath = `/V1/carts/guest-carts/{cartId}/giftCards`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody || {}) : (giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId: string, giftCardCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet.');
            }
            // verify required parameter 'giftCardCode' is not null or undefined
            if (giftCardCode === null || giftCardCode === undefined) {
                throw new RequiredError('giftCardCode','Required parameter giftCardCode was null or undefined when calling giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet.');
            }
            const localVarPath = `/V1/carts/guest-carts/{cartId}/checkGiftCard/{giftCardCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"giftCardCode"}}`, encodeURIComponent(String(giftCardCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove GiftCard Account entity
         * @param {string} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: string, giftCardCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete.');
            }
            // verify required parameter 'giftCardCode' is not null or undefined
            if (giftCardCode === null || giftCardCode === undefined) {
                throw new RequiredError('giftCardCode','Required parameter giftCardCode was null or undefined when calling giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete.');
            }
            const localVarPath = `/V1/carts/guest-carts/{cartId}/giftCards/{giftCardCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"giftCardCode"}}`, encodeURIComponent(String(giftCardCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftCardAccountGuestGiftCardAccountManagementV1Api - functional programming interface
 * @export
 */
export const GiftCardAccountGuestGiftCardAccountManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} cartId
         * @param {GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody} [giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId: string, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody?: GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftCardAccountGuestGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId: string, giftCardCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = GiftCardAccountGuestGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId, giftCardCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove GiftCard Account entity
         * @param {string} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: string, giftCardCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftCardAccountGuestGiftCardAccountManagementV1ApiFetchParamCreator(configuration).giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftCardAccountGuestGiftCardAccountManagementV1Api - factory interface
 * @export
 */
export const GiftCardAccountGuestGiftCardAccountManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} cartId
         * @param {GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody} [giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId: string, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody?: GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options?: any) {
            return GiftCardAccountGuestGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId: string, giftCardCode: string, options?: any) {
            return GiftCardAccountGuestGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId, giftCardCode, options)(fetch, basePath);
        },
        /**
         * Remove GiftCard Account entity
         * @param {string} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: string, giftCardCode: string, options?: any) {
            return GiftCardAccountGuestGiftCardAccountManagementV1ApiFp(configuration).giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options)(fetch, basePath);
        },
    };
};

/**
 * GiftCardAccountGuestGiftCardAccountManagementV1Api - object-oriented interface
 * @export
 * @class GiftCardAccountGuestGiftCardAccountManagementV1Api
 * @extends {BaseAPI}
 */
export class GiftCardAccountGuestGiftCardAccountManagementV1Api extends BaseAPI {
    /**
     *
     * @param {string} cartId
     * @param {GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody} [giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGuestGiftCardAccountManagementV1Api
     */
    public giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId: string, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody?: GiftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options?: any) {
        return GiftCardAccountGuestGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPost(cartId, giftCardAccountGuestGiftCardAccountManagementV1AddGiftCardPostBody, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} cartId
     * @param {string} giftCardCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGuestGiftCardAccountManagementV1Api
     */
    public giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId: string, giftCardCode: string, options?: any) {
        return GiftCardAccountGuestGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGuestGiftCardAccountManagementV1CheckGiftCardGet(cartId, giftCardCode, options)(this.fetch, this.basePath);
    }

    /**
     * Remove GiftCard Account entity
     * @param {string} cartId
     * @param {string} giftCardCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftCardAccountGuestGiftCardAccountManagementV1Api
     */
    public giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: string, giftCardCode: string, options?: any) {
        return GiftCardAccountGuestGiftCardAccountManagementV1ApiFp(this.configuration).giftCardAccountGuestGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftMessageCartRepositoryV1Api - fetch parameter creator
 * @export
 */
export const GiftMessageCartRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified order.
         * @param {number} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageCartRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/gift-message`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the gift message for a specified order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1GetGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/gift-message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the gift message for an entire order.
         * @param {number} cartId The cart ID.
         * @param {GiftMessageCartRepositoryV1SavePostBody} [giftMessageCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1SavePost(cartId: number, giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageCartRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/carts/{cartId}/gift-message`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftMessageCartRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftMessageCartRepositoryV1SavePostBody || {}) : (giftMessageCartRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the gift message for an entire order.
         * @param {GiftMessageCartRepositoryV1SavePostBody1} [giftMessageCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/gift-message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftMessageCartRepositoryV1SavePostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftMessageCartRepositoryV1SavePostBody || {}) : (giftMessageCartRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftMessageCartRepositoryV1Api - functional programming interface
 * @export
 */
export const GiftMessageCartRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified order.
         * @param {number} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftMessageDataMessageInterface> {
            const localVarFetchArgs = GiftMessageCartRepositoryV1ApiFetchParamCreator(configuration).giftMessageCartRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the gift message for a specified order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1GetGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftMessageDataMessageInterface> {
            const localVarFetchArgs = GiftMessageCartRepositoryV1ApiFetchParamCreator(configuration).giftMessageCartRepositoryV1GetGet_1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the gift message for an entire order.
         * @param {number} cartId The cart ID.
         * @param {GiftMessageCartRepositoryV1SavePostBody} [giftMessageCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1SavePost(cartId: number, giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftMessageCartRepositoryV1ApiFetchParamCreator(configuration).giftMessageCartRepositoryV1SavePost(cartId, giftMessageCartRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the gift message for an entire order.
         * @param {GiftMessageCartRepositoryV1SavePostBody1} [giftMessageCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftMessageCartRepositoryV1ApiFetchParamCreator(configuration).giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftMessageCartRepositoryV1Api - factory interface
 * @export
 */
export const GiftMessageCartRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return the gift message for a specified order.
         * @param {number} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1GetGet(cartId: number, options?: any) {
            return GiftMessageCartRepositoryV1ApiFp(configuration).giftMessageCartRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Return the gift message for a specified order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1GetGet_1(options?: any) {
            return GiftMessageCartRepositoryV1ApiFp(configuration).giftMessageCartRepositoryV1GetGet_1(options)(fetch, basePath);
        },
        /**
         * Set the gift message for an entire order.
         * @param {number} cartId The cart ID.
         * @param {GiftMessageCartRepositoryV1SavePostBody} [giftMessageCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1SavePost(cartId: number, giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody, options?: any) {
            return GiftMessageCartRepositoryV1ApiFp(configuration).giftMessageCartRepositoryV1SavePost(cartId, giftMessageCartRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Set the gift message for an entire order.
         * @param {GiftMessageCartRepositoryV1SavePostBody1} [giftMessageCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody1, options?: any) {
            return GiftMessageCartRepositoryV1ApiFp(configuration).giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftMessageCartRepositoryV1Api - object-oriented interface
 * @export
 * @class GiftMessageCartRepositoryV1Api
 * @extends {BaseAPI}
 */
export class GiftMessageCartRepositoryV1Api extends BaseAPI {
    /**
     * Return the gift message for a specified order.
     * @param {number} cartId The shopping cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageCartRepositoryV1Api
     */
    public giftMessageCartRepositoryV1GetGet(cartId: number, options?: any) {
        return GiftMessageCartRepositoryV1ApiFp(this.configuration).giftMessageCartRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Return the gift message for a specified order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageCartRepositoryV1Api
     */
    public giftMessageCartRepositoryV1GetGet_1(options?: any) {
        return GiftMessageCartRepositoryV1ApiFp(this.configuration).giftMessageCartRepositoryV1GetGet_1(options)(this.fetch, this.basePath);
    }

    /**
     * Set the gift message for an entire order.
     * @param {number} cartId The cart ID.
     * @param {GiftMessageCartRepositoryV1SavePostBody} [giftMessageCartRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageCartRepositoryV1Api
     */
    public giftMessageCartRepositoryV1SavePost(cartId: number, giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody, options?: any) {
        return GiftMessageCartRepositoryV1ApiFp(this.configuration).giftMessageCartRepositoryV1SavePost(cartId, giftMessageCartRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Set the gift message for an entire order.
     * @param {GiftMessageCartRepositoryV1SavePostBody1} [giftMessageCartRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageCartRepositoryV1Api
     */
    public giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody?: GiftMessageCartRepositoryV1SavePostBody1, options?: any) {
        return GiftMessageCartRepositoryV1ApiFp(this.configuration).giftMessageCartRepositoryV1SavePost_2(giftMessageCartRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftMessageGuestCartRepositoryV1Api - fetch parameter creator
 * @export
 */
export const GiftMessageGuestCartRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified order.
         * @param {string} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestCartRepositoryV1GetGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageGuestCartRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/gift-message`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the gift message for an entire order.
         * @param {string} cartId The cart ID.
         * @param {GiftMessageGuestCartRepositoryV1SavePostBody} [giftMessageGuestCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestCartRepositoryV1SavePost(cartId: string, giftMessageGuestCartRepositoryV1SavePostBody?: GiftMessageGuestCartRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageGuestCartRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/gift-message`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftMessageGuestCartRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftMessageGuestCartRepositoryV1SavePostBody || {}) : (giftMessageGuestCartRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftMessageGuestCartRepositoryV1Api - functional programming interface
 * @export
 */
export const GiftMessageGuestCartRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified order.
         * @param {string} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestCartRepositoryV1GetGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftMessageDataMessageInterface> {
            const localVarFetchArgs = GiftMessageGuestCartRepositoryV1ApiFetchParamCreator(configuration).giftMessageGuestCartRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the gift message for an entire order.
         * @param {string} cartId The cart ID.
         * @param {GiftMessageGuestCartRepositoryV1SavePostBody} [giftMessageGuestCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestCartRepositoryV1SavePost(cartId: string, giftMessageGuestCartRepositoryV1SavePostBody?: GiftMessageGuestCartRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftMessageGuestCartRepositoryV1ApiFetchParamCreator(configuration).giftMessageGuestCartRepositoryV1SavePost(cartId, giftMessageGuestCartRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftMessageGuestCartRepositoryV1Api - factory interface
 * @export
 */
export const GiftMessageGuestCartRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return the gift message for a specified order.
         * @param {string} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestCartRepositoryV1GetGet(cartId: string, options?: any) {
            return GiftMessageGuestCartRepositoryV1ApiFp(configuration).giftMessageGuestCartRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Set the gift message for an entire order.
         * @param {string} cartId The cart ID.
         * @param {GiftMessageGuestCartRepositoryV1SavePostBody} [giftMessageGuestCartRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestCartRepositoryV1SavePost(cartId: string, giftMessageGuestCartRepositoryV1SavePostBody?: GiftMessageGuestCartRepositoryV1SavePostBody, options?: any) {
            return GiftMessageGuestCartRepositoryV1ApiFp(configuration).giftMessageGuestCartRepositoryV1SavePost(cartId, giftMessageGuestCartRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftMessageGuestCartRepositoryV1Api - object-oriented interface
 * @export
 * @class GiftMessageGuestCartRepositoryV1Api
 * @extends {BaseAPI}
 */
export class GiftMessageGuestCartRepositoryV1Api extends BaseAPI {
    /**
     * Return the gift message for a specified order.
     * @param {string} cartId The shopping cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageGuestCartRepositoryV1Api
     */
    public giftMessageGuestCartRepositoryV1GetGet(cartId: string, options?: any) {
        return GiftMessageGuestCartRepositoryV1ApiFp(this.configuration).giftMessageGuestCartRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Set the gift message for an entire order.
     * @param {string} cartId The cart ID.
     * @param {GiftMessageGuestCartRepositoryV1SavePostBody} [giftMessageGuestCartRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageGuestCartRepositoryV1Api
     */
    public giftMessageGuestCartRepositoryV1SavePost(cartId: string, giftMessageGuestCartRepositoryV1SavePostBody?: GiftMessageGuestCartRepositoryV1SavePostBody, options?: any) {
        return GiftMessageGuestCartRepositoryV1ApiFp(this.configuration).giftMessageGuestCartRepositoryV1SavePost(cartId, giftMessageGuestCartRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftMessageGuestItemRepositoryV1Api - fetch parameter creator
 * @export
 */
export const GiftMessageGuestItemRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {string} cartId The shopping cart ID.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestItemRepositoryV1GetGet(cartId: string, itemId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageGuestItemRepositoryV1GetGet.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling giftMessageGuestItemRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/gift-message/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {number} itemId The item ID.
         * @param {GiftMessageGuestItemRepositoryV1SavePostBody} [giftMessageGuestItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestItemRepositoryV1SavePost(cartId: string, itemId: number, giftMessageGuestItemRepositoryV1SavePostBody?: GiftMessageGuestItemRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageGuestItemRepositoryV1SavePost.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling giftMessageGuestItemRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/gift-message/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftMessageGuestItemRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftMessageGuestItemRepositoryV1SavePostBody || {}) : (giftMessageGuestItemRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftMessageGuestItemRepositoryV1Api - functional programming interface
 * @export
 */
export const GiftMessageGuestItemRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {string} cartId The shopping cart ID.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestItemRepositoryV1GetGet(cartId: string, itemId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftMessageDataMessageInterface> {
            const localVarFetchArgs = GiftMessageGuestItemRepositoryV1ApiFetchParamCreator(configuration).giftMessageGuestItemRepositoryV1GetGet(cartId, itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {number} itemId The item ID.
         * @param {GiftMessageGuestItemRepositoryV1SavePostBody} [giftMessageGuestItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestItemRepositoryV1SavePost(cartId: string, itemId: number, giftMessageGuestItemRepositoryV1SavePostBody?: GiftMessageGuestItemRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftMessageGuestItemRepositoryV1ApiFetchParamCreator(configuration).giftMessageGuestItemRepositoryV1SavePost(cartId, itemId, giftMessageGuestItemRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftMessageGuestItemRepositoryV1Api - factory interface
 * @export
 */
export const GiftMessageGuestItemRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {string} cartId The shopping cart ID.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestItemRepositoryV1GetGet(cartId: string, itemId: number, options?: any) {
            return GiftMessageGuestItemRepositoryV1ApiFp(configuration).giftMessageGuestItemRepositoryV1GetGet(cartId, itemId, options)(fetch, basePath);
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {number} itemId The item ID.
         * @param {GiftMessageGuestItemRepositoryV1SavePostBody} [giftMessageGuestItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageGuestItemRepositoryV1SavePost(cartId: string, itemId: number, giftMessageGuestItemRepositoryV1SavePostBody?: GiftMessageGuestItemRepositoryV1SavePostBody, options?: any) {
            return GiftMessageGuestItemRepositoryV1ApiFp(configuration).giftMessageGuestItemRepositoryV1SavePost(cartId, itemId, giftMessageGuestItemRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftMessageGuestItemRepositoryV1Api - object-oriented interface
 * @export
 * @class GiftMessageGuestItemRepositoryV1Api
 * @extends {BaseAPI}
 */
export class GiftMessageGuestItemRepositoryV1Api extends BaseAPI {
    /**
     * Return the gift message for a specified item in a specified shopping cart.
     * @param {string} cartId The shopping cart ID.
     * @param {number} itemId The item ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageGuestItemRepositoryV1Api
     */
    public giftMessageGuestItemRepositoryV1GetGet(cartId: string, itemId: number, options?: any) {
        return GiftMessageGuestItemRepositoryV1ApiFp(this.configuration).giftMessageGuestItemRepositoryV1GetGet(cartId, itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Set the gift message for a specified item in a specified shopping cart.
     * @param {string} cartId The cart ID.
     * @param {number} itemId The item ID.
     * @param {GiftMessageGuestItemRepositoryV1SavePostBody} [giftMessageGuestItemRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageGuestItemRepositoryV1Api
     */
    public giftMessageGuestItemRepositoryV1SavePost(cartId: string, itemId: number, giftMessageGuestItemRepositoryV1SavePostBody?: GiftMessageGuestItemRepositoryV1SavePostBody, options?: any) {
        return GiftMessageGuestItemRepositoryV1ApiFp(this.configuration).giftMessageGuestItemRepositoryV1SavePost(cartId, itemId, giftMessageGuestItemRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftMessageItemRepositoryV1Api - fetch parameter creator
 * @export
 */
export const GiftMessageItemRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {number} cartId The shopping cart ID.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1GetGet(cartId: number, itemId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageItemRepositoryV1GetGet.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling giftMessageItemRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/gift-message/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1GetGet_1(itemId: number, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling giftMessageItemRepositoryV1GetGet_1.');
            }
            const localVarPath = `/V1/carts/mine/gift-message/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {number} itemId The item ID.
         * @param {GiftMessageItemRepositoryV1SavePostBody} [giftMessageItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1SavePost(cartId: number, itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftMessageItemRepositoryV1SavePost.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling giftMessageItemRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/carts/{cartId}/gift-message/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftMessageItemRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftMessageItemRepositoryV1SavePostBody || {}) : (giftMessageItemRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {number} itemId The item ID.
         * @param {GiftMessageItemRepositoryV1SavePostBody1} [giftMessageItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1SavePost_2(itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody1, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling giftMessageItemRepositoryV1SavePost_2.');
            }
            const localVarPath = `/V1/carts/mine/gift-message/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftMessageItemRepositoryV1SavePostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftMessageItemRepositoryV1SavePostBody || {}) : (giftMessageItemRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftMessageItemRepositoryV1Api - functional programming interface
 * @export
 */
export const GiftMessageItemRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {number} cartId The shopping cart ID.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1GetGet(cartId: number, itemId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftMessageDataMessageInterface> {
            const localVarFetchArgs = GiftMessageItemRepositoryV1ApiFetchParamCreator(configuration).giftMessageItemRepositoryV1GetGet(cartId, itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1GetGet_1(itemId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftMessageDataMessageInterface> {
            const localVarFetchArgs = GiftMessageItemRepositoryV1ApiFetchParamCreator(configuration).giftMessageItemRepositoryV1GetGet_1(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {number} itemId The item ID.
         * @param {GiftMessageItemRepositoryV1SavePostBody} [giftMessageItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1SavePost(cartId: number, itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftMessageItemRepositoryV1ApiFetchParamCreator(configuration).giftMessageItemRepositoryV1SavePost(cartId, itemId, giftMessageItemRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {number} itemId The item ID.
         * @param {GiftMessageItemRepositoryV1SavePostBody1} [giftMessageItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1SavePost_2(itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftMessageItemRepositoryV1ApiFetchParamCreator(configuration).giftMessageItemRepositoryV1SavePost_2(itemId, giftMessageItemRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftMessageItemRepositoryV1Api - factory interface
 * @export
 */
export const GiftMessageItemRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {number} cartId The shopping cart ID.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1GetGet(cartId: number, itemId: number, options?: any) {
            return GiftMessageItemRepositoryV1ApiFp(configuration).giftMessageItemRepositoryV1GetGet(cartId, itemId, options)(fetch, basePath);
        },
        /**
         * Return the gift message for a specified item in a specified shopping cart.
         * @param {number} itemId The item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1GetGet_1(itemId: number, options?: any) {
            return GiftMessageItemRepositoryV1ApiFp(configuration).giftMessageItemRepositoryV1GetGet_1(itemId, options)(fetch, basePath);
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {number} itemId The item ID.
         * @param {GiftMessageItemRepositoryV1SavePostBody} [giftMessageItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1SavePost(cartId: number, itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody, options?: any) {
            return GiftMessageItemRepositoryV1ApiFp(configuration).giftMessageItemRepositoryV1SavePost(cartId, itemId, giftMessageItemRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Set the gift message for a specified item in a specified shopping cart.
         * @param {number} itemId The item ID.
         * @param {GiftMessageItemRepositoryV1SavePostBody1} [giftMessageItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftMessageItemRepositoryV1SavePost_2(itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody1, options?: any) {
            return GiftMessageItemRepositoryV1ApiFp(configuration).giftMessageItemRepositoryV1SavePost_2(itemId, giftMessageItemRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftMessageItemRepositoryV1Api - object-oriented interface
 * @export
 * @class GiftMessageItemRepositoryV1Api
 * @extends {BaseAPI}
 */
export class GiftMessageItemRepositoryV1Api extends BaseAPI {
    /**
     * Return the gift message for a specified item in a specified shopping cart.
     * @param {number} cartId The shopping cart ID.
     * @param {number} itemId The item ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageItemRepositoryV1Api
     */
    public giftMessageItemRepositoryV1GetGet(cartId: number, itemId: number, options?: any) {
        return GiftMessageItemRepositoryV1ApiFp(this.configuration).giftMessageItemRepositoryV1GetGet(cartId, itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Return the gift message for a specified item in a specified shopping cart.
     * @param {number} itemId The item ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageItemRepositoryV1Api
     */
    public giftMessageItemRepositoryV1GetGet_1(itemId: number, options?: any) {
        return GiftMessageItemRepositoryV1ApiFp(this.configuration).giftMessageItemRepositoryV1GetGet_1(itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Set the gift message for a specified item in a specified shopping cart.
     * @param {number} cartId The cart ID.
     * @param {number} itemId The item ID.
     * @param {GiftMessageItemRepositoryV1SavePostBody} [giftMessageItemRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageItemRepositoryV1Api
     */
    public giftMessageItemRepositoryV1SavePost(cartId: number, itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody, options?: any) {
        return GiftMessageItemRepositoryV1ApiFp(this.configuration).giftMessageItemRepositoryV1SavePost(cartId, itemId, giftMessageItemRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Set the gift message for a specified item in a specified shopping cart.
     * @param {number} itemId The item ID.
     * @param {GiftMessageItemRepositoryV1SavePostBody1} [giftMessageItemRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftMessageItemRepositoryV1Api
     */
    public giftMessageItemRepositoryV1SavePost_2(itemId: number, giftMessageItemRepositoryV1SavePostBody?: GiftMessageItemRepositoryV1SavePostBody1, options?: any) {
        return GiftMessageItemRepositoryV1ApiFp(this.configuration).giftMessageItemRepositoryV1SavePost_2(itemId, giftMessageItemRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftRegistryGuestCartShippingMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const GiftRegistryGuestCartShippingMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {string} cartId The shopping cart ID.
         * @param {GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId: string, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost.');
            }
            const localVarPath = `/V1/guest-giftregistry/{cartId}/estimate-shipping-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody || {}) : (giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftRegistryGuestCartShippingMethodManagementV1Api - functional programming interface
 * @export
 */
export const GiftRegistryGuestCartShippingMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {string} cartId The shopping cart ID.
         * @param {GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId: string, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = GiftRegistryGuestCartShippingMethodManagementV1ApiFetchParamCreator(configuration).giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftRegistryGuestCartShippingMethodManagementV1Api - factory interface
 * @export
 */
export const GiftRegistryGuestCartShippingMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping
         * @param {string} cartId The shopping cart ID.
         * @param {GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId: string, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options?: any) {
            return GiftRegistryGuestCartShippingMethodManagementV1ApiFp(configuration).giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftRegistryGuestCartShippingMethodManagementV1Api - object-oriented interface
 * @export
 * @class GiftRegistryGuestCartShippingMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class GiftRegistryGuestCartShippingMethodManagementV1Api extends BaseAPI {
    /**
     * Estimate shipping
     * @param {string} cartId The shopping cart ID.
     * @param {GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftRegistryGuestCartShippingMethodManagementV1Api
     */
    public giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId: string, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options?: any) {
        return GiftRegistryGuestCartShippingMethodManagementV1ApiFp(this.configuration).giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPost(cartId, giftRegistryGuestCartShippingMethodManagementV1EstimateByRegistryIdPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftRegistryShippingMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const GiftRegistryShippingMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/giftregistry/mine/estimate-shipping-methods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody || {}) : (giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftRegistryShippingMethodManagementV1Api - functional programming interface
 * @export
 */
export const GiftRegistryShippingMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = GiftRegistryShippingMethodManagementV1ApiFetchParamCreator(configuration).giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftRegistryShippingMethodManagementV1Api - factory interface
 * @export
 */
export const GiftRegistryShippingMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping
         * @param {GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options?: any) {
            return GiftRegistryShippingMethodManagementV1ApiFp(configuration).giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftRegistryShippingMethodManagementV1Api - object-oriented interface
 * @export
 * @class GiftRegistryShippingMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class GiftRegistryShippingMethodManagementV1Api extends BaseAPI {
    /**
     * Estimate shipping
     * @param {GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody} [giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftRegistryShippingMethodManagementV1Api
     */
    public giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody?: GiftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options?: any) {
        return GiftRegistryShippingMethodManagementV1ApiFp(this.configuration).giftRegistryShippingMethodManagementV1EstimateByRegistryIdPost(giftRegistryShippingMethodManagementV1EstimateByRegistryIdPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * GiftWrappingWrappingRepositoryV1Api - fetch parameter creator
 * @export
 */
export const GiftWrappingWrappingRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete gift wrapping
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1DeleteByIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling giftWrappingWrappingRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/gift-wrappings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return data object for specified wrapping ID and store.
         * @param {number} id
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1GetGet(id: number, storeId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling giftWrappingWrappingRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/gift-wrappings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return list of gift wrapping data objects based on search criteria
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/gift-wrappings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create/Update new gift wrapping with data object values
         * @param {GiftWrappingWrappingRepositoryV1SavePostBody} [giftWrappingWrappingRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody?: GiftWrappingWrappingRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/gift-wrappings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftWrappingWrappingRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftWrappingWrappingRepositoryV1SavePostBody || {}) : (giftWrappingWrappingRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create/Update new gift wrapping with data object values
         * @param {string} wrappingId
         * @param {GiftWrappingWrappingRepositoryV1SavePutBody} [giftWrappingWrappingRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1SavePut(wrappingId: string, giftWrappingWrappingRepositoryV1SavePutBody?: GiftWrappingWrappingRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'wrappingId' is not null or undefined
            if (wrappingId === null || wrappingId === undefined) {
                throw new RequiredError('wrappingId','Required parameter wrappingId was null or undefined when calling giftWrappingWrappingRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/gift-wrappings/{wrappingId}`
                .replace(`{${"wrappingId"}}`, encodeURIComponent(String(wrappingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GiftWrappingWrappingRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(giftWrappingWrappingRepositoryV1SavePutBody || {}) : (giftWrappingWrappingRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftWrappingWrappingRepositoryV1Api - functional programming interface
 * @export
 */
export const GiftWrappingWrappingRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete gift wrapping
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1DeleteByIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GiftWrappingWrappingRepositoryV1ApiFetchParamCreator(configuration).giftWrappingWrappingRepositoryV1DeleteByIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return data object for specified wrapping ID and store.
         * @param {number} id
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1GetGet(id: number, storeId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftWrappingDataWrappingInterface> {
            const localVarFetchArgs = GiftWrappingWrappingRepositoryV1ApiFetchParamCreator(configuration).giftWrappingWrappingRepositoryV1GetGet(id, storeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return list of gift wrapping data objects based on search criteria
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftWrappingDataWrappingSearchResultsInterface> {
            const localVarFetchArgs = GiftWrappingWrappingRepositoryV1ApiFetchParamCreator(configuration).giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create/Update new gift wrapping with data object values
         * @param {GiftWrappingWrappingRepositoryV1SavePostBody} [giftWrappingWrappingRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody?: GiftWrappingWrappingRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftWrappingDataWrappingInterface> {
            const localVarFetchArgs = GiftWrappingWrappingRepositoryV1ApiFetchParamCreator(configuration).giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create/Update new gift wrapping with data object values
         * @param {string} wrappingId
         * @param {GiftWrappingWrappingRepositoryV1SavePutBody} [giftWrappingWrappingRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1SavePut(wrappingId: string, giftWrappingWrappingRepositoryV1SavePutBody?: GiftWrappingWrappingRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GiftWrappingDataWrappingInterface> {
            const localVarFetchArgs = GiftWrappingWrappingRepositoryV1ApiFetchParamCreator(configuration).giftWrappingWrappingRepositoryV1SavePut(wrappingId, giftWrappingWrappingRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GiftWrappingWrappingRepositoryV1Api - factory interface
 * @export
 */
export const GiftWrappingWrappingRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete gift wrapping
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1DeleteByIdDelete(id: number, options?: any) {
            return GiftWrappingWrappingRepositoryV1ApiFp(configuration).giftWrappingWrappingRepositoryV1DeleteByIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Return data object for specified wrapping ID and store.
         * @param {number} id
         * @param {number} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1GetGet(id: number, storeId?: number, options?: any) {
            return GiftWrappingWrappingRepositoryV1ApiFp(configuration).giftWrappingWrappingRepositoryV1GetGet(id, storeId, options)(fetch, basePath);
        },
        /**
         * Return list of gift wrapping data objects based on search criteria
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return GiftWrappingWrappingRepositoryV1ApiFp(configuration).giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create/Update new gift wrapping with data object values
         * @param {GiftWrappingWrappingRepositoryV1SavePostBody} [giftWrappingWrappingRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody?: GiftWrappingWrappingRepositoryV1SavePostBody, options?: any) {
            return GiftWrappingWrappingRepositoryV1ApiFp(configuration).giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create/Update new gift wrapping with data object values
         * @param {string} wrappingId
         * @param {GiftWrappingWrappingRepositoryV1SavePutBody} [giftWrappingWrappingRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giftWrappingWrappingRepositoryV1SavePut(wrappingId: string, giftWrappingWrappingRepositoryV1SavePutBody?: GiftWrappingWrappingRepositoryV1SavePutBody, options?: any) {
            return GiftWrappingWrappingRepositoryV1ApiFp(configuration).giftWrappingWrappingRepositoryV1SavePut(wrappingId, giftWrappingWrappingRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * GiftWrappingWrappingRepositoryV1Api - object-oriented interface
 * @export
 * @class GiftWrappingWrappingRepositoryV1Api
 * @extends {BaseAPI}
 */
export class GiftWrappingWrappingRepositoryV1Api extends BaseAPI {
    /**
     * Delete gift wrapping
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftWrappingWrappingRepositoryV1Api
     */
    public giftWrappingWrappingRepositoryV1DeleteByIdDelete(id: number, options?: any) {
        return GiftWrappingWrappingRepositoryV1ApiFp(this.configuration).giftWrappingWrappingRepositoryV1DeleteByIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Return data object for specified wrapping ID and store.
     * @param {number} id
     * @param {number} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftWrappingWrappingRepositoryV1Api
     */
    public giftWrappingWrappingRepositoryV1GetGet(id: number, storeId?: number, options?: any) {
        return GiftWrappingWrappingRepositoryV1ApiFp(this.configuration).giftWrappingWrappingRepositoryV1GetGet(id, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Return list of gift wrapping data objects based on search criteria
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftWrappingWrappingRepositoryV1Api
     */
    public giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return GiftWrappingWrappingRepositoryV1ApiFp(this.configuration).giftWrappingWrappingRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create/Update new gift wrapping with data object values
     * @param {GiftWrappingWrappingRepositoryV1SavePostBody} [giftWrappingWrappingRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftWrappingWrappingRepositoryV1Api
     */
    public giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody?: GiftWrappingWrappingRepositoryV1SavePostBody, options?: any) {
        return GiftWrappingWrappingRepositoryV1ApiFp(this.configuration).giftWrappingWrappingRepositoryV1SavePost(giftWrappingWrappingRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create/Update new gift wrapping with data object values
     * @param {string} wrappingId
     * @param {GiftWrappingWrappingRepositoryV1SavePutBody} [giftWrappingWrappingRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftWrappingWrappingRepositoryV1Api
     */
    public giftWrappingWrappingRepositoryV1SavePut(wrappingId: string, giftWrappingWrappingRepositoryV1SavePutBody?: GiftWrappingWrappingRepositoryV1SavePutBody, options?: any) {
        return GiftWrappingWrappingRepositoryV1ApiFp(this.configuration).giftWrappingWrappingRepositoryV1SavePut(wrappingId, giftWrappingWrappingRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationAdminTokenServiceV1Api - fetch parameter creator
 * @export
 */
export const IntegrationAdminTokenServiceV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create access token for admin given the admin credentials.
         * @param {IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody} [integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody?: IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/integration/admin/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody || {}) : (integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationAdminTokenServiceV1Api - functional programming interface
 * @export
 */
export const IntegrationAdminTokenServiceV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create access token for admin given the admin credentials.
         * @param {IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody} [integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody?: IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = IntegrationAdminTokenServiceV1ApiFetchParamCreator(configuration).integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationAdminTokenServiceV1Api - factory interface
 * @export
 */
export const IntegrationAdminTokenServiceV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create access token for admin given the admin credentials.
         * @param {IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody} [integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody?: IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options?: any) {
            return IntegrationAdminTokenServiceV1ApiFp(configuration).integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationAdminTokenServiceV1Api - object-oriented interface
 * @export
 * @class IntegrationAdminTokenServiceV1Api
 * @extends {BaseAPI}
 */
export class IntegrationAdminTokenServiceV1Api extends BaseAPI {
    /**
     * Create access token for admin given the admin credentials.
     * @param {IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody} [integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAdminTokenServiceV1Api
     */
    public integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody?: IntegrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options?: any) {
        return IntegrationAdminTokenServiceV1ApiFp(this.configuration).integrationAdminTokenServiceV1CreateAdminAccessTokenPost(integrationAdminTokenServiceV1CreateAdminAccessTokenPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationCustomerTokenServiceV1Api - fetch parameter creator
 * @export
 */
export const IntegrationCustomerTokenServiceV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create access token for admin given the customer credentials.
         * @param {IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody} [integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody?: IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/integration/customer/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody || {}) : (integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationCustomerTokenServiceV1Api - functional programming interface
 * @export
 */
export const IntegrationCustomerTokenServiceV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create access token for admin given the customer credentials.
         * @param {IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody} [integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody?: IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = IntegrationCustomerTokenServiceV1ApiFetchParamCreator(configuration).integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationCustomerTokenServiceV1Api - factory interface
 * @export
 */
export const IntegrationCustomerTokenServiceV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create access token for admin given the customer credentials.
         * @param {IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody} [integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody?: IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options?: any) {
            return IntegrationCustomerTokenServiceV1ApiFp(configuration).integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationCustomerTokenServiceV1Api - object-oriented interface
 * @export
 * @class IntegrationCustomerTokenServiceV1Api
 * @extends {BaseAPI}
 */
export class IntegrationCustomerTokenServiceV1Api extends BaseAPI {
    /**
     * Create access token for admin given the customer credentials.
     * @param {IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody} [integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationCustomerTokenServiceV1Api
     */
    public integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody?: IntegrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options?: any) {
        return IntegrationCustomerTokenServiceV1ApiFp(this.configuration).integrationCustomerTokenServiceV1CreateCustomerAccessTokenPost(integrationCustomerTokenServiceV1CreateCustomerAccessTokenPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteAttachmentContentManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteAttachmentContentManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns content for one or more files attached on the quote comment.
         * @param {Array<number>} attachmentIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentIds' is not null or undefined
            if (attachmentIds === null || attachmentIds === undefined) {
                throw new RequiredError('attachmentIds','Required parameter attachmentIds was null or undefined when calling negotiableQuoteAttachmentContentManagementV1GetGet.');
            }
            const localVarPath = `/V1/negotiableQuote/attachmentContent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (attachmentIds) {
                localVarQueryParameter['attachmentIds'] = attachmentIds.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteAttachmentContentManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteAttachmentContentManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns content for one or more files attached on the quote comment.
         * @param {Array<number>} attachmentIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NegotiableQuoteDataAttachmentContentInterface>> {
            const localVarFetchArgs = NegotiableQuoteAttachmentContentManagementV1ApiFetchParamCreator(configuration).negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteAttachmentContentManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteAttachmentContentManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns content for one or more files attached on the quote comment.
         * @param {Array<number>} attachmentIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds: Array<number>, options?: any) {
            return NegotiableQuoteAttachmentContentManagementV1ApiFp(configuration).negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteAttachmentContentManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteAttachmentContentManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteAttachmentContentManagementV1Api extends BaseAPI {
    /**
     * Returns content for one or more files attached on the quote comment.
     * @param {Array<number>} attachmentIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteAttachmentContentManagementV1Api
     */
    public negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds: Array<number>, options?: any) {
        return NegotiableQuoteAttachmentContentManagementV1ApiFp(this.configuration).negotiableQuoteAttachmentContentManagementV1GetGet(attachmentIds, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteBillingAddressManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteBillingAddressManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {NegotiableQuoteBillingAddressManagementV1AssignPostBody} [negotiableQuoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteBillingAddressManagementV1AssignPost(cartId: number, negotiableQuoteBillingAddressManagementV1AssignPostBody?: NegotiableQuoteBillingAddressManagementV1AssignPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteBillingAddressManagementV1AssignPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/billing-address`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteBillingAddressManagementV1AssignPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteBillingAddressManagementV1AssignPostBody || {}) : (negotiableQuoteBillingAddressManagementV1AssignPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteBillingAddressManagementV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteBillingAddressManagementV1GetGet.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/billing-address`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteBillingAddressManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteBillingAddressManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {NegotiableQuoteBillingAddressManagementV1AssignPostBody} [negotiableQuoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteBillingAddressManagementV1AssignPost(cartId: number, negotiableQuoteBillingAddressManagementV1AssignPostBody?: NegotiableQuoteBillingAddressManagementV1AssignPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NegotiableQuoteBillingAddressManagementV1ApiFetchParamCreator(configuration).negotiableQuoteBillingAddressManagementV1AssignPost(cartId, negotiableQuoteBillingAddressManagementV1AssignPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteBillingAddressManagementV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataAddressInterface> {
            const localVarFetchArgs = NegotiableQuoteBillingAddressManagementV1ApiFetchParamCreator(configuration).negotiableQuoteBillingAddressManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteBillingAddressManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteBillingAddressManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {NegotiableQuoteBillingAddressManagementV1AssignPostBody} [negotiableQuoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteBillingAddressManagementV1AssignPost(cartId: number, negotiableQuoteBillingAddressManagementV1AssignPostBody?: NegotiableQuoteBillingAddressManagementV1AssignPostBody, options?: any) {
            return NegotiableQuoteBillingAddressManagementV1ApiFp(configuration).negotiableQuoteBillingAddressManagementV1AssignPost(cartId, negotiableQuoteBillingAddressManagementV1AssignPostBody, options)(fetch, basePath);
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteBillingAddressManagementV1GetGet(cartId: number, options?: any) {
            return NegotiableQuoteBillingAddressManagementV1ApiFp(configuration).negotiableQuoteBillingAddressManagementV1GetGet(cartId, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteBillingAddressManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteBillingAddressManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteBillingAddressManagementV1Api extends BaseAPI {
    /**
     * Assigns a specified billing address to a specified cart.
     * @param {number} cartId The cart ID.
     * @param {NegotiableQuoteBillingAddressManagementV1AssignPostBody} [negotiableQuoteBillingAddressManagementV1AssignPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteBillingAddressManagementV1Api
     */
    public negotiableQuoteBillingAddressManagementV1AssignPost(cartId: number, negotiableQuoteBillingAddressManagementV1AssignPostBody?: NegotiableQuoteBillingAddressManagementV1AssignPostBody, options?: any) {
        return NegotiableQuoteBillingAddressManagementV1ApiFp(this.configuration).negotiableQuoteBillingAddressManagementV1AssignPost(cartId, negotiableQuoteBillingAddressManagementV1AssignPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the billing address for a specified quote.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteBillingAddressManagementV1Api
     */
    public negotiableQuoteBillingAddressManagementV1GetGet(cartId: number, options?: any) {
        return NegotiableQuoteBillingAddressManagementV1ApiFp(this.configuration).negotiableQuoteBillingAddressManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteCartTotalRepositoryV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteCartTotalRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns quote totals data for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCartTotalRepositoryV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteCartTotalRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/totals`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteCartTotalRepositoryV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteCartTotalRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns quote totals data for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCartTotalRepositoryV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = NegotiableQuoteCartTotalRepositoryV1ApiFetchParamCreator(configuration).negotiableQuoteCartTotalRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteCartTotalRepositoryV1Api - factory interface
 * @export
 */
export const NegotiableQuoteCartTotalRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns quote totals data for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCartTotalRepositoryV1GetGet(cartId: number, options?: any) {
            return NegotiableQuoteCartTotalRepositoryV1ApiFp(configuration).negotiableQuoteCartTotalRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteCartTotalRepositoryV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteCartTotalRepositoryV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteCartTotalRepositoryV1Api extends BaseAPI {
    /**
     * Returns quote totals data for a specified cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteCartTotalRepositoryV1Api
     */
    public negotiableQuoteCartTotalRepositoryV1GetGet(cartId: number, options?: any) {
        return NegotiableQuoteCartTotalRepositoryV1ApiFp(this.configuration).negotiableQuoteCartTotalRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteCommentLocatorV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteCommentLocatorV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns comments for a specified negotiable quote.
         * @param {number} quoteId Negotiable Quote ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId: number, options: any = {}): FetchArgs {
            // verify required parameter 'quoteId' is not null or undefined
            if (quoteId === null || quoteId === undefined) {
                throw new RequiredError('quoteId','Required parameter quoteId was null or undefined when calling negotiableQuoteCommentLocatorV1GetListForQuoteGet.');
            }
            const localVarPath = `/V1/negotiableQuote/{quoteId}/comments`
                .replace(`{${"quoteId"}}`, encodeURIComponent(String(quoteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteCommentLocatorV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteCommentLocatorV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns comments for a specified negotiable quote.
         * @param {number} quoteId Negotiable Quote ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NegotiableQuoteDataCommentInterface>> {
            const localVarFetchArgs = NegotiableQuoteCommentLocatorV1ApiFetchParamCreator(configuration).negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteCommentLocatorV1Api - factory interface
 * @export
 */
export const NegotiableQuoteCommentLocatorV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns comments for a specified negotiable quote.
         * @param {number} quoteId Negotiable Quote ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId: number, options?: any) {
            return NegotiableQuoteCommentLocatorV1ApiFp(configuration).negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteCommentLocatorV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteCommentLocatorV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteCommentLocatorV1Api extends BaseAPI {
    /**
     * Returns comments for a specified negotiable quote.
     * @param {number} quoteId Negotiable Quote ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteCommentLocatorV1Api
     */
    public negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId: number, options?: any) {
        return NegotiableQuoteCommentLocatorV1ApiFp(this.configuration).negotiableQuoteCommentLocatorV1GetListForQuoteGet(quoteId, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteCouponManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteCouponManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a coupon from a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCouponManagementV1RemoveDelete(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteCouponManagementV1RemoveDelete.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/coupons`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCouponManagementV1SetPut(cartId: number, couponCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteCouponManagementV1SetPut.');
            }
            // verify required parameter 'couponCode' is not null or undefined
            if (couponCode === null || couponCode === undefined) {
                throw new RequiredError('couponCode','Required parameter couponCode was null or undefined when calling negotiableQuoteCouponManagementV1SetPut.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/coupons/{couponCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"couponCode"}}`, encodeURIComponent(String(couponCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteCouponManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteCouponManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a coupon from a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCouponManagementV1RemoveDelete(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteCouponManagementV1ApiFetchParamCreator(configuration).negotiableQuoteCouponManagementV1RemoveDelete(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCouponManagementV1SetPut(cartId: number, couponCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteCouponManagementV1ApiFetchParamCreator(configuration).negotiableQuoteCouponManagementV1SetPut(cartId, couponCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteCouponManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteCouponManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a coupon from a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCouponManagementV1RemoveDelete(cartId: number, options?: any) {
            return NegotiableQuoteCouponManagementV1ApiFp(configuration).negotiableQuoteCouponManagementV1RemoveDelete(cartId, options)(fetch, basePath);
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteCouponManagementV1SetPut(cartId: number, couponCode: string, options?: any) {
            return NegotiableQuoteCouponManagementV1ApiFp(configuration).negotiableQuoteCouponManagementV1SetPut(cartId, couponCode, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteCouponManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteCouponManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteCouponManagementV1Api extends BaseAPI {
    /**
     * Deletes a coupon from a specified cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteCouponManagementV1Api
     */
    public negotiableQuoteCouponManagementV1RemoveDelete(cartId: number, options?: any) {
        return NegotiableQuoteCouponManagementV1ApiFp(this.configuration).negotiableQuoteCouponManagementV1RemoveDelete(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a coupon by code to a specified cart.
     * @param {number} cartId The cart ID.
     * @param {string} couponCode The coupon code data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteCouponManagementV1Api
     */
    public negotiableQuoteCouponManagementV1SetPut(cartId: number, couponCode: string, options?: any) {
        return NegotiableQuoteCouponManagementV1ApiFp(this.configuration).negotiableQuoteCouponManagementV1SetPut(cartId, couponCode, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteGiftCardAccountManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteGiftCardAccountManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove GiftCard Account entity
         * @param {number} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete.');
            }
            // verify required parameter 'giftCardCode' is not null or undefined
            if (giftCardCode === null || giftCardCode === undefined) {
                throw new RequiredError('giftCardCode','Required parameter giftCardCode was null or undefined when calling negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/giftCards/{giftCardCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"giftCardCode"}}`, encodeURIComponent(String(giftCardCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} cartId
         * @param {NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody} [negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId: number, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody?: NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/giftCards`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody || {}) : (negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteGiftCardAccountManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteGiftCardAccountManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove GiftCard Account entity
         * @param {number} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteGiftCardAccountManagementV1ApiFetchParamCreator(configuration).negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} cartId
         * @param {NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody} [negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId: number, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody?: NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteGiftCardAccountManagementV1ApiFetchParamCreator(configuration).negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteGiftCardAccountManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteGiftCardAccountManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove GiftCard Account entity
         * @param {number} cartId
         * @param {string} giftCardCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options?: any) {
            return NegotiableQuoteGiftCardAccountManagementV1ApiFp(configuration).negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} cartId
         * @param {NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody} [negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId: number, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody?: NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options?: any) {
            return NegotiableQuoteGiftCardAccountManagementV1ApiFp(configuration).negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteGiftCardAccountManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteGiftCardAccountManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteGiftCardAccountManagementV1Api extends BaseAPI {
    /**
     * Remove GiftCard Account entity
     * @param {number} cartId
     * @param {string} giftCardCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteGiftCardAccountManagementV1Api
     */
    public negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId: number, giftCardCode: string, options?: any) {
        return NegotiableQuoteGiftCardAccountManagementV1ApiFp(this.configuration).negotiableQuoteGiftCardAccountManagementV1DeleteByQuoteIdDelete(cartId, giftCardCode, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} cartId
     * @param {NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody} [negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteGiftCardAccountManagementV1Api
     */
    public negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId: number, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody?: NegotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options?: any) {
        return NegotiableQuoteGiftCardAccountManagementV1ApiFp(this.configuration).negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPost(cartId, negotiableQuoteGiftCardAccountManagementV1SaveByQuoteIdPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteNegotiableCartRepositoryV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteNegotiableCartRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save quote
         * @param {string} quoteId
         * @param {NegotiableQuoteNegotiableCartRepositoryV1SavePutBody} [negotiableQuoteNegotiableCartRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId: string, negotiableQuoteNegotiableCartRepositoryV1SavePutBody?: NegotiableQuoteNegotiableCartRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'quoteId' is not null or undefined
            if (quoteId === null || quoteId === undefined) {
                throw new RequiredError('quoteId','Required parameter quoteId was null or undefined when calling negotiableQuoteNegotiableCartRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/negotiableQuote/{quoteId}`
                .replace(`{${"quoteId"}}`, encodeURIComponent(String(quoteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteNegotiableCartRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteNegotiableCartRepositoryV1SavePutBody || {}) : (negotiableQuoteNegotiableCartRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableCartRepositoryV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteNegotiableCartRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Save quote
         * @param {string} quoteId
         * @param {NegotiableQuoteNegotiableCartRepositoryV1SavePutBody} [negotiableQuoteNegotiableCartRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId: string, negotiableQuoteNegotiableCartRepositoryV1SavePutBody?: NegotiableQuoteNegotiableCartRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ErrorResponse> {
            const localVarFetchArgs = NegotiableQuoteNegotiableCartRepositoryV1ApiFetchParamCreator(configuration).negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId, negotiableQuoteNegotiableCartRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableCartRepositoryV1Api - factory interface
 * @export
 */
export const NegotiableQuoteNegotiableCartRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Save quote
         * @param {string} quoteId
         * @param {NegotiableQuoteNegotiableCartRepositoryV1SavePutBody} [negotiableQuoteNegotiableCartRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId: string, negotiableQuoteNegotiableCartRepositoryV1SavePutBody?: NegotiableQuoteNegotiableCartRepositoryV1SavePutBody, options?: any) {
            return NegotiableQuoteNegotiableCartRepositoryV1ApiFp(configuration).negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId, negotiableQuoteNegotiableCartRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteNegotiableCartRepositoryV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteNegotiableCartRepositoryV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteNegotiableCartRepositoryV1Api extends BaseAPI {
    /**
     * Save quote
     * @param {string} quoteId
     * @param {NegotiableQuoteNegotiableCartRepositoryV1SavePutBody} [negotiableQuoteNegotiableCartRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteNegotiableCartRepositoryV1Api
     */
    public negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId: string, negotiableQuoteNegotiableCartRepositoryV1SavePutBody?: NegotiableQuoteNegotiableCartRepositoryV1SavePutBody, options?: any) {
        return NegotiableQuoteNegotiableCartRepositoryV1ApiFp(this.configuration).negotiableQuoteNegotiableCartRepositoryV1SavePut(quoteId, negotiableQuoteNegotiableCartRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteNegotiableQuoteManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteNegotiableQuoteManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit the B2B quote to the customer. The quote status for the customer will be changed to 'Updated', and the customer can work with the quote.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody} [negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody?: NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/negotiableQuote/submitToCustomer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody || {}) : (negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a B2B quote based on a regular Magento quote. If the B2B quote requires a shipping address (for negotiation or tax calculations), add it to the regular quote before you create a B2B quote.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody} [negotiableQuoteNegotiableQuoteManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody?: NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/negotiableQuote/request`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody || {}) : (negotiableQuoteNegotiableQuoteManagementV1CreatePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Decline the B2B quote. All custom pricing will be removed from this quote. The buyer will be able to place an order using their standard catalog prices and discounts.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody} [negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody?: NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/negotiableQuote/decline`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody || {}) : (negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableQuoteManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteNegotiableQuoteManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Submit the B2B quote to the customer. The quote status for the customer will be changed to 'Updated', and the customer can work with the quote.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody} [negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody?: NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteNegotiableQuoteManagementV1ApiFetchParamCreator(configuration).negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a B2B quote based on a regular Magento quote. If the B2B quote requires a shipping address (for negotiation or tax calculations), add it to the regular quote before you create a B2B quote.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody} [negotiableQuoteNegotiableQuoteManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody?: NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteNegotiableQuoteManagementV1ApiFetchParamCreator(configuration).negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Decline the B2B quote. All custom pricing will be removed from this quote. The buyer will be able to place an order using their standard catalog prices and discounts.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody} [negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody?: NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteNegotiableQuoteManagementV1ApiFetchParamCreator(configuration).negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableQuoteManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteNegotiableQuoteManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Submit the B2B quote to the customer. The quote status for the customer will be changed to 'Updated', and the customer can work with the quote.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody} [negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody?: NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options?: any) {
            return NegotiableQuoteNegotiableQuoteManagementV1ApiFp(configuration).negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options)(fetch, basePath);
        },
        /**
         * Create a B2B quote based on a regular Magento quote. If the B2B quote requires a shipping address (for negotiation or tax calculations), add it to the regular quote before you create a B2B quote.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody} [negotiableQuoteNegotiableQuoteManagementV1CreatePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody?: NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options?: any) {
            return NegotiableQuoteNegotiableQuoteManagementV1ApiFp(configuration).negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options)(fetch, basePath);
        },
        /**
         * Decline the B2B quote. All custom pricing will be removed from this quote. The buyer will be able to place an order using their standard catalog prices and discounts.
         * @param {NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody} [negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody?: NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options?: any) {
            return NegotiableQuoteNegotiableQuoteManagementV1ApiFp(configuration).negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteNegotiableQuoteManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteNegotiableQuoteManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteNegotiableQuoteManagementV1Api extends BaseAPI {
    /**
     * Submit the B2B quote to the customer. The quote status for the customer will be changed to 'Updated', and the customer can work with the quote.
     * @param {NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody} [negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1Api
     */
    public negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody?: NegotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options?: any) {
        return NegotiableQuoteNegotiableQuoteManagementV1ApiFp(this.configuration).negotiableQuoteNegotiableQuoteManagementV1AdminSendPost(negotiableQuoteNegotiableQuoteManagementV1AdminSendPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create a B2B quote based on a regular Magento quote. If the B2B quote requires a shipping address (for negotiation or tax calculations), add it to the regular quote before you create a B2B quote.
     * @param {NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody} [negotiableQuoteNegotiableQuoteManagementV1CreatePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1Api
     */
    public negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody?: NegotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options?: any) {
        return NegotiableQuoteNegotiableQuoteManagementV1ApiFp(this.configuration).negotiableQuoteNegotiableQuoteManagementV1CreatePost(negotiableQuoteNegotiableQuoteManagementV1CreatePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Decline the B2B quote. All custom pricing will be removed from this quote. The buyer will be able to place an order using their standard catalog prices and discounts.
     * @param {NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody} [negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteNegotiableQuoteManagementV1Api
     */
    public negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody?: NegotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options?: any) {
        return NegotiableQuoteNegotiableQuoteManagementV1ApiFp(this.configuration).negotiableQuoteNegotiableQuoteManagementV1DeclinePost(negotiableQuoteNegotiableQuoteManagementV1DeclinePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteNegotiableQuotePriceManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteNegotiableQuotePriceManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Refreshes item prices, taxes, discounts, cart rules in the negotiable quote as per the latest changes in the catalog / shared catalog and in the price rules. Depending on the negotiable quote state and totals, all or just some of quote numbers will be recalculated. 'Update Prices' parameter forces refresh on any quote that is not locked for admin user, including the quotes with a negotiated price. The request can be applied to one or more quotes at the same time.
         * @param {NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody} [negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody?: NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/negotiableQuote/pricesUpdated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody || {}) : (negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableQuotePriceManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteNegotiableQuotePriceManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Refreshes item prices, taxes, discounts, cart rules in the negotiable quote as per the latest changes in the catalog / shared catalog and in the price rules. Depending on the negotiable quote state and totals, all or just some of quote numbers will be recalculated. 'Update Prices' parameter forces refresh on any quote that is not locked for admin user, including the quotes with a negotiated price. The request can be applied to one or more quotes at the same time.
         * @param {NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody} [negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody?: NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteNegotiableQuotePriceManagementV1ApiFetchParamCreator(configuration).negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableQuotePriceManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteNegotiableQuotePriceManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Refreshes item prices, taxes, discounts, cart rules in the negotiable quote as per the latest changes in the catalog / shared catalog and in the price rules. Depending on the negotiable quote state and totals, all or just some of quote numbers will be recalculated. 'Update Prices' parameter forces refresh on any quote that is not locked for admin user, including the quotes with a negotiated price. The request can be applied to one or more quotes at the same time.
         * @param {NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody} [negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody?: NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options?: any) {
            return NegotiableQuoteNegotiableQuotePriceManagementV1ApiFp(configuration).negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteNegotiableQuotePriceManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteNegotiableQuotePriceManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteNegotiableQuotePriceManagementV1Api extends BaseAPI {
    /**
     * Refreshes item prices, taxes, discounts, cart rules in the negotiable quote as per the latest changes in the catalog / shared catalog and in the price rules. Depending on the negotiable quote state and totals, all or just some of quote numbers will be recalculated. 'Update Prices' parameter forces refresh on any quote that is not locked for admin user, including the quotes with a negotiated price. The request can be applied to one or more quotes at the same time.
     * @param {NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody} [negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteNegotiableQuotePriceManagementV1Api
     */
    public negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody?: NegotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options?: any) {
        return NegotiableQuoteNegotiableQuotePriceManagementV1ApiFp(this.configuration).negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPost(negotiableQuoteNegotiableQuotePriceManagementV1PricesUpdatedPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteNegotiableQuoteShippingManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteNegotiableQuoteShippingManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the shipping method on a negotiable quote.
         * @param {number} quoteId Negotiable Quote id
         * @param {NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody} [negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId: number, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody?: NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'quoteId' is not null or undefined
            if (quoteId === null || quoteId === undefined) {
                throw new RequiredError('quoteId','Required parameter quoteId was null or undefined when calling negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut.');
            }
            const localVarPath = `/V1/negotiableQuote/{quoteId}/shippingMethod`
                .replace(`{${"quoteId"}}`, encodeURIComponent(String(quoteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody || {}) : (negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableQuoteShippingManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteNegotiableQuoteShippingManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Updates the shipping method on a negotiable quote.
         * @param {number} quoteId Negotiable Quote id
         * @param {NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody} [negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId: number, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody?: NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NegotiableQuoteNegotiableQuoteShippingManagementV1ApiFetchParamCreator(configuration).negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteNegotiableQuoteShippingManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteNegotiableQuoteShippingManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Updates the shipping method on a negotiable quote.
         * @param {number} quoteId Negotiable Quote id
         * @param {NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody} [negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId: number, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody?: NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options?: any) {
            return NegotiableQuoteNegotiableQuoteShippingManagementV1ApiFp(configuration).negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteNegotiableQuoteShippingManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteNegotiableQuoteShippingManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteNegotiableQuoteShippingManagementV1Api extends BaseAPI {
    /**
     * Updates the shipping method on a negotiable quote.
     * @param {number} quoteId Negotiable Quote id
     * @param {NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody} [negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteNegotiableQuoteShippingManagementV1Api
     */
    public negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId: number, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody?: NegotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options?: any) {
        return NegotiableQuoteNegotiableQuoteShippingManagementV1ApiFp(this.configuration).negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPut(quoteId, negotiableQuoteNegotiableQuoteShippingManagementV1SetShippingMethodPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuotePaymentInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuotePaymentInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payment information
         * @param {number} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {number} cartId
         * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody || {}) : (negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payment information for a specified cart.
         * @param {number} cartId
         * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/set-payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody || {}) : (negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuotePaymentInformationManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuotePaymentInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get payment information
         * @param {number} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = NegotiableQuotePaymentInformationManagementV1ApiFetchParamCreator(configuration).negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {number} cartId
         * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NegotiableQuotePaymentInformationManagementV1ApiFetchParamCreator(configuration).negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set payment information for a specified cart.
         * @param {number} cartId
         * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NegotiableQuotePaymentInformationManagementV1ApiFetchParamCreator(configuration).negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuotePaymentInformationManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuotePaymentInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get payment information
         * @param {number} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId: number, options?: any) {
            return NegotiableQuotePaymentInformationManagementV1ApiFp(configuration).negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId, options)(fetch, basePath);
        },
        /**
         * Set payment information and place order for a specified cart.
         * @param {number} cartId
         * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
            return NegotiableQuotePaymentInformationManagementV1ApiFp(configuration).negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options)(fetch, basePath);
        },
        /**
         * Set payment information for a specified cart.
         * @param {number} cartId
         * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options?: any) {
            return NegotiableQuotePaymentInformationManagementV1ApiFp(configuration).negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuotePaymentInformationManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuotePaymentInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuotePaymentInformationManagementV1Api extends BaseAPI {
    /**
     * Get payment information
     * @param {number} cartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuotePaymentInformationManagementV1Api
     */
    public negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId: number, options?: any) {
        return NegotiableQuotePaymentInformationManagementV1ApiFp(this.configuration).negotiableQuotePaymentInformationManagementV1GetPaymentInformationGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Set payment information and place order for a specified cart.
     * @param {number} cartId
     * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuotePaymentInformationManagementV1Api
     */
    public negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
        return NegotiableQuotePaymentInformationManagementV1ApiFp(this.configuration).negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPost(cartId, negotiableQuotePaymentInformationManagementV1SavePaymentInformationAndPlaceOrderPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Set payment information for a specified cart.
     * @param {number} cartId
     * @param {NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody} [negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuotePaymentInformationManagementV1Api
     */
    public negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId: number, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody?: NegotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options?: any) {
        return NegotiableQuotePaymentInformationManagementV1ApiFp(this.configuration).negotiableQuotePaymentInformationManagementV1SavePaymentInformationPost(cartId, negotiableQuotePaymentInformationManagementV1SavePaymentInformationPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteShipmentEstimationV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteShipmentEstimationV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/estimate-shipping-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody || {}) : (negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteShipmentEstimationV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteShipmentEstimationV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = NegotiableQuoteShipmentEstimationV1ApiFetchParamCreator(configuration).negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteShipmentEstimationV1Api - factory interface
 * @export
 */
export const NegotiableQuoteShipmentEstimationV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any) {
            return NegotiableQuoteShipmentEstimationV1ApiFp(configuration).negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteShipmentEstimationV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteShipmentEstimationV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteShipmentEstimationV1Api extends BaseAPI {
    /**
     * Estimate shipping by address and return list of available shipping methods
     * @param {string} cartId
     * @param {NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteShipmentEstimationV1Api
     */
    public negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: NegotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any) {
        return NegotiableQuoteShipmentEstimationV1ApiFp(this.configuration).negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId, negotiableQuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteShippingInformationManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteShippingInformationManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} cartId
         * @param {NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody} [negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId: number, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody?: NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/shipping-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody || {}) : (negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteShippingInformationManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteShippingInformationManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} cartId
         * @param {NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody} [negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId: number, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody?: NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutDataPaymentDetailsInterface> {
            const localVarFetchArgs = NegotiableQuoteShippingInformationManagementV1ApiFetchParamCreator(configuration).negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteShippingInformationManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteShippingInformationManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {number} cartId
         * @param {NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody} [negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId: number, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody?: NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options?: any) {
            return NegotiableQuoteShippingInformationManagementV1ApiFp(configuration).negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteShippingInformationManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteShippingInformationManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteShippingInformationManagementV1Api extends BaseAPI {
    /**
     *
     * @param {number} cartId
     * @param {NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody} [negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteShippingInformationManagementV1Api
     */
    public negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId: number, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody?: NegotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options?: any) {
        return NegotiableQuoteShippingInformationManagementV1ApiFp(this.configuration).negotiableQuoteShippingInformationManagementV1SaveAddressInformationPost(cartId, negotiableQuoteShippingInformationManagementV1SaveAddressInformationPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * NegotiableQuoteShippingMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const NegotiableQuoteShippingMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {number} cartId The shopping cart ID.
         * @param {NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody?: NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost.');
            }
            const localVarPath = `/V1/negotiable-carts/{cartId}/estimate-shipping-methods-by-address-id`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody || {}) : (negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NegotiableQuoteShippingMethodManagementV1Api - functional programming interface
 * @export
 */
export const NegotiableQuoteShippingMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {number} cartId The shopping cart ID.
         * @param {NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody?: NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = NegotiableQuoteShippingMethodManagementV1ApiFetchParamCreator(configuration).negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NegotiableQuoteShippingMethodManagementV1Api - factory interface
 * @export
 */
export const NegotiableQuoteShippingMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping
         * @param {number} cartId The shopping cart ID.
         * @param {NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody?: NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options?: any) {
            return NegotiableQuoteShippingMethodManagementV1ApiFp(configuration).negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * NegotiableQuoteShippingMethodManagementV1Api - object-oriented interface
 * @export
 * @class NegotiableQuoteShippingMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class NegotiableQuoteShippingMethodManagementV1Api extends BaseAPI {
    /**
     * Estimate shipping
     * @param {number} cartId The shopping cart ID.
     * @param {NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NegotiableQuoteShippingMethodManagementV1Api
     */
    public negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody?: NegotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options?: any) {
        return NegotiableQuoteShippingMethodManagementV1ApiFp(this.configuration).negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPost(cartId, negotiableQuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteBillingAddressManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteBillingAddressManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteBillingAddressManagementV1AssignPostBody} [quoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1AssignPost(cartId: number, quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteBillingAddressManagementV1AssignPost.');
            }
            const localVarPath = `/V1/carts/{cartId}/billing-address`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteBillingAddressManagementV1AssignPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteBillingAddressManagementV1AssignPostBody || {}) : (quoteBillingAddressManagementV1AssignPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {QuoteBillingAddressManagementV1AssignPostBody1} [quoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/billing-address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteBillingAddressManagementV1AssignPostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteBillingAddressManagementV1AssignPostBody || {}) : (quoteBillingAddressManagementV1AssignPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteBillingAddressManagementV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/billing-address`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1GetGet_2(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/billing-address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteBillingAddressManagementV1Api - functional programming interface
 * @export
 */
export const QuoteBillingAddressManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteBillingAddressManagementV1AssignPostBody} [quoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1AssignPost(cartId: number, quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteBillingAddressManagementV1ApiFetchParamCreator(configuration).quoteBillingAddressManagementV1AssignPost(cartId, quoteBillingAddressManagementV1AssignPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {QuoteBillingAddressManagementV1AssignPostBody1} [quoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteBillingAddressManagementV1ApiFetchParamCreator(configuration).quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataAddressInterface> {
            const localVarFetchArgs = QuoteBillingAddressManagementV1ApiFetchParamCreator(configuration).quoteBillingAddressManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1GetGet_2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataAddressInterface> {
            const localVarFetchArgs = QuoteBillingAddressManagementV1ApiFetchParamCreator(configuration).quoteBillingAddressManagementV1GetGet_2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteBillingAddressManagementV1Api - factory interface
 * @export
 */
export const QuoteBillingAddressManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteBillingAddressManagementV1AssignPostBody} [quoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1AssignPost(cartId: number, quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody, options?: any) {
            return QuoteBillingAddressManagementV1ApiFp(configuration).quoteBillingAddressManagementV1AssignPost(cartId, quoteBillingAddressManagementV1AssignPostBody, options)(fetch, basePath);
        },
        /**
         * Assigns a specified billing address to a specified cart.
         * @param {QuoteBillingAddressManagementV1AssignPostBody1} [quoteBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody1, options?: any) {
            return QuoteBillingAddressManagementV1ApiFp(configuration).quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody, options)(fetch, basePath);
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1GetGet(cartId: number, options?: any) {
            return QuoteBillingAddressManagementV1ApiFp(configuration).quoteBillingAddressManagementV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Returns the billing address for a specified quote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteBillingAddressManagementV1GetGet_2(options?: any) {
            return QuoteBillingAddressManagementV1ApiFp(configuration).quoteBillingAddressManagementV1GetGet_2(options)(fetch, basePath);
        },
    };
};

/**
 * QuoteBillingAddressManagementV1Api - object-oriented interface
 * @export
 * @class QuoteBillingAddressManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteBillingAddressManagementV1Api extends BaseAPI {
    /**
     * Assigns a specified billing address to a specified cart.
     * @param {number} cartId The cart ID.
     * @param {QuoteBillingAddressManagementV1AssignPostBody} [quoteBillingAddressManagementV1AssignPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteBillingAddressManagementV1Api
     */
    public quoteBillingAddressManagementV1AssignPost(cartId: number, quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody, options?: any) {
        return QuoteBillingAddressManagementV1ApiFp(this.configuration).quoteBillingAddressManagementV1AssignPost(cartId, quoteBillingAddressManagementV1AssignPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Assigns a specified billing address to a specified cart.
     * @param {QuoteBillingAddressManagementV1AssignPostBody1} [quoteBillingAddressManagementV1AssignPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteBillingAddressManagementV1Api
     */
    public quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody?: QuoteBillingAddressManagementV1AssignPostBody1, options?: any) {
        return QuoteBillingAddressManagementV1ApiFp(this.configuration).quoteBillingAddressManagementV1AssignPost_1(quoteBillingAddressManagementV1AssignPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the billing address for a specified quote.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteBillingAddressManagementV1Api
     */
    public quoteBillingAddressManagementV1GetGet(cartId: number, options?: any) {
        return QuoteBillingAddressManagementV1ApiFp(this.configuration).quoteBillingAddressManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the billing address for a specified quote.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteBillingAddressManagementV1Api
     */
    public quoteBillingAddressManagementV1GetGet_2(options?: any) {
        return QuoteBillingAddressManagementV1ApiFp(this.configuration).quoteBillingAddressManagementV1GetGet_2(options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteCartItemRepositoryV1Api - fetch parameter creator
 * @export
 */
export const QuoteCartItemRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the specified item from the specified cart.
         * @param {number} cartId The cart ID.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1DeleteByIdDelete(cartId: number, itemId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartItemRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling quoteCartItemRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/carts/{cartId}/items/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified item from the specified cart.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId: number, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling quoteCartItemRepositoryV1DeleteByIdDelete_1.');
            }
            const localVarPath = `/V1/carts/mine/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items that are assigned to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1GetListGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartItemRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/items`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items that are assigned to a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1GetListGet_2(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} quoteId
         * @param {QuoteCartItemRepositoryV1SavePostBody} [quoteCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePost(quoteId: string, quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'quoteId' is not null or undefined
            if (quoteId === null || quoteId === undefined) {
                throw new RequiredError('quoteId','Required parameter quoteId was null or undefined when calling quoteCartItemRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/carts/{quoteId}/items`
                .replace(`{${"quoteId"}}`, encodeURIComponent(String(quoteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartItemRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartItemRepositoryV1SavePostBody || {}) : (quoteCartItemRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {QuoteCartItemRepositoryV1SavePostBody1} [quoteCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartItemRepositoryV1SavePostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartItemRepositoryV1SavePostBody || {}) : (quoteCartItemRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {string} itemId
         * @param {QuoteCartItemRepositoryV1SavePutBody} [quoteCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartItemRepositoryV1SavePut.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling quoteCartItemRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/carts/{cartId}/items/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartItemRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartItemRepositoryV1SavePutBody || {}) : (quoteCartItemRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} itemId
         * @param {QuoteCartItemRepositoryV1SavePutBody1} [quoteCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePut_4(itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody1, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling quoteCartItemRepositoryV1SavePut_4.');
            }
            const localVarPath = `/V1/carts/mine/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartItemRepositoryV1SavePutBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartItemRepositoryV1SavePutBody || {}) : (quoteCartItemRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteCartItemRepositoryV1Api - functional programming interface
 * @export
 */
export const QuoteCartItemRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes the specified item from the specified cart.
         * @param {number} cartId The cart ID.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1DeleteByIdDelete(cartId: number, itemId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1DeleteByIdDelete(cartId, itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes the specified item from the specified cart.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists items that are assigned to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1GetListGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataCartItemInterface>> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1GetListGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists items that are assigned to a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1GetListGet_2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataCartItemInterface>> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1GetListGet_2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} quoteId
         * @param {QuoteCartItemRepositoryV1SavePostBody} [quoteCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePost(quoteId: string, quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartItemInterface> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1SavePost(quoteId, quoteCartItemRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {QuoteCartItemRepositoryV1SavePostBody1} [quoteCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartItemInterface> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {string} itemId
         * @param {QuoteCartItemRepositoryV1SavePutBody} [quoteCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartItemInterface> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1SavePut(cartId, itemId, quoteCartItemRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} itemId
         * @param {QuoteCartItemRepositoryV1SavePutBody1} [quoteCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePut_4(itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartItemInterface> {
            const localVarFetchArgs = QuoteCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteCartItemRepositoryV1SavePut_4(itemId, quoteCartItemRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteCartItemRepositoryV1Api - factory interface
 * @export
 */
export const QuoteCartItemRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Removes the specified item from the specified cart.
         * @param {number} cartId The cart ID.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1DeleteByIdDelete(cartId: number, itemId: number, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1DeleteByIdDelete(cartId, itemId, options)(fetch, basePath);
        },
        /**
         * Removes the specified item from the specified cart.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId: number, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId, options)(fetch, basePath);
        },
        /**
         * Lists items that are assigned to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1GetListGet(cartId: number, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1GetListGet(cartId, options)(fetch, basePath);
        },
        /**
         * Lists items that are assigned to a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1GetListGet_2(options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1GetListGet_2(options)(fetch, basePath);
        },
        /**
         * Add/update the specified cart item.
         * @param {string} quoteId
         * @param {QuoteCartItemRepositoryV1SavePostBody} [quoteCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePost(quoteId: string, quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1SavePost(quoteId, quoteCartItemRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Add/update the specified cart item.
         * @param {QuoteCartItemRepositoryV1SavePostBody1} [quoteCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody1, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {string} itemId
         * @param {QuoteCartItemRepositoryV1SavePutBody} [quoteCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1SavePut(cartId, itemId, quoteCartItemRepositoryV1SavePutBody, options)(fetch, basePath);
        },
        /**
         * Add/update the specified cart item.
         * @param {string} itemId
         * @param {QuoteCartItemRepositoryV1SavePutBody1} [quoteCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartItemRepositoryV1SavePut_4(itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody1, options?: any) {
            return QuoteCartItemRepositoryV1ApiFp(configuration).quoteCartItemRepositoryV1SavePut_4(itemId, quoteCartItemRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteCartItemRepositoryV1Api - object-oriented interface
 * @export
 * @class QuoteCartItemRepositoryV1Api
 * @extends {BaseAPI}
 */
export class QuoteCartItemRepositoryV1Api extends BaseAPI {
    /**
     * Removes the specified item from the specified cart.
     * @param {number} cartId The cart ID.
     * @param {number} itemId The item ID of the item to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1DeleteByIdDelete(cartId: number, itemId: number, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1DeleteByIdDelete(cartId, itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Removes the specified item from the specified cart.
     * @param {number} itemId The item ID of the item to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId: number, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1DeleteByIdDelete_1(itemId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists items that are assigned to a specified cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1GetListGet(cartId: number, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1GetListGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists items that are assigned to a specified cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1GetListGet_2(options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1GetListGet_2(options)(this.fetch, this.basePath);
    }

    /**
     * Add/update the specified cart item.
     * @param {string} quoteId
     * @param {QuoteCartItemRepositoryV1SavePostBody} [quoteCartItemRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1SavePost(quoteId: string, quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1SavePost(quoteId, quoteCartItemRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add/update the specified cart item.
     * @param {QuoteCartItemRepositoryV1SavePostBody1} [quoteCartItemRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody?: QuoteCartItemRepositoryV1SavePostBody1, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1SavePost_3(quoteCartItemRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add/update the specified cart item.
     * @param {string} cartId
     * @param {string} itemId
     * @param {QuoteCartItemRepositoryV1SavePutBody} [quoteCartItemRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1SavePut(cartId, itemId, quoteCartItemRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add/update the specified cart item.
     * @param {string} itemId
     * @param {QuoteCartItemRepositoryV1SavePutBody1} [quoteCartItemRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartItemRepositoryV1Api
     */
    public quoteCartItemRepositoryV1SavePut_4(itemId: string, quoteCartItemRepositoryV1SavePutBody?: QuoteCartItemRepositoryV1SavePutBody1, options?: any) {
        return QuoteCartItemRepositoryV1ApiFp(this.configuration).quoteCartItemRepositoryV1SavePut_4(itemId, quoteCartItemRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteCartManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteCartManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a specified customer to a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteCartManagementV1AssignCustomerPutBody} [quoteCartManagementV1AssignCustomerPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1AssignCustomerPut(cartId: number, quoteCartManagementV1AssignCustomerPutBody?: QuoteCartManagementV1AssignCustomerPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartManagementV1AssignCustomerPut.');
            }
            const localVarPath = `/V1/carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartManagementV1AssignCustomerPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartManagementV1AssignCustomerPutBody || {}) : (quoteCartManagementV1AssignCustomerPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartForCustomerPost(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
         * @param {number} customerId The customer ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling quoteCartManagementV1CreateEmptyCartForCustomerPost_1.');
            }
            const localVarPath = `/V1/customers/{customerId}/carts`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an empty cart and quote for a guest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartPost(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information for the cart for a specified customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1GetCartForCustomerGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places an order for a specified cart.
         * @param {QuoteCartManagementV1PlaceOrderPutBody} [quoteCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartManagementV1PlaceOrderPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartManagementV1PlaceOrderPutBody || {}) : (quoteCartManagementV1PlaceOrderPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Places an order for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteCartManagementV1PlaceOrderPutBody1} [quoteCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1PlaceOrderPut_2(cartId: number, quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody1, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartManagementV1PlaceOrderPut_2.');
            }
            const localVarPath = `/V1/carts/{cartId}/order`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartManagementV1PlaceOrderPutBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartManagementV1PlaceOrderPutBody || {}) : (quoteCartManagementV1PlaceOrderPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteCartManagementV1Api - functional programming interface
 * @export
 */
export const QuoteCartManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assigns a specified customer to a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteCartManagementV1AssignCustomerPutBody} [quoteCartManagementV1AssignCustomerPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1AssignCustomerPut(cartId: number, quoteCartManagementV1AssignCustomerPutBody?: QuoteCartManagementV1AssignCustomerPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1AssignCustomerPut(cartId, quoteCartManagementV1AssignCustomerPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartForCustomerPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1CreateEmptyCartForCustomerPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
         * @param {number} customerId The customer ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates an empty cart and quote for a guest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1CreateEmptyCartPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns information for the cart for a specified customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1GetCartForCustomerGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartInterface> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1GetCartForCustomerGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Places an order for a specified cart.
         * @param {QuoteCartManagementV1PlaceOrderPutBody} [quoteCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Places an order for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteCartManagementV1PlaceOrderPutBody1} [quoteCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1PlaceOrderPut_2(cartId: number, quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteCartManagementV1ApiFetchParamCreator(configuration).quoteCartManagementV1PlaceOrderPut_2(cartId, quoteCartManagementV1PlaceOrderPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteCartManagementV1Api - factory interface
 * @export
 */
export const QuoteCartManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assigns a specified customer to a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteCartManagementV1AssignCustomerPutBody} [quoteCartManagementV1AssignCustomerPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1AssignCustomerPut(cartId: number, quoteCartManagementV1AssignCustomerPutBody?: QuoteCartManagementV1AssignCustomerPutBody, options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1AssignCustomerPut(cartId, quoteCartManagementV1AssignCustomerPutBody, options)(fetch, basePath);
        },
        /**
         * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartForCustomerPost(options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1CreateEmptyCartForCustomerPost(options)(fetch, basePath);
        },
        /**
         * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
         * @param {number} customerId The customer ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId: number, options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId, options)(fetch, basePath);
        },
        /**
         * Creates an empty cart and quote for a guest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1CreateEmptyCartPost(options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1CreateEmptyCartPost(options)(fetch, basePath);
        },
        /**
         * Returns information for the cart for a specified customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1GetCartForCustomerGet(options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1GetCartForCustomerGet(options)(fetch, basePath);
        },
        /**
         * Places an order for a specified cart.
         * @param {QuoteCartManagementV1PlaceOrderPutBody} [quoteCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody, options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody, options)(fetch, basePath);
        },
        /**
         * Places an order for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {QuoteCartManagementV1PlaceOrderPutBody1} [quoteCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartManagementV1PlaceOrderPut_2(cartId: number, quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody1, options?: any) {
            return QuoteCartManagementV1ApiFp(configuration).quoteCartManagementV1PlaceOrderPut_2(cartId, quoteCartManagementV1PlaceOrderPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteCartManagementV1Api - object-oriented interface
 * @export
 * @class QuoteCartManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteCartManagementV1Api extends BaseAPI {
    /**
     * Assigns a specified customer to a specified shopping cart.
     * @param {number} cartId The cart ID.
     * @param {QuoteCartManagementV1AssignCustomerPutBody} [quoteCartManagementV1AssignCustomerPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1AssignCustomerPut(cartId: number, quoteCartManagementV1AssignCustomerPutBody?: QuoteCartManagementV1AssignCustomerPutBody, options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1AssignCustomerPut(cartId, quoteCartManagementV1AssignCustomerPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1CreateEmptyCartForCustomerPost(options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1CreateEmptyCartForCustomerPost(options)(this.fetch, this.basePath);
    }

    /**
     * Creates an empty cart and quote for a specified customer if customer does not have a cart yet.
     * @param {number} customerId The customer ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId: number, options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1CreateEmptyCartForCustomerPost_1(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * Creates an empty cart and quote for a guest.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1CreateEmptyCartPost(options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1CreateEmptyCartPost(options)(this.fetch, this.basePath);
    }

    /**
     * Returns information for the cart for a specified customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1GetCartForCustomerGet(options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1GetCartForCustomerGet(options)(this.fetch, this.basePath);
    }

    /**
     * Places an order for a specified cart.
     * @param {QuoteCartManagementV1PlaceOrderPutBody} [quoteCartManagementV1PlaceOrderPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody, options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1PlaceOrderPut(quoteCartManagementV1PlaceOrderPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Places an order for a specified cart.
     * @param {number} cartId The cart ID.
     * @param {QuoteCartManagementV1PlaceOrderPutBody1} [quoteCartManagementV1PlaceOrderPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartManagementV1Api
     */
    public quoteCartManagementV1PlaceOrderPut_2(cartId: number, quoteCartManagementV1PlaceOrderPutBody?: QuoteCartManagementV1PlaceOrderPutBody1, options?: any) {
        return QuoteCartManagementV1ApiFp(this.configuration).quoteCartManagementV1PlaceOrderPut_2(cartId, quoteCartManagementV1PlaceOrderPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteCartRepositoryV1Api - fetch parameter creator
 * @export
 */
export const QuoteCartRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enables an administrative user to return information for a specified cart.
         * @param {number} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables administrative users to list carts that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#CartRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save quote
         * @param {QuoteCartRepositoryV1SavePutBody} [quoteCartRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody?: QuoteCartRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartRepositoryV1SavePutBody || {}) : (quoteCartRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteCartRepositoryV1Api - functional programming interface
 * @export
 */
export const QuoteCartRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Enables an administrative user to return information for a specified cart.
         * @param {number} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartInterface> {
            const localVarFetchArgs = QuoteCartRepositoryV1ApiFetchParamCreator(configuration).quoteCartRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enables administrative users to list carts that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#CartRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartSearchResultsInterface> {
            const localVarFetchArgs = QuoteCartRepositoryV1ApiFetchParamCreator(configuration).quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save quote
         * @param {QuoteCartRepositoryV1SavePutBody} [quoteCartRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody?: QuoteCartRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ErrorResponse> {
            const localVarFetchArgs = QuoteCartRepositoryV1ApiFetchParamCreator(configuration).quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteCartRepositoryV1Api - factory interface
 * @export
 */
export const QuoteCartRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Enables an administrative user to return information for a specified cart.
         * @param {number} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1GetGet(cartId: number, options?: any) {
            return QuoteCartRepositoryV1ApiFp(configuration).quoteCartRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Enables administrative users to list carts that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#CartRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return QuoteCartRepositoryV1ApiFp(configuration).quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save quote
         * @param {QuoteCartRepositoryV1SavePutBody} [quoteCartRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody?: QuoteCartRepositoryV1SavePutBody, options?: any) {
            return QuoteCartRepositoryV1ApiFp(configuration).quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteCartRepositoryV1Api - object-oriented interface
 * @export
 * @class QuoteCartRepositoryV1Api
 * @extends {BaseAPI}
 */
export class QuoteCartRepositoryV1Api extends BaseAPI {
    /**
     * Enables an administrative user to return information for a specified cart.
     * @param {number} cartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartRepositoryV1Api
     */
    public quoteCartRepositoryV1GetGet(cartId: number, options?: any) {
        return QuoteCartRepositoryV1ApiFp(this.configuration).quoteCartRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Enables administrative users to list carts that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#CartRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartRepositoryV1Api
     */
    public quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return QuoteCartRepositoryV1ApiFp(this.configuration).quoteCartRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save quote
     * @param {QuoteCartRepositoryV1SavePutBody} [quoteCartRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartRepositoryV1Api
     */
    public quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody?: QuoteCartRepositoryV1SavePutBody, options?: any) {
        return QuoteCartRepositoryV1ApiFp(this.configuration).quoteCartRepositoryV1SavePut(quoteCartRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteCartTotalManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteCartTotalManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set shipping/billing methods and additional data for cart and collect totals.
         * @param {QuoteCartTotalManagementV1CollectTotalsPutBody} [quoteCartTotalManagementV1CollectTotalsPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody?: QuoteCartTotalManagementV1CollectTotalsPutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/collect-totals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteCartTotalManagementV1CollectTotalsPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteCartTotalManagementV1CollectTotalsPutBody || {}) : (quoteCartTotalManagementV1CollectTotalsPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteCartTotalManagementV1Api - functional programming interface
 * @export
 */
export const QuoteCartTotalManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Set shipping/billing methods and additional data for cart and collect totals.
         * @param {QuoteCartTotalManagementV1CollectTotalsPutBody} [quoteCartTotalManagementV1CollectTotalsPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody?: QuoteCartTotalManagementV1CollectTotalsPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = QuoteCartTotalManagementV1ApiFetchParamCreator(configuration).quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteCartTotalManagementV1Api - factory interface
 * @export
 */
export const QuoteCartTotalManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Set shipping/billing methods and additional data for cart and collect totals.
         * @param {QuoteCartTotalManagementV1CollectTotalsPutBody} [quoteCartTotalManagementV1CollectTotalsPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody?: QuoteCartTotalManagementV1CollectTotalsPutBody, options?: any) {
            return QuoteCartTotalManagementV1ApiFp(configuration).quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteCartTotalManagementV1Api - object-oriented interface
 * @export
 * @class QuoteCartTotalManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteCartTotalManagementV1Api extends BaseAPI {
    /**
     * Set shipping/billing methods and additional data for cart and collect totals.
     * @param {QuoteCartTotalManagementV1CollectTotalsPutBody} [quoteCartTotalManagementV1CollectTotalsPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartTotalManagementV1Api
     */
    public quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody?: QuoteCartTotalManagementV1CollectTotalsPutBody, options?: any) {
        return QuoteCartTotalManagementV1ApiFp(this.configuration).quoteCartTotalManagementV1CollectTotalsPut(quoteCartTotalManagementV1CollectTotalsPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteCartTotalRepositoryV1Api - fetch parameter creator
 * @export
 */
export const QuoteCartTotalRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns quote totals data for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalRepositoryV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCartTotalRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/totals`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns quote totals data for a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalRepositoryV1GetGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/totals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteCartTotalRepositoryV1Api - functional programming interface
 * @export
 */
export const QuoteCartTotalRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns quote totals data for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalRepositoryV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = QuoteCartTotalRepositoryV1ApiFetchParamCreator(configuration).quoteCartTotalRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns quote totals data for a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalRepositoryV1GetGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = QuoteCartTotalRepositoryV1ApiFetchParamCreator(configuration).quoteCartTotalRepositoryV1GetGet_1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteCartTotalRepositoryV1Api - factory interface
 * @export
 */
export const QuoteCartTotalRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns quote totals data for a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalRepositoryV1GetGet(cartId: number, options?: any) {
            return QuoteCartTotalRepositoryV1ApiFp(configuration).quoteCartTotalRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Returns quote totals data for a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCartTotalRepositoryV1GetGet_1(options?: any) {
            return QuoteCartTotalRepositoryV1ApiFp(configuration).quoteCartTotalRepositoryV1GetGet_1(options)(fetch, basePath);
        },
    };
};

/**
 * QuoteCartTotalRepositoryV1Api - object-oriented interface
 * @export
 * @class QuoteCartTotalRepositoryV1Api
 * @extends {BaseAPI}
 */
export class QuoteCartTotalRepositoryV1Api extends BaseAPI {
    /**
     * Returns quote totals data for a specified cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartTotalRepositoryV1Api
     */
    public quoteCartTotalRepositoryV1GetGet(cartId: number, options?: any) {
        return QuoteCartTotalRepositoryV1ApiFp(this.configuration).quoteCartTotalRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns quote totals data for a specified cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCartTotalRepositoryV1Api
     */
    public quoteCartTotalRepositoryV1GetGet_1(options?: any) {
        return QuoteCartTotalRepositoryV1ApiFp(this.configuration).quoteCartTotalRepositoryV1GetGet_1(options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteCouponManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteCouponManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information for a coupon in a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCouponManagementV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/coupons`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information for a coupon in a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1GetGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a coupon from a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1RemoveDelete(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCouponManagementV1RemoveDelete.');
            }
            const localVarPath = `/V1/carts/{cartId}/coupons`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a coupon from a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1RemoveDelete_2(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1SetPut(cartId: number, couponCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteCouponManagementV1SetPut.');
            }
            // verify required parameter 'couponCode' is not null or undefined
            if (couponCode === null || couponCode === undefined) {
                throw new RequiredError('couponCode','Required parameter couponCode was null or undefined when calling quoteCouponManagementV1SetPut.');
            }
            const localVarPath = `/V1/carts/{cartId}/coupons/{couponCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"couponCode"}}`, encodeURIComponent(String(couponCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1SetPut_3(couponCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'couponCode' is not null or undefined
            if (couponCode === null || couponCode === undefined) {
                throw new RequiredError('couponCode','Required parameter couponCode was null or undefined when calling quoteCouponManagementV1SetPut_3.');
            }
            const localVarPath = `/V1/carts/mine/coupons/{couponCode}`
                .replace(`{${"couponCode"}}`, encodeURIComponent(String(couponCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteCouponManagementV1Api - functional programming interface
 * @export
 */
export const QuoteCouponManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns information for a coupon in a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = QuoteCouponManagementV1ApiFetchParamCreator(configuration).quoteCouponManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns information for a coupon in a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1GetGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = QuoteCouponManagementV1ApiFetchParamCreator(configuration).quoteCouponManagementV1GetGet_1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a coupon from a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1RemoveDelete(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCouponManagementV1ApiFetchParamCreator(configuration).quoteCouponManagementV1RemoveDelete(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a coupon from a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1RemoveDelete_2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCouponManagementV1ApiFetchParamCreator(configuration).quoteCouponManagementV1RemoveDelete_2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1SetPut(cartId: number, couponCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCouponManagementV1ApiFetchParamCreator(configuration).quoteCouponManagementV1SetPut(cartId, couponCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1SetPut_3(couponCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteCouponManagementV1ApiFetchParamCreator(configuration).quoteCouponManagementV1SetPut_3(couponCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteCouponManagementV1Api - factory interface
 * @export
 */
export const QuoteCouponManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns information for a coupon in a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1GetGet(cartId: number, options?: any) {
            return QuoteCouponManagementV1ApiFp(configuration).quoteCouponManagementV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Returns information for a coupon in a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1GetGet_1(options?: any) {
            return QuoteCouponManagementV1ApiFp(configuration).quoteCouponManagementV1GetGet_1(options)(fetch, basePath);
        },
        /**
         * Deletes a coupon from a specified cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1RemoveDelete(cartId: number, options?: any) {
            return QuoteCouponManagementV1ApiFp(configuration).quoteCouponManagementV1RemoveDelete(cartId, options)(fetch, basePath);
        },
        /**
         * Deletes a coupon from a specified cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1RemoveDelete_2(options?: any) {
            return QuoteCouponManagementV1ApiFp(configuration).quoteCouponManagementV1RemoveDelete_2(options)(fetch, basePath);
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {number} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1SetPut(cartId: number, couponCode: string, options?: any) {
            return QuoteCouponManagementV1ApiFp(configuration).quoteCouponManagementV1SetPut(cartId, couponCode, options)(fetch, basePath);
        },
        /**
         * Adds a coupon by code to a specified cart.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteCouponManagementV1SetPut_3(couponCode: string, options?: any) {
            return QuoteCouponManagementV1ApiFp(configuration).quoteCouponManagementV1SetPut_3(couponCode, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteCouponManagementV1Api - object-oriented interface
 * @export
 * @class QuoteCouponManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteCouponManagementV1Api extends BaseAPI {
    /**
     * Returns information for a coupon in a specified cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCouponManagementV1Api
     */
    public quoteCouponManagementV1GetGet(cartId: number, options?: any) {
        return QuoteCouponManagementV1ApiFp(this.configuration).quoteCouponManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns information for a coupon in a specified cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCouponManagementV1Api
     */
    public quoteCouponManagementV1GetGet_1(options?: any) {
        return QuoteCouponManagementV1ApiFp(this.configuration).quoteCouponManagementV1GetGet_1(options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a coupon from a specified cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCouponManagementV1Api
     */
    public quoteCouponManagementV1RemoveDelete(cartId: number, options?: any) {
        return QuoteCouponManagementV1ApiFp(this.configuration).quoteCouponManagementV1RemoveDelete(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a coupon from a specified cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCouponManagementV1Api
     */
    public quoteCouponManagementV1RemoveDelete_2(options?: any) {
        return QuoteCouponManagementV1ApiFp(this.configuration).quoteCouponManagementV1RemoveDelete_2(options)(this.fetch, this.basePath);
    }

    /**
     * Adds a coupon by code to a specified cart.
     * @param {number} cartId The cart ID.
     * @param {string} couponCode The coupon code data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCouponManagementV1Api
     */
    public quoteCouponManagementV1SetPut(cartId: number, couponCode: string, options?: any) {
        return QuoteCouponManagementV1ApiFp(this.configuration).quoteCouponManagementV1SetPut(cartId, couponCode, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a coupon by code to a specified cart.
     * @param {string} couponCode The coupon code data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteCouponManagementV1Api
     */
    public quoteCouponManagementV1SetPut_3(couponCode: string, options?: any) {
        return QuoteCouponManagementV1ApiFp(this.configuration).quoteCouponManagementV1SetPut_3(couponCode, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestBillingAddressManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestBillingAddressManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign a specified billing address to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestBillingAddressManagementV1AssignPostBody} [quoteGuestBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestBillingAddressManagementV1AssignPost(cartId: string, quoteGuestBillingAddressManagementV1AssignPostBody?: QuoteGuestBillingAddressManagementV1AssignPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestBillingAddressManagementV1AssignPost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/billing-address`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestBillingAddressManagementV1AssignPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestBillingAddressManagementV1AssignPostBody || {}) : (quoteGuestBillingAddressManagementV1AssignPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the billing address for a specified quote.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestBillingAddressManagementV1GetGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestBillingAddressManagementV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/billing-address`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestBillingAddressManagementV1Api - functional programming interface
 * @export
 */
export const QuoteGuestBillingAddressManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assign a specified billing address to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestBillingAddressManagementV1AssignPostBody} [quoteGuestBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestBillingAddressManagementV1AssignPost(cartId: string, quoteGuestBillingAddressManagementV1AssignPostBody?: QuoteGuestBillingAddressManagementV1AssignPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteGuestBillingAddressManagementV1ApiFetchParamCreator(configuration).quoteGuestBillingAddressManagementV1AssignPost(cartId, quoteGuestBillingAddressManagementV1AssignPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the billing address for a specified quote.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestBillingAddressManagementV1GetGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataAddressInterface> {
            const localVarFetchArgs = QuoteGuestBillingAddressManagementV1ApiFetchParamCreator(configuration).quoteGuestBillingAddressManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestBillingAddressManagementV1Api - factory interface
 * @export
 */
export const QuoteGuestBillingAddressManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assign a specified billing address to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestBillingAddressManagementV1AssignPostBody} [quoteGuestBillingAddressManagementV1AssignPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestBillingAddressManagementV1AssignPost(cartId: string, quoteGuestBillingAddressManagementV1AssignPostBody?: QuoteGuestBillingAddressManagementV1AssignPostBody, options?: any) {
            return QuoteGuestBillingAddressManagementV1ApiFp(configuration).quoteGuestBillingAddressManagementV1AssignPost(cartId, quoteGuestBillingAddressManagementV1AssignPostBody, options)(fetch, basePath);
        },
        /**
         * Return the billing address for a specified quote.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestBillingAddressManagementV1GetGet(cartId: string, options?: any) {
            return QuoteGuestBillingAddressManagementV1ApiFp(configuration).quoteGuestBillingAddressManagementV1GetGet(cartId, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestBillingAddressManagementV1Api - object-oriented interface
 * @export
 * @class QuoteGuestBillingAddressManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestBillingAddressManagementV1Api extends BaseAPI {
    /**
     * Assign a specified billing address to a specified cart.
     * @param {string} cartId The cart ID.
     * @param {QuoteGuestBillingAddressManagementV1AssignPostBody} [quoteGuestBillingAddressManagementV1AssignPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestBillingAddressManagementV1Api
     */
    public quoteGuestBillingAddressManagementV1AssignPost(cartId: string, quoteGuestBillingAddressManagementV1AssignPostBody?: QuoteGuestBillingAddressManagementV1AssignPostBody, options?: any) {
        return QuoteGuestBillingAddressManagementV1ApiFp(this.configuration).quoteGuestBillingAddressManagementV1AssignPost(cartId, quoteGuestBillingAddressManagementV1AssignPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return the billing address for a specified quote.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestBillingAddressManagementV1Api
     */
    public quoteGuestBillingAddressManagementV1GetGet(cartId: string, options?: any) {
        return QuoteGuestBillingAddressManagementV1ApiFp(this.configuration).quoteGuestBillingAddressManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestCartItemRepositoryV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestCartItemRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove the specified item from the specified cart.
         * @param {string} cartId The cart ID.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId: string, itemId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartItemRepositoryV1DeleteByIdDelete.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling quoteGuestCartItemRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/items/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List items that are assigned to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1GetListGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartItemRepositoryV1GetListGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/items`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {QuoteGuestCartItemRepositoryV1SavePostBody} [quoteGuestCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1SavePost(cartId: string, quoteGuestCartItemRepositoryV1SavePostBody?: QuoteGuestCartItemRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartItemRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/items`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestCartItemRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestCartItemRepositoryV1SavePostBody || {}) : (quoteGuestCartItemRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {string} itemId
         * @param {QuoteGuestCartItemRepositoryV1SavePutBody} [quoteGuestCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteGuestCartItemRepositoryV1SavePutBody?: QuoteGuestCartItemRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartItemRepositoryV1SavePut.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling quoteGuestCartItemRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/items/{itemId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestCartItemRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestCartItemRepositoryV1SavePutBody || {}) : (quoteGuestCartItemRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestCartItemRepositoryV1Api - functional programming interface
 * @export
 */
export const QuoteGuestCartItemRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove the specified item from the specified cart.
         * @param {string} cartId The cart ID.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId: string, itemId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteGuestCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId, itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List items that are assigned to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1GetListGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataCartItemInterface>> {
            const localVarFetchArgs = QuoteGuestCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteGuestCartItemRepositoryV1GetListGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {QuoteGuestCartItemRepositoryV1SavePostBody} [quoteGuestCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1SavePost(cartId: string, quoteGuestCartItemRepositoryV1SavePostBody?: QuoteGuestCartItemRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartItemInterface> {
            const localVarFetchArgs = QuoteGuestCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteGuestCartItemRepositoryV1SavePost(cartId, quoteGuestCartItemRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {string} itemId
         * @param {QuoteGuestCartItemRepositoryV1SavePutBody} [quoteGuestCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteGuestCartItemRepositoryV1SavePutBody?: QuoteGuestCartItemRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartItemInterface> {
            const localVarFetchArgs = QuoteGuestCartItemRepositoryV1ApiFetchParamCreator(configuration).quoteGuestCartItemRepositoryV1SavePut(cartId, itemId, quoteGuestCartItemRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestCartItemRepositoryV1Api - factory interface
 * @export
 */
export const QuoteGuestCartItemRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove the specified item from the specified cart.
         * @param {string} cartId The cart ID.
         * @param {number} itemId The item ID of the item to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId: string, itemId: number, options?: any) {
            return QuoteGuestCartItemRepositoryV1ApiFp(configuration).quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId, itemId, options)(fetch, basePath);
        },
        /**
         * List items that are assigned to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1GetListGet(cartId: string, options?: any) {
            return QuoteGuestCartItemRepositoryV1ApiFp(configuration).quoteGuestCartItemRepositoryV1GetListGet(cartId, options)(fetch, basePath);
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {QuoteGuestCartItemRepositoryV1SavePostBody} [quoteGuestCartItemRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1SavePost(cartId: string, quoteGuestCartItemRepositoryV1SavePostBody?: QuoteGuestCartItemRepositoryV1SavePostBody, options?: any) {
            return QuoteGuestCartItemRepositoryV1ApiFp(configuration).quoteGuestCartItemRepositoryV1SavePost(cartId, quoteGuestCartItemRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Add/update the specified cart item.
         * @param {string} cartId
         * @param {string} itemId
         * @param {QuoteGuestCartItemRepositoryV1SavePutBody} [quoteGuestCartItemRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteGuestCartItemRepositoryV1SavePutBody?: QuoteGuestCartItemRepositoryV1SavePutBody, options?: any) {
            return QuoteGuestCartItemRepositoryV1ApiFp(configuration).quoteGuestCartItemRepositoryV1SavePut(cartId, itemId, quoteGuestCartItemRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestCartItemRepositoryV1Api - object-oriented interface
 * @export
 * @class QuoteGuestCartItemRepositoryV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestCartItemRepositoryV1Api extends BaseAPI {
    /**
     * Remove the specified item from the specified cart.
     * @param {string} cartId The cart ID.
     * @param {number} itemId The item ID of the item to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartItemRepositoryV1Api
     */
    public quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId: string, itemId: number, options?: any) {
        return QuoteGuestCartItemRepositoryV1ApiFp(this.configuration).quoteGuestCartItemRepositoryV1DeleteByIdDelete(cartId, itemId, options)(this.fetch, this.basePath);
    }

    /**
     * List items that are assigned to a specified cart.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartItemRepositoryV1Api
     */
    public quoteGuestCartItemRepositoryV1GetListGet(cartId: string, options?: any) {
        return QuoteGuestCartItemRepositoryV1ApiFp(this.configuration).quoteGuestCartItemRepositoryV1GetListGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Add/update the specified cart item.
     * @param {string} cartId
     * @param {QuoteGuestCartItemRepositoryV1SavePostBody} [quoteGuestCartItemRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartItemRepositoryV1Api
     */
    public quoteGuestCartItemRepositoryV1SavePost(cartId: string, quoteGuestCartItemRepositoryV1SavePostBody?: QuoteGuestCartItemRepositoryV1SavePostBody, options?: any) {
        return QuoteGuestCartItemRepositoryV1ApiFp(this.configuration).quoteGuestCartItemRepositoryV1SavePost(cartId, quoteGuestCartItemRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Add/update the specified cart item.
     * @param {string} cartId
     * @param {string} itemId
     * @param {QuoteGuestCartItemRepositoryV1SavePutBody} [quoteGuestCartItemRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartItemRepositoryV1Api
     */
    public quoteGuestCartItemRepositoryV1SavePut(cartId: string, itemId: string, quoteGuestCartItemRepositoryV1SavePutBody?: QuoteGuestCartItemRepositoryV1SavePutBody, options?: any) {
        return QuoteGuestCartItemRepositoryV1ApiFp(this.configuration).quoteGuestCartItemRepositoryV1SavePut(cartId, itemId, quoteGuestCartItemRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestCartManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestCartManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign a specified customer to a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartManagementV1AssignCustomerPutBody} [quoteGuestCartManagementV1AssignCustomerPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1AssignCustomerPut(cartId: string, quoteGuestCartManagementV1AssignCustomerPutBody?: QuoteGuestCartManagementV1AssignCustomerPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartManagementV1AssignCustomerPut.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestCartManagementV1AssignCustomerPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestCartManagementV1AssignCustomerPutBody || {}) : (quoteGuestCartManagementV1AssignCustomerPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable an customer or guest user to create an empty cart and quote for an anonymous customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1CreateEmptyCartPost(options: any = {}): FetchArgs {
            const localVarPath = `/V1/guest-carts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place an order for a specified cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartManagementV1PlaceOrderPutBody} [quoteGuestCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1PlaceOrderPut(cartId: string, quoteGuestCartManagementV1PlaceOrderPutBody?: QuoteGuestCartManagementV1PlaceOrderPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartManagementV1PlaceOrderPut.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/order`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestCartManagementV1PlaceOrderPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestCartManagementV1PlaceOrderPutBody || {}) : (quoteGuestCartManagementV1PlaceOrderPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestCartManagementV1Api - functional programming interface
 * @export
 */
export const QuoteGuestCartManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assign a specified customer to a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartManagementV1AssignCustomerPutBody} [quoteGuestCartManagementV1AssignCustomerPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1AssignCustomerPut(cartId: string, quoteGuestCartManagementV1AssignCustomerPutBody?: QuoteGuestCartManagementV1AssignCustomerPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteGuestCartManagementV1ApiFetchParamCreator(configuration).quoteGuestCartManagementV1AssignCustomerPut(cartId, quoteGuestCartManagementV1AssignCustomerPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable an customer or guest user to create an empty cart and quote for an anonymous customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1CreateEmptyCartPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = QuoteGuestCartManagementV1ApiFetchParamCreator(configuration).quoteGuestCartManagementV1CreateEmptyCartPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Place an order for a specified cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartManagementV1PlaceOrderPutBody} [quoteGuestCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1PlaceOrderPut(cartId: string, quoteGuestCartManagementV1PlaceOrderPutBody?: QuoteGuestCartManagementV1PlaceOrderPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteGuestCartManagementV1ApiFetchParamCreator(configuration).quoteGuestCartManagementV1PlaceOrderPut(cartId, quoteGuestCartManagementV1PlaceOrderPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestCartManagementV1Api - factory interface
 * @export
 */
export const QuoteGuestCartManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assign a specified customer to a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartManagementV1AssignCustomerPutBody} [quoteGuestCartManagementV1AssignCustomerPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1AssignCustomerPut(cartId: string, quoteGuestCartManagementV1AssignCustomerPutBody?: QuoteGuestCartManagementV1AssignCustomerPutBody, options?: any) {
            return QuoteGuestCartManagementV1ApiFp(configuration).quoteGuestCartManagementV1AssignCustomerPut(cartId, quoteGuestCartManagementV1AssignCustomerPutBody, options)(fetch, basePath);
        },
        /**
         * Enable an customer or guest user to create an empty cart and quote for an anonymous customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1CreateEmptyCartPost(options?: any) {
            return QuoteGuestCartManagementV1ApiFp(configuration).quoteGuestCartManagementV1CreateEmptyCartPost(options)(fetch, basePath);
        },
        /**
         * Place an order for a specified cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartManagementV1PlaceOrderPutBody} [quoteGuestCartManagementV1PlaceOrderPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartManagementV1PlaceOrderPut(cartId: string, quoteGuestCartManagementV1PlaceOrderPutBody?: QuoteGuestCartManagementV1PlaceOrderPutBody, options?: any) {
            return QuoteGuestCartManagementV1ApiFp(configuration).quoteGuestCartManagementV1PlaceOrderPut(cartId, quoteGuestCartManagementV1PlaceOrderPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestCartManagementV1Api - object-oriented interface
 * @export
 * @class QuoteGuestCartManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestCartManagementV1Api extends BaseAPI {
    /**
     * Assign a specified customer to a specified shopping cart.
     * @param {string} cartId The cart ID.
     * @param {QuoteGuestCartManagementV1AssignCustomerPutBody} [quoteGuestCartManagementV1AssignCustomerPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartManagementV1Api
     */
    public quoteGuestCartManagementV1AssignCustomerPut(cartId: string, quoteGuestCartManagementV1AssignCustomerPutBody?: QuoteGuestCartManagementV1AssignCustomerPutBody, options?: any) {
        return QuoteGuestCartManagementV1ApiFp(this.configuration).quoteGuestCartManagementV1AssignCustomerPut(cartId, quoteGuestCartManagementV1AssignCustomerPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Enable an customer or guest user to create an empty cart and quote for an anonymous customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartManagementV1Api
     */
    public quoteGuestCartManagementV1CreateEmptyCartPost(options?: any) {
        return QuoteGuestCartManagementV1ApiFp(this.configuration).quoteGuestCartManagementV1CreateEmptyCartPost(options)(this.fetch, this.basePath);
    }

    /**
     * Place an order for a specified cart.
     * @param {string} cartId The cart ID.
     * @param {QuoteGuestCartManagementV1PlaceOrderPutBody} [quoteGuestCartManagementV1PlaceOrderPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartManagementV1Api
     */
    public quoteGuestCartManagementV1PlaceOrderPut(cartId: string, quoteGuestCartManagementV1PlaceOrderPutBody?: QuoteGuestCartManagementV1PlaceOrderPutBody, options?: any) {
        return QuoteGuestCartManagementV1ApiFp(this.configuration).quoteGuestCartManagementV1PlaceOrderPut(cartId, quoteGuestCartManagementV1PlaceOrderPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestCartRepositoryV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestCartRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enable a guest user to return information for a specified cart.
         * @param {string} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartRepositoryV1GetGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestCartRepositoryV1Api - functional programming interface
 * @export
 */
export const QuoteGuestCartRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Enable a guest user to return information for a specified cart.
         * @param {string} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartRepositoryV1GetGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataCartInterface> {
            const localVarFetchArgs = QuoteGuestCartRepositoryV1ApiFetchParamCreator(configuration).quoteGuestCartRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestCartRepositoryV1Api - factory interface
 * @export
 */
export const QuoteGuestCartRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Enable a guest user to return information for a specified cart.
         * @param {string} cartId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartRepositoryV1GetGet(cartId: string, options?: any) {
            return QuoteGuestCartRepositoryV1ApiFp(configuration).quoteGuestCartRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestCartRepositoryV1Api - object-oriented interface
 * @export
 * @class QuoteGuestCartRepositoryV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestCartRepositoryV1Api extends BaseAPI {
    /**
     * Enable a guest user to return information for a specified cart.
     * @param {string} cartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartRepositoryV1Api
     */
    public quoteGuestCartRepositoryV1GetGet(cartId: string, options?: any) {
        return QuoteGuestCartRepositoryV1ApiFp(this.configuration).quoteGuestCartRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestCartTotalManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestCartTotalManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set shipping/billing methods and additional data for cart and collect totals for guest.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartTotalManagementV1CollectTotalsPutBody} [quoteGuestCartTotalManagementV1CollectTotalsPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartTotalManagementV1CollectTotalsPut(cartId: string, quoteGuestCartTotalManagementV1CollectTotalsPutBody?: QuoteGuestCartTotalManagementV1CollectTotalsPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartTotalManagementV1CollectTotalsPut.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/collect-totals`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestCartTotalManagementV1CollectTotalsPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestCartTotalManagementV1CollectTotalsPutBody || {}) : (quoteGuestCartTotalManagementV1CollectTotalsPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestCartTotalManagementV1Api - functional programming interface
 * @export
 */
export const QuoteGuestCartTotalManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Set shipping/billing methods and additional data for cart and collect totals for guest.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartTotalManagementV1CollectTotalsPutBody} [quoteGuestCartTotalManagementV1CollectTotalsPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartTotalManagementV1CollectTotalsPut(cartId: string, quoteGuestCartTotalManagementV1CollectTotalsPutBody?: QuoteGuestCartTotalManagementV1CollectTotalsPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = QuoteGuestCartTotalManagementV1ApiFetchParamCreator(configuration).quoteGuestCartTotalManagementV1CollectTotalsPut(cartId, quoteGuestCartTotalManagementV1CollectTotalsPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestCartTotalManagementV1Api - factory interface
 * @export
 */
export const QuoteGuestCartTotalManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Set shipping/billing methods and additional data for cart and collect totals for guest.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestCartTotalManagementV1CollectTotalsPutBody} [quoteGuestCartTotalManagementV1CollectTotalsPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartTotalManagementV1CollectTotalsPut(cartId: string, quoteGuestCartTotalManagementV1CollectTotalsPutBody?: QuoteGuestCartTotalManagementV1CollectTotalsPutBody, options?: any) {
            return QuoteGuestCartTotalManagementV1ApiFp(configuration).quoteGuestCartTotalManagementV1CollectTotalsPut(cartId, quoteGuestCartTotalManagementV1CollectTotalsPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestCartTotalManagementV1Api - object-oriented interface
 * @export
 * @class QuoteGuestCartTotalManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestCartTotalManagementV1Api extends BaseAPI {
    /**
     * Set shipping/billing methods and additional data for cart and collect totals for guest.
     * @param {string} cartId The cart ID.
     * @param {QuoteGuestCartTotalManagementV1CollectTotalsPutBody} [quoteGuestCartTotalManagementV1CollectTotalsPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartTotalManagementV1Api
     */
    public quoteGuestCartTotalManagementV1CollectTotalsPut(cartId: string, quoteGuestCartTotalManagementV1CollectTotalsPutBody?: QuoteGuestCartTotalManagementV1CollectTotalsPutBody, options?: any) {
        return QuoteGuestCartTotalManagementV1ApiFp(this.configuration).quoteGuestCartTotalManagementV1CollectTotalsPut(cartId, quoteGuestCartTotalManagementV1CollectTotalsPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestCartTotalRepositoryV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestCartTotalRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return quote totals data for a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartTotalRepositoryV1GetGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCartTotalRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/totals`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestCartTotalRepositoryV1Api - functional programming interface
 * @export
 */
export const QuoteGuestCartTotalRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return quote totals data for a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartTotalRepositoryV1GetGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataTotalsInterface> {
            const localVarFetchArgs = QuoteGuestCartTotalRepositoryV1ApiFetchParamCreator(configuration).quoteGuestCartTotalRepositoryV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestCartTotalRepositoryV1Api - factory interface
 * @export
 */
export const QuoteGuestCartTotalRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return quote totals data for a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCartTotalRepositoryV1GetGet(cartId: string, options?: any) {
            return QuoteGuestCartTotalRepositoryV1ApiFp(configuration).quoteGuestCartTotalRepositoryV1GetGet(cartId, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestCartTotalRepositoryV1Api - object-oriented interface
 * @export
 * @class QuoteGuestCartTotalRepositoryV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestCartTotalRepositoryV1Api extends BaseAPI {
    /**
     * Return quote totals data for a specified cart.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCartTotalRepositoryV1Api
     */
    public quoteGuestCartTotalRepositoryV1GetGet(cartId: string, options?: any) {
        return QuoteGuestCartTotalRepositoryV1ApiFp(this.configuration).quoteGuestCartTotalRepositoryV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestCouponManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestCouponManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return information for a coupon in a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1GetGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCouponManagementV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/coupons`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a coupon from a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1RemoveDelete(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCouponManagementV1RemoveDelete.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/coupons`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a coupon by code to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1SetPut(cartId: string, couponCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestCouponManagementV1SetPut.');
            }
            // verify required parameter 'couponCode' is not null or undefined
            if (couponCode === null || couponCode === undefined) {
                throw new RequiredError('couponCode','Required parameter couponCode was null or undefined when calling quoteGuestCouponManagementV1SetPut.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/coupons/{couponCode}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)))
                .replace(`{${"couponCode"}}`, encodeURIComponent(String(couponCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestCouponManagementV1Api - functional programming interface
 * @export
 */
export const QuoteGuestCouponManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return information for a coupon in a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1GetGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = QuoteGuestCouponManagementV1ApiFetchParamCreator(configuration).quoteGuestCouponManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a coupon from a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1RemoveDelete(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteGuestCouponManagementV1ApiFetchParamCreator(configuration).quoteGuestCouponManagementV1RemoveDelete(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a coupon by code to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1SetPut(cartId: string, couponCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuoteGuestCouponManagementV1ApiFetchParamCreator(configuration).quoteGuestCouponManagementV1SetPut(cartId, couponCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestCouponManagementV1Api - factory interface
 * @export
 */
export const QuoteGuestCouponManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return information for a coupon in a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1GetGet(cartId: string, options?: any) {
            return QuoteGuestCouponManagementV1ApiFp(configuration).quoteGuestCouponManagementV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Delete a coupon from a specified cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1RemoveDelete(cartId: string, options?: any) {
            return QuoteGuestCouponManagementV1ApiFp(configuration).quoteGuestCouponManagementV1RemoveDelete(cartId, options)(fetch, basePath);
        },
        /**
         * Add a coupon by code to a specified cart.
         * @param {string} cartId The cart ID.
         * @param {string} couponCode The coupon code data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestCouponManagementV1SetPut(cartId: string, couponCode: string, options?: any) {
            return QuoteGuestCouponManagementV1ApiFp(configuration).quoteGuestCouponManagementV1SetPut(cartId, couponCode, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestCouponManagementV1Api - object-oriented interface
 * @export
 * @class QuoteGuestCouponManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestCouponManagementV1Api extends BaseAPI {
    /**
     * Return information for a coupon in a specified cart.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCouponManagementV1Api
     */
    public quoteGuestCouponManagementV1GetGet(cartId: string, options?: any) {
        return QuoteGuestCouponManagementV1ApiFp(this.configuration).quoteGuestCouponManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a coupon from a specified cart.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCouponManagementV1Api
     */
    public quoteGuestCouponManagementV1RemoveDelete(cartId: string, options?: any) {
        return QuoteGuestCouponManagementV1ApiFp(this.configuration).quoteGuestCouponManagementV1RemoveDelete(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Add a coupon by code to a specified cart.
     * @param {string} cartId The cart ID.
     * @param {string} couponCode The coupon code data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestCouponManagementV1Api
     */
    public quoteGuestCouponManagementV1SetPut(cartId: string, couponCode: string, options?: any) {
        return QuoteGuestCouponManagementV1ApiFp(this.configuration).quoteGuestCouponManagementV1SetPut(cartId, couponCode, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestPaymentMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestPaymentMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the payment method for a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1GetGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestPaymentMethodManagementV1GetGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/selected-payment-method`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#GuestPaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1GetListGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestPaymentMethodManagementV1GetListGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/payment-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a specified payment method to a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestPaymentMethodManagementV1SetPutBody} [quoteGuestPaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1SetPut(cartId: string, quoteGuestPaymentMethodManagementV1SetPutBody?: QuoteGuestPaymentMethodManagementV1SetPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestPaymentMethodManagementV1SetPut.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/selected-payment-method`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestPaymentMethodManagementV1SetPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestPaymentMethodManagementV1SetPutBody || {}) : (quoteGuestPaymentMethodManagementV1SetPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestPaymentMethodManagementV1Api - functional programming interface
 * @export
 */
export const QuoteGuestPaymentMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the payment method for a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1GetGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataPaymentInterface> {
            const localVarFetchArgs = QuoteGuestPaymentMethodManagementV1ApiFetchParamCreator(configuration).quoteGuestPaymentMethodManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#GuestPaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1GetListGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataPaymentMethodInterface>> {
            const localVarFetchArgs = QuoteGuestPaymentMethodManagementV1ApiFetchParamCreator(configuration).quoteGuestPaymentMethodManagementV1GetListGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a specified payment method to a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestPaymentMethodManagementV1SetPutBody} [quoteGuestPaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1SetPut(cartId: string, quoteGuestPaymentMethodManagementV1SetPutBody?: QuoteGuestPaymentMethodManagementV1SetPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuoteGuestPaymentMethodManagementV1ApiFetchParamCreator(configuration).quoteGuestPaymentMethodManagementV1SetPut(cartId, quoteGuestPaymentMethodManagementV1SetPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestPaymentMethodManagementV1Api - factory interface
 * @export
 */
export const QuoteGuestPaymentMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return the payment method for a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1GetGet(cartId: string, options?: any) {
            return QuoteGuestPaymentMethodManagementV1ApiFp(configuration).quoteGuestPaymentMethodManagementV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * List available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#GuestPaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1GetListGet(cartId: string, options?: any) {
            return QuoteGuestPaymentMethodManagementV1ApiFp(configuration).quoteGuestPaymentMethodManagementV1GetListGet(cartId, options)(fetch, basePath);
        },
        /**
         * Add a specified payment method to a specified shopping cart.
         * @param {string} cartId The cart ID.
         * @param {QuoteGuestPaymentMethodManagementV1SetPutBody} [quoteGuestPaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestPaymentMethodManagementV1SetPut(cartId: string, quoteGuestPaymentMethodManagementV1SetPutBody?: QuoteGuestPaymentMethodManagementV1SetPutBody, options?: any) {
            return QuoteGuestPaymentMethodManagementV1ApiFp(configuration).quoteGuestPaymentMethodManagementV1SetPut(cartId, quoteGuestPaymentMethodManagementV1SetPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestPaymentMethodManagementV1Api - object-oriented interface
 * @export
 * @class QuoteGuestPaymentMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestPaymentMethodManagementV1Api extends BaseAPI {
    /**
     * Return the payment method for a specified shopping cart.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestPaymentMethodManagementV1Api
     */
    public quoteGuestPaymentMethodManagementV1GetGet(cartId: string, options?: any) {
        return QuoteGuestPaymentMethodManagementV1ApiFp(this.configuration).quoteGuestPaymentMethodManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * List available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#GuestPaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestPaymentMethodManagementV1Api
     */
    public quoteGuestPaymentMethodManagementV1GetListGet(cartId: string, options?: any) {
        return QuoteGuestPaymentMethodManagementV1ApiFp(this.configuration).quoteGuestPaymentMethodManagementV1GetListGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Add a specified payment method to a specified shopping cart.
     * @param {string} cartId The cart ID.
     * @param {QuoteGuestPaymentMethodManagementV1SetPutBody} [quoteGuestPaymentMethodManagementV1SetPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestPaymentMethodManagementV1Api
     */
    public quoteGuestPaymentMethodManagementV1SetPut(cartId: string, quoteGuestPaymentMethodManagementV1SetPutBody?: QuoteGuestPaymentMethodManagementV1SetPutBody, options?: any) {
        return QuoteGuestPaymentMethodManagementV1ApiFp(this.configuration).quoteGuestPaymentMethodManagementV1SetPut(cartId, quoteGuestPaymentMethodManagementV1SetPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestShipmentEstimationV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestShipmentEstimationV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/estimate-shipping-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody || {}) : (quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestShipmentEstimationV1Api - functional programming interface
 * @export
 */
export const QuoteGuestShipmentEstimationV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteGuestShipmentEstimationV1ApiFetchParamCreator(configuration).quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestShipmentEstimationV1Api - factory interface
 * @export
 */
export const QuoteGuestShipmentEstimationV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any) {
            return QuoteGuestShipmentEstimationV1ApiFp(configuration).quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestShipmentEstimationV1Api - object-oriented interface
 * @export
 * @class QuoteGuestShipmentEstimationV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestShipmentEstimationV1Api extends BaseAPI {
    /**
     * Estimate shipping by address and return list of available shipping methods
     * @param {string} cartId
     * @param {QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestShipmentEstimationV1Api
     */
    public quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any) {
        return QuoteGuestShipmentEstimationV1ApiFp(this.configuration).quoteGuestShipmentEstimationV1EstimateByExtendedAddressPost(cartId, quoteGuestShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteGuestShippingMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteGuestShippingMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List applicable shipping methods for a specified quote.
         * @param {string} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestShippingMethodManagementV1GetListGet(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteGuestShippingMethodManagementV1GetListGet.');
            }
            const localVarPath = `/V1/guest-carts/{cartId}/shipping-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteGuestShippingMethodManagementV1Api - functional programming interface
 * @export
 */
export const QuoteGuestShippingMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List applicable shipping methods for a specified quote.
         * @param {string} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestShippingMethodManagementV1GetListGet(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteGuestShippingMethodManagementV1ApiFetchParamCreator(configuration).quoteGuestShippingMethodManagementV1GetListGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteGuestShippingMethodManagementV1Api - factory interface
 * @export
 */
export const QuoteGuestShippingMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List applicable shipping methods for a specified quote.
         * @param {string} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteGuestShippingMethodManagementV1GetListGet(cartId: string, options?: any) {
            return QuoteGuestShippingMethodManagementV1ApiFp(configuration).quoteGuestShippingMethodManagementV1GetListGet(cartId, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteGuestShippingMethodManagementV1Api - object-oriented interface
 * @export
 * @class QuoteGuestShippingMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteGuestShippingMethodManagementV1Api extends BaseAPI {
    /**
     * List applicable shipping methods for a specified quote.
     * @param {string} cartId The shopping cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteGuestShippingMethodManagementV1Api
     */
    public quoteGuestShippingMethodManagementV1GetListGet(cartId: string, options?: any) {
        return QuoteGuestShippingMethodManagementV1ApiFp(this.configuration).quoteGuestShippingMethodManagementV1GetListGet(cartId, options)(this.fetch, this.basePath);
    }

}

/**
 * QuotePaymentMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const QuotePaymentMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the payment method for a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quotePaymentMethodManagementV1GetGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/selected-payment-method`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the payment method for a specified shopping cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/selected-payment-method`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetListGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quotePaymentMethodManagementV1GetListGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/payment-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetListGet_2(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/payment-methods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a specified payment method to a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {QuotePaymentMethodManagementV1SetPutBody} [quotePaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1SetPut(cartId: number, quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quotePaymentMethodManagementV1SetPut.');
            }
            const localVarPath = `/V1/carts/{cartId}/selected-payment-method`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotePaymentMethodManagementV1SetPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quotePaymentMethodManagementV1SetPutBody || {}) : (quotePaymentMethodManagementV1SetPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a specified payment method to a specified shopping cart.
         * @param {QuotePaymentMethodManagementV1SetPutBody1} [quotePaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/selected-payment-method`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotePaymentMethodManagementV1SetPutBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quotePaymentMethodManagementV1SetPutBody || {}) : (quotePaymentMethodManagementV1SetPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotePaymentMethodManagementV1Api - functional programming interface
 * @export
 */
export const QuotePaymentMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the payment method for a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataPaymentInterface> {
            const localVarFetchArgs = QuotePaymentMethodManagementV1ApiFetchParamCreator(configuration).quotePaymentMethodManagementV1GetGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the payment method for a specified shopping cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDataPaymentInterface> {
            const localVarFetchArgs = QuotePaymentMethodManagementV1ApiFetchParamCreator(configuration).quotePaymentMethodManagementV1GetGet_1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetListGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataPaymentMethodInterface>> {
            const localVarFetchArgs = QuotePaymentMethodManagementV1ApiFetchParamCreator(configuration).quotePaymentMethodManagementV1GetListGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetListGet_2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataPaymentMethodInterface>> {
            const localVarFetchArgs = QuotePaymentMethodManagementV1ApiFetchParamCreator(configuration).quotePaymentMethodManagementV1GetListGet_2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a specified payment method to a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {QuotePaymentMethodManagementV1SetPutBody} [quotePaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1SetPut(cartId: number, quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = QuotePaymentMethodManagementV1ApiFetchParamCreator(configuration).quotePaymentMethodManagementV1SetPut(cartId, quotePaymentMethodManagementV1SetPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a specified payment method to a specified shopping cart.
         * @param {QuotePaymentMethodManagementV1SetPutBody1} [quotePaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = QuotePaymentMethodManagementV1ApiFetchParamCreator(configuration).quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuotePaymentMethodManagementV1Api - factory interface
 * @export
 */
export const QuotePaymentMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the payment method for a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetGet(cartId: number, options?: any) {
            return QuotePaymentMethodManagementV1ApiFp(configuration).quotePaymentMethodManagementV1GetGet(cartId, options)(fetch, basePath);
        },
        /**
         * Returns the payment method for a specified shopping cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetGet_1(options?: any) {
            return QuotePaymentMethodManagementV1ApiFp(configuration).quotePaymentMethodManagementV1GetGet_1(options)(fetch, basePath);
        },
        /**
         * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {number} cartId The cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetListGet(cartId: number, options?: any) {
            return QuotePaymentMethodManagementV1ApiFp(configuration).quotePaymentMethodManagementV1GetListGet(cartId, options)(fetch, basePath);
        },
        /**
         * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1GetListGet_2(options?: any) {
            return QuotePaymentMethodManagementV1ApiFp(configuration).quotePaymentMethodManagementV1GetListGet_2(options)(fetch, basePath);
        },
        /**
         * Adds a specified payment method to a specified shopping cart.
         * @param {number} cartId The cart ID.
         * @param {QuotePaymentMethodManagementV1SetPutBody} [quotePaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1SetPut(cartId: number, quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody, options?: any) {
            return QuotePaymentMethodManagementV1ApiFp(configuration).quotePaymentMethodManagementV1SetPut(cartId, quotePaymentMethodManagementV1SetPutBody, options)(fetch, basePath);
        },
        /**
         * Adds a specified payment method to a specified shopping cart.
         * @param {QuotePaymentMethodManagementV1SetPutBody1} [quotePaymentMethodManagementV1SetPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody1, options?: any) {
            return QuotePaymentMethodManagementV1ApiFp(configuration).quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuotePaymentMethodManagementV1Api - object-oriented interface
 * @export
 * @class QuotePaymentMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class QuotePaymentMethodManagementV1Api extends BaseAPI {
    /**
     * Returns the payment method for a specified shopping cart.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotePaymentMethodManagementV1Api
     */
    public quotePaymentMethodManagementV1GetGet(cartId: number, options?: any) {
        return QuotePaymentMethodManagementV1ApiFp(this.configuration).quotePaymentMethodManagementV1GetGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the payment method for a specified shopping cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotePaymentMethodManagementV1Api
     */
    public quotePaymentMethodManagementV1GetGet_1(options?: any) {
        return QuotePaymentMethodManagementV1ApiFp(this.configuration).quotePaymentMethodManagementV1GetGet_1(options)(this.fetch, this.basePath);
    }

    /**
     * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {number} cartId The cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotePaymentMethodManagementV1Api
     */
    public quotePaymentMethodManagementV1GetListGet(cartId: number, options?: any) {
        return QuotePaymentMethodManagementV1ApiFp(this.configuration).quotePaymentMethodManagementV1GetListGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists available payment methods for a specified shopping cart. This call returns an array of objects, but detailed information about each objects attributes might not be included.  See http://devdocs.magento.com/codelinks/attributes.html#PaymentMethodManagementInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotePaymentMethodManagementV1Api
     */
    public quotePaymentMethodManagementV1GetListGet_2(options?: any) {
        return QuotePaymentMethodManagementV1ApiFp(this.configuration).quotePaymentMethodManagementV1GetListGet_2(options)(this.fetch, this.basePath);
    }

    /**
     * Adds a specified payment method to a specified shopping cart.
     * @param {number} cartId The cart ID.
     * @param {QuotePaymentMethodManagementV1SetPutBody} [quotePaymentMethodManagementV1SetPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotePaymentMethodManagementV1Api
     */
    public quotePaymentMethodManagementV1SetPut(cartId: number, quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody, options?: any) {
        return QuotePaymentMethodManagementV1ApiFp(this.configuration).quotePaymentMethodManagementV1SetPut(cartId, quotePaymentMethodManagementV1SetPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a specified payment method to a specified shopping cart.
     * @param {QuotePaymentMethodManagementV1SetPutBody1} [quotePaymentMethodManagementV1SetPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotePaymentMethodManagementV1Api
     */
    public quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody?: QuotePaymentMethodManagementV1SetPutBody1, options?: any) {
        return QuotePaymentMethodManagementV1ApiFp(this.configuration).quotePaymentMethodManagementV1SetPut_3(quotePaymentMethodManagementV1SetPutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteShipmentEstimationV1Api - fetch parameter creator
 * @export
 */
export const QuoteShipmentEstimationV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteShipmentEstimationV1EstimateByExtendedAddressPost.');
            }
            const localVarPath = `/V1/carts/{cartId}/estimate-shipping-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody || {}) : (quoteShipmentEstimationV1EstimateByExtendedAddressPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/estimate-shipping-methods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody || {}) : (quoteShipmentEstimationV1EstimateByExtendedAddressPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteShipmentEstimationV1Api - functional programming interface
 * @export
 */
export const QuoteShipmentEstimationV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteShipmentEstimationV1ApiFetchParamCreator(configuration).quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteShipmentEstimationV1ApiFetchParamCreator(configuration).quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteShipmentEstimationV1Api - factory interface
 * @export
 */
export const QuoteShipmentEstimationV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {string} cartId
         * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any) {
            return QuoteShipmentEstimationV1ApiFp(configuration).quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(fetch, basePath);
        },
        /**
         * Estimate shipping by address and return list of available shipping methods
         * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1, options?: any) {
            return QuoteShipmentEstimationV1ApiFp(configuration).quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * QuoteShipmentEstimationV1Api - object-oriented interface
 * @export
 * @class QuoteShipmentEstimationV1Api
 * @extends {BaseAPI}
 */
export class QuoteShipmentEstimationV1Api extends BaseAPI {
    /**
     * Estimate shipping by address and return list of available shipping methods
     * @param {string} cartId
     * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteShipmentEstimationV1Api
     */
    public quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId: string, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options?: any) {
        return QuoteShipmentEstimationV1ApiFp(this.configuration).quoteShipmentEstimationV1EstimateByExtendedAddressPost(cartId, quoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Estimate shipping by address and return list of available shipping methods
     * @param {QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1} [quoteShipmentEstimationV1EstimateByExtendedAddressPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteShipmentEstimationV1Api
     */
    public quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody?: QuoteShipmentEstimationV1EstimateByExtendedAddressPostBody1, options?: any) {
        return QuoteShipmentEstimationV1ApiFp(this.configuration).quoteShipmentEstimationV1EstimateByExtendedAddressPost_1(quoteShipmentEstimationV1EstimateByExtendedAddressPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * QuoteShippingMethodManagementV1Api - fetch parameter creator
 * @export
 */
export const QuoteShippingMethodManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {number} cartId The shopping cart ID.
         * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteShippingMethodManagementV1EstimateByAddressIdPost.');
            }
            const localVarPath = `/V1/carts/{cartId}/estimate-shipping-methods-by-address-id`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteShippingMethodManagementV1EstimateByAddressIdPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteShippingMethodManagementV1EstimateByAddressIdPostBody || {}) : (quoteShippingMethodManagementV1EstimateByAddressIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate shipping
         * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1, options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/estimate-shipping-methods-by-address-id`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(quoteShippingMethodManagementV1EstimateByAddressIdPostBody || {}) : (quoteShippingMethodManagementV1EstimateByAddressIdPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists applicable shipping methods for a specified quote.
         * @param {number} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1GetListGet(cartId: number, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling quoteShippingMethodManagementV1GetListGet.');
            }
            const localVarPath = `/V1/carts/{cartId}/shipping-methods`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists applicable shipping methods for a specified quote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1GetListGet_2(options: any = {}): FetchArgs {
            const localVarPath = `/V1/carts/mine/shipping-methods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteShippingMethodManagementV1Api - functional programming interface
 * @export
 */
export const QuoteShippingMethodManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Estimate shipping
         * @param {number} cartId The shopping cart ID.
         * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteShippingMethodManagementV1ApiFetchParamCreator(configuration).quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId, quoteShippingMethodManagementV1EstimateByAddressIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Estimate shipping
         * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteShippingMethodManagementV1ApiFetchParamCreator(configuration).quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists applicable shipping methods for a specified quote.
         * @param {number} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1GetListGet(cartId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteShippingMethodManagementV1ApiFetchParamCreator(configuration).quoteShippingMethodManagementV1GetListGet(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists applicable shipping methods for a specified quote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1GetListGet_2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuoteDataShippingMethodInterface>> {
            const localVarFetchArgs = QuoteShippingMethodManagementV1ApiFetchParamCreator(configuration).quoteShippingMethodManagementV1GetListGet_2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuoteShippingMethodManagementV1Api - factory interface
 * @export
 */
export const QuoteShippingMethodManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Estimate shipping
         * @param {number} cartId The shopping cart ID.
         * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options?: any) {
            return QuoteShippingMethodManagementV1ApiFp(configuration).quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId, quoteShippingMethodManagementV1EstimateByAddressIdPostBody, options)(fetch, basePath);
        },
        /**
         * Estimate shipping
         * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1, options?: any) {
            return QuoteShippingMethodManagementV1ApiFp(configuration).quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody, options)(fetch, basePath);
        },
        /**
         * Lists applicable shipping methods for a specified quote.
         * @param {number} cartId The shopping cart ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1GetListGet(cartId: number, options?: any) {
            return QuoteShippingMethodManagementV1ApiFp(configuration).quoteShippingMethodManagementV1GetListGet(cartId, options)(fetch, basePath);
        },
        /**
         * Lists applicable shipping methods for a specified quote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteShippingMethodManagementV1GetListGet_2(options?: any) {
            return QuoteShippingMethodManagementV1ApiFp(configuration).quoteShippingMethodManagementV1GetListGet_2(options)(fetch, basePath);
        },
    };
};

/**
 * QuoteShippingMethodManagementV1Api - object-oriented interface
 * @export
 * @class QuoteShippingMethodManagementV1Api
 * @extends {BaseAPI}
 */
export class QuoteShippingMethodManagementV1Api extends BaseAPI {
    /**
     * Estimate shipping
     * @param {number} cartId The shopping cart ID.
     * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteShippingMethodManagementV1Api
     */
    public quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId: number, quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody, options?: any) {
        return QuoteShippingMethodManagementV1ApiFp(this.configuration).quoteShippingMethodManagementV1EstimateByAddressIdPost(cartId, quoteShippingMethodManagementV1EstimateByAddressIdPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Estimate shipping
     * @param {QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1} [quoteShippingMethodManagementV1EstimateByAddressIdPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteShippingMethodManagementV1Api
     */
    public quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody?: QuoteShippingMethodManagementV1EstimateByAddressIdPostBody1, options?: any) {
        return QuoteShippingMethodManagementV1ApiFp(this.configuration).quoteShippingMethodManagementV1EstimateByAddressIdPost_1(quoteShippingMethodManagementV1EstimateByAddressIdPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Lists applicable shipping methods for a specified quote.
     * @param {number} cartId The shopping cart ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteShippingMethodManagementV1Api
     */
    public quoteShippingMethodManagementV1GetListGet(cartId: number, options?: any) {
        return QuoteShippingMethodManagementV1ApiFp(this.configuration).quoteShippingMethodManagementV1GetListGet(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists applicable shipping methods for a specified quote.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteShippingMethodManagementV1Api
     */
    public quoteShippingMethodManagementV1GetListGet_2(options?: any) {
        return QuoteShippingMethodManagementV1ApiFp(this.configuration).quoteShippingMethodManagementV1GetListGet_2(options)(this.fetch, this.basePath);
    }

}

/**
 * RequisitionListRequisitionListRepositoryV1Api - fetch parameter creator
 * @export
 */
export const RequisitionListRequisitionListRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save Requisition List
         * @param {RequisitionListRequisitionListRepositoryV1SavePostBody} [requisitionListRequisitionListRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody?: RequisitionListRequisitionListRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/requisition_lists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequisitionListRequisitionListRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requisitionListRequisitionListRepositoryV1SavePostBody || {}) : (requisitionListRequisitionListRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequisitionListRequisitionListRepositoryV1Api - functional programming interface
 * @export
 */
export const RequisitionListRequisitionListRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Save Requisition List
         * @param {RequisitionListRequisitionListRepositoryV1SavePostBody} [requisitionListRequisitionListRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody?: RequisitionListRequisitionListRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RequisitionListDataRequisitionListInterface> {
            const localVarFetchArgs = RequisitionListRequisitionListRepositoryV1ApiFetchParamCreator(configuration).requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RequisitionListRequisitionListRepositoryV1Api - factory interface
 * @export
 */
export const RequisitionListRequisitionListRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Save Requisition List
         * @param {RequisitionListRequisitionListRepositoryV1SavePostBody} [requisitionListRequisitionListRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody?: RequisitionListRequisitionListRepositoryV1SavePostBody, options?: any) {
            return RequisitionListRequisitionListRepositoryV1ApiFp(configuration).requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * RequisitionListRequisitionListRepositoryV1Api - object-oriented interface
 * @export
 * @class RequisitionListRequisitionListRepositoryV1Api
 * @extends {BaseAPI}
 */
export class RequisitionListRequisitionListRepositoryV1Api extends BaseAPI {
    /**
     * Save Requisition List
     * @param {RequisitionListRequisitionListRepositoryV1SavePostBody} [requisitionListRequisitionListRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequisitionListRequisitionListRepositoryV1Api
     */
    public requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody?: RequisitionListRequisitionListRepositoryV1SavePostBody, options?: any) {
        return RequisitionListRequisitionListRepositoryV1ApiFp(this.configuration).requisitionListRequisitionListRepositoryV1SavePost(requisitionListRequisitionListRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * RewardRewardManagementV1Api - fetch parameter creator
 * @export
 */
export const RewardRewardManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set reward points to quote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardRewardManagementV1SetPost(options: any = {}): FetchArgs {
            const localVarPath = `/V1/reward/mine/use-reward`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardRewardManagementV1Api - functional programming interface
 * @export
 */
export const RewardRewardManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Set reward points to quote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardRewardManagementV1SetPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RewardRewardManagementV1ApiFetchParamCreator(configuration).rewardRewardManagementV1SetPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RewardRewardManagementV1Api - factory interface
 * @export
 */
export const RewardRewardManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Set reward points to quote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardRewardManagementV1SetPost(options?: any) {
            return RewardRewardManagementV1ApiFp(configuration).rewardRewardManagementV1SetPost(options)(fetch, basePath);
        },
    };
};

/**
 * RewardRewardManagementV1Api - object-oriented interface
 * @export
 * @class RewardRewardManagementV1Api
 * @extends {BaseAPI}
 */
export class RewardRewardManagementV1Api extends BaseAPI {
    /**
     * Set reward points to quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardRewardManagementV1Api
     */
    public rewardRewardManagementV1SetPost(options?: any) {
        return RewardRewardManagementV1ApiFp(this.configuration).rewardRewardManagementV1SetPost(options)(this.fetch, this.basePath);
    }

}

/**
 * RmaCommentManagementV1Api - fetch parameter creator
 * @export
 */
export const RmaCommentManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add comment
         * @param {string} id
         * @param {RmaCommentManagementV1AddCommentPostBody} [rmaCommentManagementV1AddCommentPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaCommentManagementV1AddCommentPost(id: string, rmaCommentManagementV1AddCommentPostBody?: RmaCommentManagementV1AddCommentPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaCommentManagementV1AddCommentPost.');
            }
            const localVarPath = `/V1/returns/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RmaCommentManagementV1AddCommentPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rmaCommentManagementV1AddCommentPostBody || {}) : (rmaCommentManagementV1AddCommentPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Comments list
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaCommentManagementV1CommentsListGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaCommentManagementV1CommentsListGet.');
            }
            const localVarPath = `/V1/returns/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RmaCommentManagementV1Api - functional programming interface
 * @export
 */
export const RmaCommentManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add comment
         * @param {string} id
         * @param {RmaCommentManagementV1AddCommentPostBody} [rmaCommentManagementV1AddCommentPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaCommentManagementV1AddCommentPost(id: string, rmaCommentManagementV1AddCommentPostBody?: RmaCommentManagementV1AddCommentPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RmaCommentManagementV1ApiFetchParamCreator(configuration).rmaCommentManagementV1AddCommentPost(id, rmaCommentManagementV1AddCommentPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Comments list
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaCommentManagementV1CommentsListGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RmaDataCommentSearchResultInterface> {
            const localVarFetchArgs = RmaCommentManagementV1ApiFetchParamCreator(configuration).rmaCommentManagementV1CommentsListGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RmaCommentManagementV1Api - factory interface
 * @export
 */
export const RmaCommentManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add comment
         * @param {string} id
         * @param {RmaCommentManagementV1AddCommentPostBody} [rmaCommentManagementV1AddCommentPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaCommentManagementV1AddCommentPost(id: string, rmaCommentManagementV1AddCommentPostBody?: RmaCommentManagementV1AddCommentPostBody, options?: any) {
            return RmaCommentManagementV1ApiFp(configuration).rmaCommentManagementV1AddCommentPost(id, rmaCommentManagementV1AddCommentPostBody, options)(fetch, basePath);
        },
        /**
         * Comments list
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaCommentManagementV1CommentsListGet(id: number, options?: any) {
            return RmaCommentManagementV1ApiFp(configuration).rmaCommentManagementV1CommentsListGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * RmaCommentManagementV1Api - object-oriented interface
 * @export
 * @class RmaCommentManagementV1Api
 * @extends {BaseAPI}
 */
export class RmaCommentManagementV1Api extends BaseAPI {
    /**
     * Add comment
     * @param {string} id
     * @param {RmaCommentManagementV1AddCommentPostBody} [rmaCommentManagementV1AddCommentPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaCommentManagementV1Api
     */
    public rmaCommentManagementV1AddCommentPost(id: string, rmaCommentManagementV1AddCommentPostBody?: RmaCommentManagementV1AddCommentPostBody, options?: any) {
        return RmaCommentManagementV1ApiFp(this.configuration).rmaCommentManagementV1AddCommentPost(id, rmaCommentManagementV1AddCommentPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Comments list
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaCommentManagementV1Api
     */
    public rmaCommentManagementV1CommentsListGet(id: number, options?: any) {
        return RmaCommentManagementV1ApiFp(this.configuration).rmaCommentManagementV1CommentsListGet(id, options)(this.fetch, this.basePath);
    }

}

/**
 * RmaRmaAttributesManagementV1Api - fetch parameter creator
 * @export
 */
export const RmaRmaAttributesManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/returnsAttributeMetadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeCode' is not null or undefined
            if (attributeCode === null || attributeCode === undefined) {
                throw new RequiredError('attributeCode','Required parameter attributeCode was null or undefined when calling rmaRmaAttributesManagementV1GetAttributeMetadataGet.');
            }
            const localVarPath = `/V1/returnsAttributeMetadata/{attributeCode}`
                .replace(`{${"attributeCode"}}`, encodeURIComponent(String(attributeCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAttributesGet(formCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'formCode' is not null or undefined
            if (formCode === null || formCode === undefined) {
                throw new RequiredError('formCode','Required parameter formCode was null or undefined when calling rmaRmaAttributesManagementV1GetAttributesGet.');
            }
            const localVarPath = `/V1/returnsAttributeMetadata/form/{formCode}`
                .replace(`{${"formCode"}}`, encodeURIComponent(String(formCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom attribute metadata for the given Data object's attribute set
         * @param {string} [dataObjectClassName] Data object class name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/V1/returnsAttributeMetadata/custom`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataObjectClassName !== undefined) {
                localVarQueryParameter['dataObjectClassName'] = dataObjectClassName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RmaRmaAttributesManagementV1Api - functional programming interface
 * @export
 */
export const RmaRmaAttributesManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = RmaRmaAttributesManagementV1ApiFetchParamCreator(configuration).rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDataAttributeMetadataInterface> {
            const localVarFetchArgs = RmaRmaAttributesManagementV1ApiFetchParamCreator(configuration).rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAttributesGet(formCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomerDataAttributeMetadataInterface>> {
            const localVarFetchArgs = RmaRmaAttributesManagementV1ApiFetchParamCreator(configuration).rmaRmaAttributesManagementV1GetAttributesGet(formCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get custom attribute metadata for the given Data object's attribute set
         * @param {string} [dataObjectClassName] Data object class name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FrameworkMetadataObjectInterface>> {
            const localVarFetchArgs = RmaRmaAttributesManagementV1ApiFetchParamCreator(configuration).rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RmaRmaAttributesManagementV1Api - factory interface
 * @export
 */
export const RmaRmaAttributesManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all attribute metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options?: any) {
            return RmaRmaAttributesManagementV1ApiFp(configuration).rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options)(fetch, basePath);
        },
        /**
         * Retrieve attribute metadata.
         * @param {string} attributeCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode: string, options?: any) {
            return RmaRmaAttributesManagementV1ApiFp(configuration).rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode, options)(fetch, basePath);
        },
        /**
         * Retrieve all attributes filtered by form code
         * @param {string} formCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetAttributesGet(formCode: string, options?: any) {
            return RmaRmaAttributesManagementV1ApiFp(configuration).rmaRmaAttributesManagementV1GetAttributesGet(formCode, options)(fetch, basePath);
        },
        /**
         * Get custom attribute metadata for the given Data object's attribute set
         * @param {string} [dataObjectClassName] Data object class name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName?: string, options?: any) {
            return RmaRmaAttributesManagementV1ApiFp(configuration).rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName, options)(fetch, basePath);
        },
    };
};

/**
 * RmaRmaAttributesManagementV1Api - object-oriented interface
 * @export
 * @class RmaRmaAttributesManagementV1Api
 * @extends {BaseAPI}
 */
export class RmaRmaAttributesManagementV1Api extends BaseAPI {
    /**
     * Get all attribute metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaAttributesManagementV1Api
     */
    public rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options?: any) {
        return RmaRmaAttributesManagementV1ApiFp(this.configuration).rmaRmaAttributesManagementV1GetAllAttributesMetadataGet(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve attribute metadata.
     * @param {string} attributeCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaAttributesManagementV1Api
     */
    public rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode: string, options?: any) {
        return RmaRmaAttributesManagementV1ApiFp(this.configuration).rmaRmaAttributesManagementV1GetAttributeMetadataGet(attributeCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all attributes filtered by form code
     * @param {string} formCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaAttributesManagementV1Api
     */
    public rmaRmaAttributesManagementV1GetAttributesGet(formCode: string, options?: any) {
        return RmaRmaAttributesManagementV1ApiFp(this.configuration).rmaRmaAttributesManagementV1GetAttributesGet(formCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get custom attribute metadata for the given Data object's attribute set
     * @param {string} [dataObjectClassName] Data object class name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaAttributesManagementV1Api
     */
    public rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName?: string, options?: any) {
        return RmaRmaAttributesManagementV1ApiFp(this.configuration).rmaRmaAttributesManagementV1GetCustomAttributesMetadataGet(dataObjectClassName, options)(this.fetch, this.basePath);
    }

}

/**
 * RmaRmaManagementV1Api - fetch parameter creator
 * @export
 */
export const RmaRmaManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save RMA
         * @param {RmaRmaManagementV1SaveRmaPostBody} [rmaRmaManagementV1SaveRmaPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody?: RmaRmaManagementV1SaveRmaPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/returns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RmaRmaManagementV1SaveRmaPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rmaRmaManagementV1SaveRmaPostBody || {}) : (rmaRmaManagementV1SaveRmaPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save RMA
         * @param {string} id
         * @param {RmaRmaManagementV1SaveRmaPutBody} [rmaRmaManagementV1SaveRmaPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SaveRmaPut(id: string, rmaRmaManagementV1SaveRmaPutBody?: RmaRmaManagementV1SaveRmaPutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaRmaManagementV1SaveRmaPut.');
            }
            const localVarPath = `/V1/returns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RmaRmaManagementV1SaveRmaPutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rmaRmaManagementV1SaveRmaPutBody || {}) : (rmaRmaManagementV1SaveRmaPutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return list of rma data objects based on search criteria
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/returns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RmaRmaManagementV1Api - functional programming interface
 * @export
 */
export const RmaRmaManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Save RMA
         * @param {RmaRmaManagementV1SaveRmaPostBody} [rmaRmaManagementV1SaveRmaPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody?: RmaRmaManagementV1SaveRmaPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RmaDataRmaInterface> {
            const localVarFetchArgs = RmaRmaManagementV1ApiFetchParamCreator(configuration).rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save RMA
         * @param {string} id
         * @param {RmaRmaManagementV1SaveRmaPutBody} [rmaRmaManagementV1SaveRmaPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SaveRmaPut(id: string, rmaRmaManagementV1SaveRmaPutBody?: RmaRmaManagementV1SaveRmaPutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RmaDataRmaInterface> {
            const localVarFetchArgs = RmaRmaManagementV1ApiFetchParamCreator(configuration).rmaRmaManagementV1SaveRmaPut(id, rmaRmaManagementV1SaveRmaPutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return list of rma data objects based on search criteria
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RmaDataRmaSearchResultInterface> {
            const localVarFetchArgs = RmaRmaManagementV1ApiFetchParamCreator(configuration).rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RmaRmaManagementV1Api - factory interface
 * @export
 */
export const RmaRmaManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Save RMA
         * @param {RmaRmaManagementV1SaveRmaPostBody} [rmaRmaManagementV1SaveRmaPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody?: RmaRmaManagementV1SaveRmaPostBody, options?: any) {
            return RmaRmaManagementV1ApiFp(configuration).rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody, options)(fetch, basePath);
        },
        /**
         * Save RMA
         * @param {string} id
         * @param {RmaRmaManagementV1SaveRmaPutBody} [rmaRmaManagementV1SaveRmaPutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SaveRmaPut(id: string, rmaRmaManagementV1SaveRmaPutBody?: RmaRmaManagementV1SaveRmaPutBody, options?: any) {
            return RmaRmaManagementV1ApiFp(configuration).rmaRmaManagementV1SaveRmaPut(id, rmaRmaManagementV1SaveRmaPutBody, options)(fetch, basePath);
        },
        /**
         * Return list of rma data objects based on search criteria
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return RmaRmaManagementV1ApiFp(configuration).rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * RmaRmaManagementV1Api - object-oriented interface
 * @export
 * @class RmaRmaManagementV1Api
 * @extends {BaseAPI}
 */
export class RmaRmaManagementV1Api extends BaseAPI {
    /**
     * Save RMA
     * @param {RmaRmaManagementV1SaveRmaPostBody} [rmaRmaManagementV1SaveRmaPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaManagementV1Api
     */
    public rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody?: RmaRmaManagementV1SaveRmaPostBody, options?: any) {
        return RmaRmaManagementV1ApiFp(this.configuration).rmaRmaManagementV1SaveRmaPost(rmaRmaManagementV1SaveRmaPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save RMA
     * @param {string} id
     * @param {RmaRmaManagementV1SaveRmaPutBody} [rmaRmaManagementV1SaveRmaPutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaManagementV1Api
     */
    public rmaRmaManagementV1SaveRmaPut(id: string, rmaRmaManagementV1SaveRmaPutBody?: RmaRmaManagementV1SaveRmaPutBody, options?: any) {
        return RmaRmaManagementV1ApiFp(this.configuration).rmaRmaManagementV1SaveRmaPut(id, rmaRmaManagementV1SaveRmaPutBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return list of rma data objects based on search criteria
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaManagementV1Api
     */
    public rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return RmaRmaManagementV1ApiFp(this.configuration).rmaRmaManagementV1SearchGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * RmaRmaRepositoryV1Api - fetch parameter creator
 * @export
 */
export const RmaRmaRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete RMA
         * @param {string} id
         * @param {RmaRmaRepositoryV1DeleteDeleteBody} [rmaRmaRepositoryV1DeleteDeleteBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaRepositoryV1DeleteDelete(id: string, rmaRmaRepositoryV1DeleteDeleteBody?: RmaRmaRepositoryV1DeleteDeleteBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaRmaRepositoryV1DeleteDelete.');
            }
            const localVarPath = `/V1/returns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RmaRmaRepositoryV1DeleteDeleteBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rmaRmaRepositoryV1DeleteDeleteBody || {}) : (rmaRmaRepositoryV1DeleteDeleteBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return data object for specified RMA id
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaRmaRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/returns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RmaRmaRepositoryV1Api - functional programming interface
 * @export
 */
export const RmaRmaRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete RMA
         * @param {string} id
         * @param {RmaRmaRepositoryV1DeleteDeleteBody} [rmaRmaRepositoryV1DeleteDeleteBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaRepositoryV1DeleteDelete(id: string, rmaRmaRepositoryV1DeleteDeleteBody?: RmaRmaRepositoryV1DeleteDeleteBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RmaRmaRepositoryV1ApiFetchParamCreator(configuration).rmaRmaRepositoryV1DeleteDelete(id, rmaRmaRepositoryV1DeleteDeleteBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return data object for specified RMA id
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RmaDataRmaInterface> {
            const localVarFetchArgs = RmaRmaRepositoryV1ApiFetchParamCreator(configuration).rmaRmaRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RmaRmaRepositoryV1Api - factory interface
 * @export
 */
export const RmaRmaRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete RMA
         * @param {string} id
         * @param {RmaRmaRepositoryV1DeleteDeleteBody} [rmaRmaRepositoryV1DeleteDeleteBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaRepositoryV1DeleteDelete(id: string, rmaRmaRepositoryV1DeleteDeleteBody?: RmaRmaRepositoryV1DeleteDeleteBody, options?: any) {
            return RmaRmaRepositoryV1ApiFp(configuration).rmaRmaRepositoryV1DeleteDelete(id, rmaRmaRepositoryV1DeleteDeleteBody, options)(fetch, basePath);
        },
        /**
         * Return data object for specified RMA id
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaRmaRepositoryV1GetGet(id: number, options?: any) {
            return RmaRmaRepositoryV1ApiFp(configuration).rmaRmaRepositoryV1GetGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * RmaRmaRepositoryV1Api - object-oriented interface
 * @export
 * @class RmaRmaRepositoryV1Api
 * @extends {BaseAPI}
 */
export class RmaRmaRepositoryV1Api extends BaseAPI {
    /**
     * Delete RMA
     * @param {string} id
     * @param {RmaRmaRepositoryV1DeleteDeleteBody} [rmaRmaRepositoryV1DeleteDeleteBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaRepositoryV1Api
     */
    public rmaRmaRepositoryV1DeleteDelete(id: string, rmaRmaRepositoryV1DeleteDeleteBody?: RmaRmaRepositoryV1DeleteDeleteBody, options?: any) {
        return RmaRmaRepositoryV1ApiFp(this.configuration).rmaRmaRepositoryV1DeleteDelete(id, rmaRmaRepositoryV1DeleteDeleteBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return data object for specified RMA id
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaRmaRepositoryV1Api
     */
    public rmaRmaRepositoryV1GetGet(id: number, options?: any) {
        return RmaRmaRepositoryV1ApiFp(this.configuration).rmaRmaRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

}

/**
 * RmaTrackManagementV1Api - fetch parameter creator
 * @export
 */
export const RmaTrackManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add track
         * @param {number} id
         * @param {RmaTrackManagementV1AddTrackPostBody} [rmaTrackManagementV1AddTrackPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1AddTrackPost(id: number, rmaTrackManagementV1AddTrackPostBody?: RmaTrackManagementV1AddTrackPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaTrackManagementV1AddTrackPost.');
            }
            const localVarPath = `/V1/returns/{id}/tracking-numbers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RmaTrackManagementV1AddTrackPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rmaTrackManagementV1AddTrackPostBody || {}) : (rmaTrackManagementV1AddTrackPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get shipping label int the PDF format
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1GetShippingLabelPdfGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaTrackManagementV1GetShippingLabelPdfGet.');
            }
            const localVarPath = `/V1/returns/{id}/labels`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get track list
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1GetTracksGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaTrackManagementV1GetTracksGet.');
            }
            const localVarPath = `/V1/returns/{id}/tracking-numbers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove track by id
         * @param {number} id
         * @param {number} trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1RemoveTrackByIdDelete(id: number, trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rmaTrackManagementV1RemoveTrackByIdDelete.');
            }
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling rmaTrackManagementV1RemoveTrackByIdDelete.');
            }
            const localVarPath = `/V1/returns/{id}/tracking-numbers/{trackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RmaTrackManagementV1Api - functional programming interface
 * @export
 */
export const RmaTrackManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add track
         * @param {number} id
         * @param {RmaTrackManagementV1AddTrackPostBody} [rmaTrackManagementV1AddTrackPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1AddTrackPost(id: number, rmaTrackManagementV1AddTrackPostBody?: RmaTrackManagementV1AddTrackPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RmaTrackManagementV1ApiFetchParamCreator(configuration).rmaTrackManagementV1AddTrackPost(id, rmaTrackManagementV1AddTrackPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get shipping label int the PDF format
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1GetShippingLabelPdfGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RmaTrackManagementV1ApiFetchParamCreator(configuration).rmaTrackManagementV1GetShippingLabelPdfGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get track list
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1GetTracksGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RmaDataTrackSearchResultInterface> {
            const localVarFetchArgs = RmaTrackManagementV1ApiFetchParamCreator(configuration).rmaTrackManagementV1GetTracksGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove track by id
         * @param {number} id
         * @param {number} trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1RemoveTrackByIdDelete(id: number, trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RmaTrackManagementV1ApiFetchParamCreator(configuration).rmaTrackManagementV1RemoveTrackByIdDelete(id, trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RmaTrackManagementV1Api - factory interface
 * @export
 */
export const RmaTrackManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add track
         * @param {number} id
         * @param {RmaTrackManagementV1AddTrackPostBody} [rmaTrackManagementV1AddTrackPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1AddTrackPost(id: number, rmaTrackManagementV1AddTrackPostBody?: RmaTrackManagementV1AddTrackPostBody, options?: any) {
            return RmaTrackManagementV1ApiFp(configuration).rmaTrackManagementV1AddTrackPost(id, rmaTrackManagementV1AddTrackPostBody, options)(fetch, basePath);
        },
        /**
         * Get shipping label int the PDF format
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1GetShippingLabelPdfGet(id: number, options?: any) {
            return RmaTrackManagementV1ApiFp(configuration).rmaTrackManagementV1GetShippingLabelPdfGet(id, options)(fetch, basePath);
        },
        /**
         * Get track list
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1GetTracksGet(id: number, options?: any) {
            return RmaTrackManagementV1ApiFp(configuration).rmaTrackManagementV1GetTracksGet(id, options)(fetch, basePath);
        },
        /**
         * Remove track by id
         * @param {number} id
         * @param {number} trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rmaTrackManagementV1RemoveTrackByIdDelete(id: number, trackId: number, options?: any) {
            return RmaTrackManagementV1ApiFp(configuration).rmaTrackManagementV1RemoveTrackByIdDelete(id, trackId, options)(fetch, basePath);
        },
    };
};

/**
 * RmaTrackManagementV1Api - object-oriented interface
 * @export
 * @class RmaTrackManagementV1Api
 * @extends {BaseAPI}
 */
export class RmaTrackManagementV1Api extends BaseAPI {
    /**
     * Add track
     * @param {number} id
     * @param {RmaTrackManagementV1AddTrackPostBody} [rmaTrackManagementV1AddTrackPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaTrackManagementV1Api
     */
    public rmaTrackManagementV1AddTrackPost(id: number, rmaTrackManagementV1AddTrackPostBody?: RmaTrackManagementV1AddTrackPostBody, options?: any) {
        return RmaTrackManagementV1ApiFp(this.configuration).rmaTrackManagementV1AddTrackPost(id, rmaTrackManagementV1AddTrackPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Get shipping label int the PDF format
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaTrackManagementV1Api
     */
    public rmaTrackManagementV1GetShippingLabelPdfGet(id: number, options?: any) {
        return RmaTrackManagementV1ApiFp(this.configuration).rmaTrackManagementV1GetShippingLabelPdfGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get track list
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaTrackManagementV1Api
     */
    public rmaTrackManagementV1GetTracksGet(id: number, options?: any) {
        return RmaTrackManagementV1ApiFp(this.configuration).rmaTrackManagementV1GetTracksGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Remove track by id
     * @param {number} id
     * @param {number} trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaTrackManagementV1Api
     */
    public rmaTrackManagementV1RemoveTrackByIdDelete(id: number, trackId: number, options?: any) {
        return RmaTrackManagementV1ApiFp(this.configuration).rmaTrackManagementV1RemoveTrackByIdDelete(id, trackId, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesCreditmemoCommentRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesCreditmemoCommentRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified entity.
         * @param {string} id
         * @param {SalesCreditmemoCommentRepositoryV1SavePostBody} [salesCreditmemoCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoCommentRepositoryV1SavePost(id: string, salesCreditmemoCommentRepositoryV1SavePostBody?: SalesCreditmemoCommentRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesCreditmemoCommentRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/creditmemo/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesCreditmemoCommentRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesCreditmemoCommentRepositoryV1SavePostBody || {}) : (salesCreditmemoCommentRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesCreditmemoCommentRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesCreditmemoCommentRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified entity.
         * @param {string} id
         * @param {SalesCreditmemoCommentRepositoryV1SavePostBody} [salesCreditmemoCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoCommentRepositoryV1SavePost(id: string, salesCreditmemoCommentRepositoryV1SavePostBody?: SalesCreditmemoCommentRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataCreditmemoCommentInterface> {
            const localVarFetchArgs = SalesCreditmemoCommentRepositoryV1ApiFetchParamCreator(configuration).salesCreditmemoCommentRepositoryV1SavePost(id, salesCreditmemoCommentRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesCreditmemoCommentRepositoryV1Api - factory interface
 * @export
 */
export const SalesCreditmemoCommentRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Performs persist operations for a specified entity.
         * @param {string} id
         * @param {SalesCreditmemoCommentRepositoryV1SavePostBody} [salesCreditmemoCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoCommentRepositoryV1SavePost(id: string, salesCreditmemoCommentRepositoryV1SavePostBody?: SalesCreditmemoCommentRepositoryV1SavePostBody, options?: any) {
            return SalesCreditmemoCommentRepositoryV1ApiFp(configuration).salesCreditmemoCommentRepositoryV1SavePost(id, salesCreditmemoCommentRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesCreditmemoCommentRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesCreditmemoCommentRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesCreditmemoCommentRepositoryV1Api extends BaseAPI {
    /**
     * Performs persist operations for a specified entity.
     * @param {string} id
     * @param {SalesCreditmemoCommentRepositoryV1SavePostBody} [salesCreditmemoCommentRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoCommentRepositoryV1Api
     */
    public salesCreditmemoCommentRepositoryV1SavePost(id: string, salesCreditmemoCommentRepositoryV1SavePostBody?: SalesCreditmemoCommentRepositoryV1SavePostBody, options?: any) {
        return SalesCreditmemoCommentRepositoryV1ApiFp(this.configuration).salesCreditmemoCommentRepositoryV1SavePost(id, salesCreditmemoCommentRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesCreditmemoManagementV1Api - fetch parameter creator
 * @export
 */
export const SalesCreditmemoManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1CancelPut(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesCreditmemoManagementV1CancelPut.');
            }
            const localVarPath = `/V1/creditmemo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists comments for a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1GetCommentsListGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesCreditmemoManagementV1GetCommentsListGet.');
            }
            const localVarPath = `/V1/creditmemo/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Emails a user a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1NotifyPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesCreditmemoManagementV1NotifyPost.');
            }
            const localVarPath = `/V1/creditmemo/{id}/emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Prepare creditmemo to refund and save it.
         * @param {SalesCreditmemoManagementV1RefundPostBody} [salesCreditmemoManagementV1RefundPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody?: SalesCreditmemoManagementV1RefundPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/creditmemo/refund`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesCreditmemoManagementV1RefundPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesCreditmemoManagementV1RefundPostBody || {}) : (salesCreditmemoManagementV1RefundPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesCreditmemoManagementV1Api - functional programming interface
 * @export
 */
export const SalesCreditmemoManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cancels a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1CancelPut(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesCreditmemoManagementV1ApiFetchParamCreator(configuration).salesCreditmemoManagementV1CancelPut(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists comments for a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1GetCommentsListGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataCreditmemoCommentSearchResultInterface> {
            const localVarFetchArgs = SalesCreditmemoManagementV1ApiFetchParamCreator(configuration).salesCreditmemoManagementV1GetCommentsListGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Emails a user a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1NotifyPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesCreditmemoManagementV1ApiFetchParamCreator(configuration).salesCreditmemoManagementV1NotifyPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Prepare creditmemo to refund and save it.
         * @param {SalesCreditmemoManagementV1RefundPostBody} [salesCreditmemoManagementV1RefundPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody?: SalesCreditmemoManagementV1RefundPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataCreditmemoInterface> {
            const localVarFetchArgs = SalesCreditmemoManagementV1ApiFetchParamCreator(configuration).salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesCreditmemoManagementV1Api - factory interface
 * @export
 */
export const SalesCreditmemoManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Cancels a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1CancelPut(id: number, options?: any) {
            return SalesCreditmemoManagementV1ApiFp(configuration).salesCreditmemoManagementV1CancelPut(id, options)(fetch, basePath);
        },
        /**
         * Lists comments for a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1GetCommentsListGet(id: number, options?: any) {
            return SalesCreditmemoManagementV1ApiFp(configuration).salesCreditmemoManagementV1GetCommentsListGet(id, options)(fetch, basePath);
        },
        /**
         * Emails a user a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1NotifyPost(id: number, options?: any) {
            return SalesCreditmemoManagementV1ApiFp(configuration).salesCreditmemoManagementV1NotifyPost(id, options)(fetch, basePath);
        },
        /**
         * Prepare creditmemo to refund and save it.
         * @param {SalesCreditmemoManagementV1RefundPostBody} [salesCreditmemoManagementV1RefundPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody?: SalesCreditmemoManagementV1RefundPostBody, options?: any) {
            return SalesCreditmemoManagementV1ApiFp(configuration).salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesCreditmemoManagementV1Api - object-oriented interface
 * @export
 * @class SalesCreditmemoManagementV1Api
 * @extends {BaseAPI}
 */
export class SalesCreditmemoManagementV1Api extends BaseAPI {
    /**
     * Cancels a specified credit memo.
     * @param {number} id The credit memo ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoManagementV1Api
     */
    public salesCreditmemoManagementV1CancelPut(id: number, options?: any) {
        return SalesCreditmemoManagementV1ApiFp(this.configuration).salesCreditmemoManagementV1CancelPut(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists comments for a specified credit memo.
     * @param {number} id The credit memo ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoManagementV1Api
     */
    public salesCreditmemoManagementV1GetCommentsListGet(id: number, options?: any) {
        return SalesCreditmemoManagementV1ApiFp(this.configuration).salesCreditmemoManagementV1GetCommentsListGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Emails a user a specified credit memo.
     * @param {number} id The credit memo ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoManagementV1Api
     */
    public salesCreditmemoManagementV1NotifyPost(id: number, options?: any) {
        return SalesCreditmemoManagementV1ApiFp(this.configuration).salesCreditmemoManagementV1NotifyPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Prepare creditmemo to refund and save it.
     * @param {SalesCreditmemoManagementV1RefundPostBody} [salesCreditmemoManagementV1RefundPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoManagementV1Api
     */
    public salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody?: SalesCreditmemoManagementV1RefundPostBody, options?: any) {
        return SalesCreditmemoManagementV1ApiFp(this.configuration).salesCreditmemoManagementV1RefundPost(salesCreditmemoManagementV1RefundPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesCreditmemoRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesCreditmemoRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loads a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesCreditmemoRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/creditmemo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists credit memos that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CreditmemoRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/creditmemos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs persist operations for a specified credit memo.
         * @param {SalesCreditmemoRepositoryV1SavePostBody} [salesCreditmemoRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody?: SalesCreditmemoRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/creditmemo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesCreditmemoRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesCreditmemoRepositoryV1SavePostBody || {}) : (salesCreditmemoRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesCreditmemoRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesCreditmemoRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loads a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataCreditmemoInterface> {
            const localVarFetchArgs = SalesCreditmemoRepositoryV1ApiFetchParamCreator(configuration).salesCreditmemoRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists credit memos that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CreditmemoRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataCreditmemoSearchResultInterface> {
            const localVarFetchArgs = SalesCreditmemoRepositoryV1ApiFetchParamCreator(configuration).salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs persist operations for a specified credit memo.
         * @param {SalesCreditmemoRepositoryV1SavePostBody} [salesCreditmemoRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody?: SalesCreditmemoRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataCreditmemoInterface> {
            const localVarFetchArgs = SalesCreditmemoRepositoryV1ApiFetchParamCreator(configuration).salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesCreditmemoRepositoryV1Api - factory interface
 * @export
 */
export const SalesCreditmemoRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loads a specified credit memo.
         * @param {number} id The credit memo ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1GetGet(id: number, options?: any) {
            return SalesCreditmemoRepositoryV1ApiFp(configuration).salesCreditmemoRepositoryV1GetGet(id, options)(fetch, basePath);
        },
        /**
         * Lists credit memos that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CreditmemoRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesCreditmemoRepositoryV1ApiFp(configuration).salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Performs persist operations for a specified credit memo.
         * @param {SalesCreditmemoRepositoryV1SavePostBody} [salesCreditmemoRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody?: SalesCreditmemoRepositoryV1SavePostBody, options?: any) {
            return SalesCreditmemoRepositoryV1ApiFp(configuration).salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesCreditmemoRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesCreditmemoRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesCreditmemoRepositoryV1Api extends BaseAPI {
    /**
     * Loads a specified credit memo.
     * @param {number} id The credit memo ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoRepositoryV1Api
     */
    public salesCreditmemoRepositoryV1GetGet(id: number, options?: any) {
        return SalesCreditmemoRepositoryV1ApiFp(this.configuration).salesCreditmemoRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists credit memos that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CreditmemoRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoRepositoryV1Api
     */
    public salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesCreditmemoRepositoryV1ApiFp(this.configuration).salesCreditmemoRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Performs persist operations for a specified credit memo.
     * @param {SalesCreditmemoRepositoryV1SavePostBody} [salesCreditmemoRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesCreditmemoRepositoryV1Api
     */
    public salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody?: SalesCreditmemoRepositoryV1SavePostBody, options?: any) {
        return SalesCreditmemoRepositoryV1ApiFp(this.configuration).salesCreditmemoRepositoryV1SavePost(salesCreditmemoRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesInvoiceCommentRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesInvoiceCommentRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified invoice comment.
         * @param {SalesInvoiceCommentRepositoryV1SavePostBody} [salesInvoiceCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody?: SalesInvoiceCommentRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/invoices/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesInvoiceCommentRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesInvoiceCommentRepositoryV1SavePostBody || {}) : (salesInvoiceCommentRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesInvoiceCommentRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesInvoiceCommentRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified invoice comment.
         * @param {SalesInvoiceCommentRepositoryV1SavePostBody} [salesInvoiceCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody?: SalesInvoiceCommentRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataInvoiceCommentInterface> {
            const localVarFetchArgs = SalesInvoiceCommentRepositoryV1ApiFetchParamCreator(configuration).salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesInvoiceCommentRepositoryV1Api - factory interface
 * @export
 */
export const SalesInvoiceCommentRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Performs persist operations for a specified invoice comment.
         * @param {SalesInvoiceCommentRepositoryV1SavePostBody} [salesInvoiceCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody?: SalesInvoiceCommentRepositoryV1SavePostBody, options?: any) {
            return SalesInvoiceCommentRepositoryV1ApiFp(configuration).salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesInvoiceCommentRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesInvoiceCommentRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesInvoiceCommentRepositoryV1Api extends BaseAPI {
    /**
     * Performs persist operations for a specified invoice comment.
     * @param {SalesInvoiceCommentRepositoryV1SavePostBody} [salesInvoiceCommentRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceCommentRepositoryV1Api
     */
    public salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody?: SalesInvoiceCommentRepositoryV1SavePostBody, options?: any) {
        return SalesInvoiceCommentRepositoryV1ApiFp(this.configuration).salesInvoiceCommentRepositoryV1SavePost(salesInvoiceCommentRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesInvoiceManagementV1Api - fetch parameter creator
 * @export
 */
export const SalesInvoiceManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists comments for a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1GetCommentsListGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesInvoiceManagementV1GetCommentsListGet.');
            }
            const localVarPath = `/V1/invoices/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Emails a user a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1NotifyPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesInvoiceManagementV1NotifyPost.');
            }
            const localVarPath = `/V1/invoices/{id}/emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets invoice capture.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1SetCapturePost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesInvoiceManagementV1SetCapturePost.');
            }
            const localVarPath = `/V1/invoices/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Voids a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1SetVoidPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesInvoiceManagementV1SetVoidPost.');
            }
            const localVarPath = `/V1/invoices/{id}/void`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesInvoiceManagementV1Api - functional programming interface
 * @export
 */
export const SalesInvoiceManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists comments for a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1GetCommentsListGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataInvoiceCommentSearchResultInterface> {
            const localVarFetchArgs = SalesInvoiceManagementV1ApiFetchParamCreator(configuration).salesInvoiceManagementV1GetCommentsListGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Emails a user a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1NotifyPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesInvoiceManagementV1ApiFetchParamCreator(configuration).salesInvoiceManagementV1NotifyPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets invoice capture.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1SetCapturePost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SalesInvoiceManagementV1ApiFetchParamCreator(configuration).salesInvoiceManagementV1SetCapturePost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Voids a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1SetVoidPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesInvoiceManagementV1ApiFetchParamCreator(configuration).salesInvoiceManagementV1SetVoidPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesInvoiceManagementV1Api - factory interface
 * @export
 */
export const SalesInvoiceManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists comments for a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1GetCommentsListGet(id: number, options?: any) {
            return SalesInvoiceManagementV1ApiFp(configuration).salesInvoiceManagementV1GetCommentsListGet(id, options)(fetch, basePath);
        },
        /**
         * Emails a user a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1NotifyPost(id: number, options?: any) {
            return SalesInvoiceManagementV1ApiFp(configuration).salesInvoiceManagementV1NotifyPost(id, options)(fetch, basePath);
        },
        /**
         * Sets invoice capture.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1SetCapturePost(id: number, options?: any) {
            return SalesInvoiceManagementV1ApiFp(configuration).salesInvoiceManagementV1SetCapturePost(id, options)(fetch, basePath);
        },
        /**
         * Voids a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceManagementV1SetVoidPost(id: number, options?: any) {
            return SalesInvoiceManagementV1ApiFp(configuration).salesInvoiceManagementV1SetVoidPost(id, options)(fetch, basePath);
        },
    };
};

/**
 * SalesInvoiceManagementV1Api - object-oriented interface
 * @export
 * @class SalesInvoiceManagementV1Api
 * @extends {BaseAPI}
 */
export class SalesInvoiceManagementV1Api extends BaseAPI {
    /**
     * Lists comments for a specified invoice.
     * @param {number} id The invoice ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceManagementV1Api
     */
    public salesInvoiceManagementV1GetCommentsListGet(id: number, options?: any) {
        return SalesInvoiceManagementV1ApiFp(this.configuration).salesInvoiceManagementV1GetCommentsListGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Emails a user a specified invoice.
     * @param {number} id The invoice ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceManagementV1Api
     */
    public salesInvoiceManagementV1NotifyPost(id: number, options?: any) {
        return SalesInvoiceManagementV1ApiFp(this.configuration).salesInvoiceManagementV1NotifyPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Sets invoice capture.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceManagementV1Api
     */
    public salesInvoiceManagementV1SetCapturePost(id: number, options?: any) {
        return SalesInvoiceManagementV1ApiFp(this.configuration).salesInvoiceManagementV1SetCapturePost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Voids a specified invoice.
     * @param {number} id The invoice ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceManagementV1Api
     */
    public salesInvoiceManagementV1SetVoidPost(id: number, options?: any) {
        return SalesInvoiceManagementV1ApiFp(this.configuration).salesInvoiceManagementV1SetVoidPost(id, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesInvoiceOrderV1Api - fetch parameter creator
 * @export
 */
export const SalesInvoiceOrderV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} orderId
         * @param {SalesInvoiceOrderV1ExecutePostBody} [salesInvoiceOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceOrderV1ExecutePost(orderId: number, salesInvoiceOrderV1ExecutePostBody?: SalesInvoiceOrderV1ExecutePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling salesInvoiceOrderV1ExecutePost.');
            }
            const localVarPath = `/V1/order/{orderId}/invoice`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesInvoiceOrderV1ExecutePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesInvoiceOrderV1ExecutePostBody || {}) : (salesInvoiceOrderV1ExecutePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesInvoiceOrderV1Api - functional programming interface
 * @export
 */
export const SalesInvoiceOrderV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} orderId
         * @param {SalesInvoiceOrderV1ExecutePostBody} [salesInvoiceOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceOrderV1ExecutePost(orderId: number, salesInvoiceOrderV1ExecutePostBody?: SalesInvoiceOrderV1ExecutePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = SalesInvoiceOrderV1ApiFetchParamCreator(configuration).salesInvoiceOrderV1ExecutePost(orderId, salesInvoiceOrderV1ExecutePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesInvoiceOrderV1Api - factory interface
 * @export
 */
export const SalesInvoiceOrderV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {number} orderId
         * @param {SalesInvoiceOrderV1ExecutePostBody} [salesInvoiceOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceOrderV1ExecutePost(orderId: number, salesInvoiceOrderV1ExecutePostBody?: SalesInvoiceOrderV1ExecutePostBody, options?: any) {
            return SalesInvoiceOrderV1ApiFp(configuration).salesInvoiceOrderV1ExecutePost(orderId, salesInvoiceOrderV1ExecutePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesInvoiceOrderV1Api - object-oriented interface
 * @export
 * @class SalesInvoiceOrderV1Api
 * @extends {BaseAPI}
 */
export class SalesInvoiceOrderV1Api extends BaseAPI {
    /**
     *
     * @param {number} orderId
     * @param {SalesInvoiceOrderV1ExecutePostBody} [salesInvoiceOrderV1ExecutePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceOrderV1Api
     */
    public salesInvoiceOrderV1ExecutePost(orderId: number, salesInvoiceOrderV1ExecutePostBody?: SalesInvoiceOrderV1ExecutePostBody, options?: any) {
        return SalesInvoiceOrderV1ApiFp(this.configuration).salesInvoiceOrderV1ExecutePost(orderId, salesInvoiceOrderV1ExecutePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesInvoiceRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesInvoiceRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loads a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesInvoiceRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists invoices that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#InvoiceRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/invoices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs persist operations for a specified invoice.
         * @param {SalesInvoiceRepositoryV1SavePostBody} [salesInvoiceRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody?: SalesInvoiceRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/invoices/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesInvoiceRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesInvoiceRepositoryV1SavePostBody || {}) : (salesInvoiceRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesInvoiceRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesInvoiceRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loads a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataInvoiceInterface> {
            const localVarFetchArgs = SalesInvoiceRepositoryV1ApiFetchParamCreator(configuration).salesInvoiceRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists invoices that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#InvoiceRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataInvoiceSearchResultInterface> {
            const localVarFetchArgs = SalesInvoiceRepositoryV1ApiFetchParamCreator(configuration).salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs persist operations for a specified invoice.
         * @param {SalesInvoiceRepositoryV1SavePostBody} [salesInvoiceRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody?: SalesInvoiceRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataInvoiceInterface> {
            const localVarFetchArgs = SalesInvoiceRepositoryV1ApiFetchParamCreator(configuration).salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesInvoiceRepositoryV1Api - factory interface
 * @export
 */
export const SalesInvoiceRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loads a specified invoice.
         * @param {number} id The invoice ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1GetGet(id: number, options?: any) {
            return SalesInvoiceRepositoryV1ApiFp(configuration).salesInvoiceRepositoryV1GetGet(id, options)(fetch, basePath);
        },
        /**
         * Lists invoices that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#InvoiceRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesInvoiceRepositoryV1ApiFp(configuration).salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Performs persist operations for a specified invoice.
         * @param {SalesInvoiceRepositoryV1SavePostBody} [salesInvoiceRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody?: SalesInvoiceRepositoryV1SavePostBody, options?: any) {
            return SalesInvoiceRepositoryV1ApiFp(configuration).salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesInvoiceRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesInvoiceRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesInvoiceRepositoryV1Api extends BaseAPI {
    /**
     * Loads a specified invoice.
     * @param {number} id The invoice ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceRepositoryV1Api
     */
    public salesInvoiceRepositoryV1GetGet(id: number, options?: any) {
        return SalesInvoiceRepositoryV1ApiFp(this.configuration).salesInvoiceRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists invoices that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#InvoiceRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceRepositoryV1Api
     */
    public salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesInvoiceRepositoryV1ApiFp(this.configuration).salesInvoiceRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Performs persist operations for a specified invoice.
     * @param {SalesInvoiceRepositoryV1SavePostBody} [salesInvoiceRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesInvoiceRepositoryV1Api
     */
    public salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody?: SalesInvoiceRepositoryV1SavePostBody, options?: any) {
        return SalesInvoiceRepositoryV1ApiFp(this.configuration).salesInvoiceRepositoryV1SavePost(salesInvoiceRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesOrderAddressRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesOrderAddressRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified order address.
         * @param {string} parentId
         * @param {SalesOrderAddressRepositoryV1SavePutBody} [salesOrderAddressRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderAddressRepositoryV1SavePut(parentId: string, salesOrderAddressRepositoryV1SavePutBody?: SalesOrderAddressRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'parentId' is not null or undefined
            if (parentId === null || parentId === undefined) {
                throw new RequiredError('parentId','Required parameter parentId was null or undefined when calling salesOrderAddressRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/orders/{parent_id}`
                .replace(`{${"parent_id"}}`, encodeURIComponent(String(parentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesOrderAddressRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesOrderAddressRepositoryV1SavePutBody || {}) : (salesOrderAddressRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesOrderAddressRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesOrderAddressRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified order address.
         * @param {string} parentId
         * @param {SalesOrderAddressRepositoryV1SavePutBody} [salesOrderAddressRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderAddressRepositoryV1SavePut(parentId: string, salesOrderAddressRepositoryV1SavePutBody?: SalesOrderAddressRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderAddressInterface> {
            const localVarFetchArgs = SalesOrderAddressRepositoryV1ApiFetchParamCreator(configuration).salesOrderAddressRepositoryV1SavePut(parentId, salesOrderAddressRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesOrderAddressRepositoryV1Api - factory interface
 * @export
 */
export const SalesOrderAddressRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Performs persist operations for a specified order address.
         * @param {string} parentId
         * @param {SalesOrderAddressRepositoryV1SavePutBody} [salesOrderAddressRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderAddressRepositoryV1SavePut(parentId: string, salesOrderAddressRepositoryV1SavePutBody?: SalesOrderAddressRepositoryV1SavePutBody, options?: any) {
            return SalesOrderAddressRepositoryV1ApiFp(configuration).salesOrderAddressRepositoryV1SavePut(parentId, salesOrderAddressRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesOrderAddressRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesOrderAddressRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesOrderAddressRepositoryV1Api extends BaseAPI {
    /**
     * Performs persist operations for a specified order address.
     * @param {string} parentId
     * @param {SalesOrderAddressRepositoryV1SavePutBody} [salesOrderAddressRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderAddressRepositoryV1Api
     */
    public salesOrderAddressRepositoryV1SavePut(parentId: string, salesOrderAddressRepositoryV1SavePutBody?: SalesOrderAddressRepositoryV1SavePutBody, options?: any) {
        return SalesOrderAddressRepositoryV1ApiFp(this.configuration).salesOrderAddressRepositoryV1SavePut(parentId, salesOrderAddressRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesOrderItemRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesOrderItemRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loads a specified order item.
         * @param {number} id The order item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderItemRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderItemRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/orders/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists order items that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderItemRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/orders/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesOrderItemRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesOrderItemRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loads a specified order item.
         * @param {number} id The order item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderItemRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderItemInterface> {
            const localVarFetchArgs = SalesOrderItemRepositoryV1ApiFetchParamCreator(configuration).salesOrderItemRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists order items that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderItemRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderItemSearchResultInterface> {
            const localVarFetchArgs = SalesOrderItemRepositoryV1ApiFetchParamCreator(configuration).salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesOrderItemRepositoryV1Api - factory interface
 * @export
 */
export const SalesOrderItemRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loads a specified order item.
         * @param {number} id The order item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderItemRepositoryV1GetGet(id: number, options?: any) {
            return SalesOrderItemRepositoryV1ApiFp(configuration).salesOrderItemRepositoryV1GetGet(id, options)(fetch, basePath);
        },
        /**
         * Lists order items that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderItemRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesOrderItemRepositoryV1ApiFp(configuration).salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * SalesOrderItemRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesOrderItemRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesOrderItemRepositoryV1Api extends BaseAPI {
    /**
     * Loads a specified order item.
     * @param {number} id The order item ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderItemRepositoryV1Api
     */
    public salesOrderItemRepositoryV1GetGet(id: number, options?: any) {
        return SalesOrderItemRepositoryV1ApiFp(this.configuration).salesOrderItemRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists order items that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderItemRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderItemRepositoryV1Api
     */
    public salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesOrderItemRepositoryV1ApiFp(this.configuration).salesOrderItemRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesOrderManagementV1Api - fetch parameter creator
 * @export
 */
export const SalesOrderManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a comment to a specified order.
         * @param {number} id The order ID.
         * @param {SalesOrderManagementV1AddCommentPostBody} [salesOrderManagementV1AddCommentPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1AddCommentPost(id: number, salesOrderManagementV1AddCommentPostBody?: SalesOrderManagementV1AddCommentPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1AddCommentPost.');
            }
            const localVarPath = `/V1/orders/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesOrderManagementV1AddCommentPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesOrderManagementV1AddCommentPostBody || {}) : (salesOrderManagementV1AddCommentPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1CancelPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1CancelPost.');
            }
            const localVarPath = `/V1/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists comments for a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1GetCommentsListGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1GetCommentsListGet.');
            }
            const localVarPath = `/V1/orders/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the status for a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1GetStatusGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1GetStatusGet.');
            }
            const localVarPath = `/V1/orders/{id}/statuses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Holds a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1HoldPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1HoldPost.');
            }
            const localVarPath = `/V1/orders/{id}/hold`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Emails a user a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1NotifyPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1NotifyPost.');
            }
            const localVarPath = `/V1/orders/{id}/emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Releases a specified order from hold status.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1UnHoldPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderManagementV1UnHoldPost.');
            }
            const localVarPath = `/V1/orders/{id}/unhold`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesOrderManagementV1Api - functional programming interface
 * @export
 */
export const SalesOrderManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a comment to a specified order.
         * @param {number} id The order ID.
         * @param {SalesOrderManagementV1AddCommentPostBody} [salesOrderManagementV1AddCommentPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1AddCommentPost(id: number, salesOrderManagementV1AddCommentPostBody?: SalesOrderManagementV1AddCommentPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1AddCommentPost(id, salesOrderManagementV1AddCommentPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancels a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1CancelPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1CancelPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists comments for a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1GetCommentsListGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderStatusHistorySearchResultInterface> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1GetCommentsListGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the status for a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1GetStatusGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1GetStatusGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Holds a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1HoldPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1HoldPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Emails a user a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1NotifyPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1NotifyPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Releases a specified order from hold status.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1UnHoldPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesOrderManagementV1ApiFetchParamCreator(configuration).salesOrderManagementV1UnHoldPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesOrderManagementV1Api - factory interface
 * @export
 */
export const SalesOrderManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a comment to a specified order.
         * @param {number} id The order ID.
         * @param {SalesOrderManagementV1AddCommentPostBody} [salesOrderManagementV1AddCommentPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1AddCommentPost(id: number, salesOrderManagementV1AddCommentPostBody?: SalesOrderManagementV1AddCommentPostBody, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1AddCommentPost(id, salesOrderManagementV1AddCommentPostBody, options)(fetch, basePath);
        },
        /**
         * Cancels a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1CancelPost(id: number, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1CancelPost(id, options)(fetch, basePath);
        },
        /**
         * Lists comments for a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1GetCommentsListGet(id: number, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1GetCommentsListGet(id, options)(fetch, basePath);
        },
        /**
         * Gets the status for a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1GetStatusGet(id: number, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1GetStatusGet(id, options)(fetch, basePath);
        },
        /**
         * Holds a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1HoldPost(id: number, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1HoldPost(id, options)(fetch, basePath);
        },
        /**
         * Emails a user a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1NotifyPost(id: number, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1NotifyPost(id, options)(fetch, basePath);
        },
        /**
         * Releases a specified order from hold status.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderManagementV1UnHoldPost(id: number, options?: any) {
            return SalesOrderManagementV1ApiFp(configuration).salesOrderManagementV1UnHoldPost(id, options)(fetch, basePath);
        },
    };
};

/**
 * SalesOrderManagementV1Api - object-oriented interface
 * @export
 * @class SalesOrderManagementV1Api
 * @extends {BaseAPI}
 */
export class SalesOrderManagementV1Api extends BaseAPI {
    /**
     * Adds a comment to a specified order.
     * @param {number} id The order ID.
     * @param {SalesOrderManagementV1AddCommentPostBody} [salesOrderManagementV1AddCommentPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1AddCommentPost(id: number, salesOrderManagementV1AddCommentPostBody?: SalesOrderManagementV1AddCommentPostBody, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1AddCommentPost(id, salesOrderManagementV1AddCommentPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Cancels a specified order.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1CancelPost(id: number, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1CancelPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists comments for a specified order.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1GetCommentsListGet(id: number, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1GetCommentsListGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the status for a specified order.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1GetStatusGet(id: number, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1GetStatusGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Holds a specified order.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1HoldPost(id: number, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1HoldPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Emails a user a specified order.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1NotifyPost(id: number, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1NotifyPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Releases a specified order from hold status.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderManagementV1Api
     */
    public salesOrderManagementV1UnHoldPost(id: number, options?: any) {
        return SalesOrderManagementV1ApiFp(this.configuration).salesOrderManagementV1UnHoldPost(id, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesOrderRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesOrderRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loads a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesOrderRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists orders that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs persist operations for a specified order.
         * @param {SalesOrderRepositoryV1SavePostBody} [salesOrderRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody?: SalesOrderRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/orders/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesOrderRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesOrderRepositoryV1SavePostBody || {}) : (salesOrderRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs persist operations for a specified order.
         * @param {SalesOrderRepositoryV1SavePutBody} [salesOrderRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody?: SalesOrderRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/orders/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesOrderRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesOrderRepositoryV1SavePutBody || {}) : (salesOrderRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesOrderRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesOrderRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loads a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderInterface> {
            const localVarFetchArgs = SalesOrderRepositoryV1ApiFetchParamCreator(configuration).salesOrderRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists orders that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderSearchResultInterface> {
            const localVarFetchArgs = SalesOrderRepositoryV1ApiFetchParamCreator(configuration).salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs persist operations for a specified order.
         * @param {SalesOrderRepositoryV1SavePostBody} [salesOrderRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody?: SalesOrderRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderInterface> {
            const localVarFetchArgs = SalesOrderRepositoryV1ApiFetchParamCreator(configuration).salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs persist operations for a specified order.
         * @param {SalesOrderRepositoryV1SavePutBody} [salesOrderRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody?: SalesOrderRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataOrderInterface> {
            const localVarFetchArgs = SalesOrderRepositoryV1ApiFetchParamCreator(configuration).salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesOrderRepositoryV1Api - factory interface
 * @export
 */
export const SalesOrderRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loads a specified order.
         * @param {number} id The order ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1GetGet(id: number, options?: any) {
            return SalesOrderRepositoryV1ApiFp(configuration).salesOrderRepositoryV1GetGet(id, options)(fetch, basePath);
        },
        /**
         * Lists orders that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesOrderRepositoryV1ApiFp(configuration).salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Performs persist operations for a specified order.
         * @param {SalesOrderRepositoryV1SavePostBody} [salesOrderRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody?: SalesOrderRepositoryV1SavePostBody, options?: any) {
            return SalesOrderRepositoryV1ApiFp(configuration).salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Performs persist operations for a specified order.
         * @param {SalesOrderRepositoryV1SavePutBody} [salesOrderRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody?: SalesOrderRepositoryV1SavePutBody, options?: any) {
            return SalesOrderRepositoryV1ApiFp(configuration).salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesOrderRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesOrderRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesOrderRepositoryV1Api extends BaseAPI {
    /**
     * Loads a specified order.
     * @param {number} id The order ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderRepositoryV1Api
     */
    public salesOrderRepositoryV1GetGet(id: number, options?: any) {
        return SalesOrderRepositoryV1ApiFp(this.configuration).salesOrderRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists orders that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#OrderRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderRepositoryV1Api
     */
    public salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesOrderRepositoryV1ApiFp(this.configuration).salesOrderRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Performs persist operations for a specified order.
     * @param {SalesOrderRepositoryV1SavePostBody} [salesOrderRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderRepositoryV1Api
     */
    public salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody?: SalesOrderRepositoryV1SavePostBody, options?: any) {
        return SalesOrderRepositoryV1ApiFp(this.configuration).salesOrderRepositoryV1SavePost(salesOrderRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Performs persist operations for a specified order.
     * @param {SalesOrderRepositoryV1SavePutBody} [salesOrderRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesOrderRepositoryV1Api
     */
    public salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody?: SalesOrderRepositoryV1SavePutBody, options?: any) {
        return SalesOrderRepositoryV1ApiFp(this.configuration).salesOrderRepositoryV1SavePut(salesOrderRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesRefundInvoiceV1Api - fetch parameter creator
 * @export
 */
export const SalesRefundInvoiceV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create refund for invoice
         * @param {number} invoiceId
         * @param {SalesRefundInvoiceV1ExecutePostBody} [salesRefundInvoiceV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRefundInvoiceV1ExecutePost(invoiceId: number, salesRefundInvoiceV1ExecutePostBody?: SalesRefundInvoiceV1ExecutePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling salesRefundInvoiceV1ExecutePost.');
            }
            const localVarPath = `/V1/invoice/{invoiceId}/refund`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRefundInvoiceV1ExecutePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRefundInvoiceV1ExecutePostBody || {}) : (salesRefundInvoiceV1ExecutePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesRefundInvoiceV1Api - functional programming interface
 * @export
 */
export const SalesRefundInvoiceV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create refund for invoice
         * @param {number} invoiceId
         * @param {SalesRefundInvoiceV1ExecutePostBody} [salesRefundInvoiceV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRefundInvoiceV1ExecutePost(invoiceId: number, salesRefundInvoiceV1ExecutePostBody?: SalesRefundInvoiceV1ExecutePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = SalesRefundInvoiceV1ApiFetchParamCreator(configuration).salesRefundInvoiceV1ExecutePost(invoiceId, salesRefundInvoiceV1ExecutePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesRefundInvoiceV1Api - factory interface
 * @export
 */
export const SalesRefundInvoiceV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create refund for invoice
         * @param {number} invoiceId
         * @param {SalesRefundInvoiceV1ExecutePostBody} [salesRefundInvoiceV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRefundInvoiceV1ExecutePost(invoiceId: number, salesRefundInvoiceV1ExecutePostBody?: SalesRefundInvoiceV1ExecutePostBody, options?: any) {
            return SalesRefundInvoiceV1ApiFp(configuration).salesRefundInvoiceV1ExecutePost(invoiceId, salesRefundInvoiceV1ExecutePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesRefundInvoiceV1Api - object-oriented interface
 * @export
 * @class SalesRefundInvoiceV1Api
 * @extends {BaseAPI}
 */
export class SalesRefundInvoiceV1Api extends BaseAPI {
    /**
     * Create refund for invoice
     * @param {number} invoiceId
     * @param {SalesRefundInvoiceV1ExecutePostBody} [salesRefundInvoiceV1ExecutePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRefundInvoiceV1Api
     */
    public salesRefundInvoiceV1ExecutePost(invoiceId: number, salesRefundInvoiceV1ExecutePostBody?: SalesRefundInvoiceV1ExecutePostBody, options?: any) {
        return SalesRefundInvoiceV1ApiFp(this.configuration).salesRefundInvoiceV1ExecutePost(invoiceId, salesRefundInvoiceV1ExecutePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesRefundOrderV1Api - fetch parameter creator
 * @export
 */
export const SalesRefundOrderV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create offline refund for order
         * @param {number} orderId
         * @param {SalesRefundOrderV1ExecutePostBody} [salesRefundOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRefundOrderV1ExecutePost(orderId: number, salesRefundOrderV1ExecutePostBody?: SalesRefundOrderV1ExecutePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling salesRefundOrderV1ExecutePost.');
            }
            const localVarPath = `/V1/order/{orderId}/refund`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRefundOrderV1ExecutePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRefundOrderV1ExecutePostBody || {}) : (salesRefundOrderV1ExecutePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesRefundOrderV1Api - functional programming interface
 * @export
 */
export const SalesRefundOrderV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create offline refund for order
         * @param {number} orderId
         * @param {SalesRefundOrderV1ExecutePostBody} [salesRefundOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRefundOrderV1ExecutePost(orderId: number, salesRefundOrderV1ExecutePostBody?: SalesRefundOrderV1ExecutePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = SalesRefundOrderV1ApiFetchParamCreator(configuration).salesRefundOrderV1ExecutePost(orderId, salesRefundOrderV1ExecutePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesRefundOrderV1Api - factory interface
 * @export
 */
export const SalesRefundOrderV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create offline refund for order
         * @param {number} orderId
         * @param {SalesRefundOrderV1ExecutePostBody} [salesRefundOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRefundOrderV1ExecutePost(orderId: number, salesRefundOrderV1ExecutePostBody?: SalesRefundOrderV1ExecutePostBody, options?: any) {
            return SalesRefundOrderV1ApiFp(configuration).salesRefundOrderV1ExecutePost(orderId, salesRefundOrderV1ExecutePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesRefundOrderV1Api - object-oriented interface
 * @export
 * @class SalesRefundOrderV1Api
 * @extends {BaseAPI}
 */
export class SalesRefundOrderV1Api extends BaseAPI {
    /**
     * Create offline refund for order
     * @param {number} orderId
     * @param {SalesRefundOrderV1ExecutePostBody} [salesRefundOrderV1ExecutePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRefundOrderV1Api
     */
    public salesRefundOrderV1ExecutePost(orderId: number, salesRefundOrderV1ExecutePostBody?: SalesRefundOrderV1ExecutePostBody, options?: any) {
        return SalesRefundOrderV1ApiFp(this.configuration).salesRefundOrderV1ExecutePost(orderId, salesRefundOrderV1ExecutePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesRuleCouponManagementV1Api - fetch parameter creator
 * @export
 */
export const SalesRuleCouponManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete coupon by coupon codes.
         * @param {SalesRuleCouponManagementV1DeleteByCodesPostBody} [salesRuleCouponManagementV1DeleteByCodesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody?: SalesRuleCouponManagementV1DeleteByCodesPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/coupons/deleteByCodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleCouponManagementV1DeleteByCodesPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleCouponManagementV1DeleteByCodesPostBody || {}) : (salesRuleCouponManagementV1DeleteByCodesPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete coupon by coupon ids.
         * @param {SalesRuleCouponManagementV1DeleteByIdsPostBody} [salesRuleCouponManagementV1DeleteByIdsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody?: SalesRuleCouponManagementV1DeleteByIdsPostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/coupons/deleteByIds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleCouponManagementV1DeleteByIdsPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleCouponManagementV1DeleteByIdsPostBody || {}) : (salesRuleCouponManagementV1DeleteByIdsPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate coupon for a rule
         * @param {SalesRuleCouponManagementV1GeneratePostBody} [salesRuleCouponManagementV1GeneratePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody?: SalesRuleCouponManagementV1GeneratePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/coupons/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleCouponManagementV1GeneratePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleCouponManagementV1GeneratePostBody || {}) : (salesRuleCouponManagementV1GeneratePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesRuleCouponManagementV1Api - functional programming interface
 * @export
 */
export const SalesRuleCouponManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete coupon by coupon codes.
         * @param {SalesRuleCouponManagementV1DeleteByCodesPostBody} [salesRuleCouponManagementV1DeleteByCodesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody?: SalesRuleCouponManagementV1DeleteByCodesPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataCouponMassDeleteResultInterface> {
            const localVarFetchArgs = SalesRuleCouponManagementV1ApiFetchParamCreator(configuration).salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete coupon by coupon ids.
         * @param {SalesRuleCouponManagementV1DeleteByIdsPostBody} [salesRuleCouponManagementV1DeleteByIdsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody?: SalesRuleCouponManagementV1DeleteByIdsPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataCouponMassDeleteResultInterface> {
            const localVarFetchArgs = SalesRuleCouponManagementV1ApiFetchParamCreator(configuration).salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate coupon for a rule
         * @param {SalesRuleCouponManagementV1GeneratePostBody} [salesRuleCouponManagementV1GeneratePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody?: SalesRuleCouponManagementV1GeneratePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SalesRuleCouponManagementV1ApiFetchParamCreator(configuration).salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesRuleCouponManagementV1Api - factory interface
 * @export
 */
export const SalesRuleCouponManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete coupon by coupon codes.
         * @param {SalesRuleCouponManagementV1DeleteByCodesPostBody} [salesRuleCouponManagementV1DeleteByCodesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody?: SalesRuleCouponManagementV1DeleteByCodesPostBody, options?: any) {
            return SalesRuleCouponManagementV1ApiFp(configuration).salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody, options)(fetch, basePath);
        },
        /**
         * Delete coupon by coupon ids.
         * @param {SalesRuleCouponManagementV1DeleteByIdsPostBody} [salesRuleCouponManagementV1DeleteByIdsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody?: SalesRuleCouponManagementV1DeleteByIdsPostBody, options?: any) {
            return SalesRuleCouponManagementV1ApiFp(configuration).salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody, options)(fetch, basePath);
        },
        /**
         * Generate coupon for a rule
         * @param {SalesRuleCouponManagementV1GeneratePostBody} [salesRuleCouponManagementV1GeneratePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody?: SalesRuleCouponManagementV1GeneratePostBody, options?: any) {
            return SalesRuleCouponManagementV1ApiFp(configuration).salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesRuleCouponManagementV1Api - object-oriented interface
 * @export
 * @class SalesRuleCouponManagementV1Api
 * @extends {BaseAPI}
 */
export class SalesRuleCouponManagementV1Api extends BaseAPI {
    /**
     * Delete coupon by coupon codes.
     * @param {SalesRuleCouponManagementV1DeleteByCodesPostBody} [salesRuleCouponManagementV1DeleteByCodesPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponManagementV1Api
     */
    public salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody?: SalesRuleCouponManagementV1DeleteByCodesPostBody, options?: any) {
        return SalesRuleCouponManagementV1ApiFp(this.configuration).salesRuleCouponManagementV1DeleteByCodesPost(salesRuleCouponManagementV1DeleteByCodesPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Delete coupon by coupon ids.
     * @param {SalesRuleCouponManagementV1DeleteByIdsPostBody} [salesRuleCouponManagementV1DeleteByIdsPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponManagementV1Api
     */
    public salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody?: SalesRuleCouponManagementV1DeleteByIdsPostBody, options?: any) {
        return SalesRuleCouponManagementV1ApiFp(this.configuration).salesRuleCouponManagementV1DeleteByIdsPost(salesRuleCouponManagementV1DeleteByIdsPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Generate coupon for a rule
     * @param {SalesRuleCouponManagementV1GeneratePostBody} [salesRuleCouponManagementV1GeneratePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponManagementV1Api
     */
    public salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody?: SalesRuleCouponManagementV1GeneratePostBody, options?: any) {
        return SalesRuleCouponManagementV1ApiFp(this.configuration).salesRuleCouponManagementV1GeneratePost(salesRuleCouponManagementV1GeneratePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesRuleCouponRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesRuleCouponRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete coupon by coupon id.
         * @param {number} couponId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1DeleteByIdDelete(couponId: number, options: any = {}): FetchArgs {
            // verify required parameter 'couponId' is not null or undefined
            if (couponId === null || couponId === undefined) {
                throw new RequiredError('couponId','Required parameter couponId was null or undefined when calling salesRuleCouponRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/coupons/{couponId}`
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get coupon by coupon id.
         * @param {number} couponId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1GetByIdGet(couponId: number, options: any = {}): FetchArgs {
            // verify required parameter 'couponId' is not null or undefined
            if (couponId === null || couponId === undefined) {
                throw new RequiredError('couponId','Required parameter couponId was null or undefined when calling salesRuleCouponRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/coupons/{couponId}`
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a coupon using the specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CouponRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/coupons/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save a coupon.
         * @param {SalesRuleCouponRepositoryV1SavePostBody} [salesRuleCouponRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody?: SalesRuleCouponRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleCouponRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleCouponRepositoryV1SavePostBody || {}) : (salesRuleCouponRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save a coupon.
         * @param {string} couponId
         * @param {SalesRuleCouponRepositoryV1SavePutBody} [salesRuleCouponRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1SavePut(couponId: string, salesRuleCouponRepositoryV1SavePutBody?: SalesRuleCouponRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'couponId' is not null or undefined
            if (couponId === null || couponId === undefined) {
                throw new RequiredError('couponId','Required parameter couponId was null or undefined when calling salesRuleCouponRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/coupons/{couponId}`
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleCouponRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleCouponRepositoryV1SavePutBody || {}) : (salesRuleCouponRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesRuleCouponRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesRuleCouponRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete coupon by coupon id.
         * @param {number} couponId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1DeleteByIdDelete(couponId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesRuleCouponRepositoryV1ApiFetchParamCreator(configuration).salesRuleCouponRepositoryV1DeleteByIdDelete(couponId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get coupon by coupon id.
         * @param {number} couponId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1GetByIdGet(couponId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataCouponInterface> {
            const localVarFetchArgs = SalesRuleCouponRepositoryV1ApiFetchParamCreator(configuration).salesRuleCouponRepositoryV1GetByIdGet(couponId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a coupon using the specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CouponRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataCouponSearchResultInterface> {
            const localVarFetchArgs = SalesRuleCouponRepositoryV1ApiFetchParamCreator(configuration).salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save a coupon.
         * @param {SalesRuleCouponRepositoryV1SavePostBody} [salesRuleCouponRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody?: SalesRuleCouponRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataCouponInterface> {
            const localVarFetchArgs = SalesRuleCouponRepositoryV1ApiFetchParamCreator(configuration).salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save a coupon.
         * @param {string} couponId
         * @param {SalesRuleCouponRepositoryV1SavePutBody} [salesRuleCouponRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1SavePut(couponId: string, salesRuleCouponRepositoryV1SavePutBody?: SalesRuleCouponRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataCouponInterface> {
            const localVarFetchArgs = SalesRuleCouponRepositoryV1ApiFetchParamCreator(configuration).salesRuleCouponRepositoryV1SavePut(couponId, salesRuleCouponRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesRuleCouponRepositoryV1Api - factory interface
 * @export
 */
export const SalesRuleCouponRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete coupon by coupon id.
         * @param {number} couponId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1DeleteByIdDelete(couponId: number, options?: any) {
            return SalesRuleCouponRepositoryV1ApiFp(configuration).salesRuleCouponRepositoryV1DeleteByIdDelete(couponId, options)(fetch, basePath);
        },
        /**
         * Get coupon by coupon id.
         * @param {number} couponId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1GetByIdGet(couponId: number, options?: any) {
            return SalesRuleCouponRepositoryV1ApiFp(configuration).salesRuleCouponRepositoryV1GetByIdGet(couponId, options)(fetch, basePath);
        },
        /**
         * Retrieve a coupon using the specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CouponRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesRuleCouponRepositoryV1ApiFp(configuration).salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save a coupon.
         * @param {SalesRuleCouponRepositoryV1SavePostBody} [salesRuleCouponRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody?: SalesRuleCouponRepositoryV1SavePostBody, options?: any) {
            return SalesRuleCouponRepositoryV1ApiFp(configuration).salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save a coupon.
         * @param {string} couponId
         * @param {SalesRuleCouponRepositoryV1SavePutBody} [salesRuleCouponRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleCouponRepositoryV1SavePut(couponId: string, salesRuleCouponRepositoryV1SavePutBody?: SalesRuleCouponRepositoryV1SavePutBody, options?: any) {
            return SalesRuleCouponRepositoryV1ApiFp(configuration).salesRuleCouponRepositoryV1SavePut(couponId, salesRuleCouponRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesRuleCouponRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesRuleCouponRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesRuleCouponRepositoryV1Api extends BaseAPI {
    /**
     * Delete coupon by coupon id.
     * @param {number} couponId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponRepositoryV1Api
     */
    public salesRuleCouponRepositoryV1DeleteByIdDelete(couponId: number, options?: any) {
        return SalesRuleCouponRepositoryV1ApiFp(this.configuration).salesRuleCouponRepositoryV1DeleteByIdDelete(couponId, options)(this.fetch, this.basePath);
    }

    /**
     * Get coupon by coupon id.
     * @param {number} couponId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponRepositoryV1Api
     */
    public salesRuleCouponRepositoryV1GetByIdGet(couponId: number, options?: any) {
        return SalesRuleCouponRepositoryV1ApiFp(this.configuration).salesRuleCouponRepositoryV1GetByIdGet(couponId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a coupon using the specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#CouponRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponRepositoryV1Api
     */
    public salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesRuleCouponRepositoryV1ApiFp(this.configuration).salesRuleCouponRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save a coupon.
     * @param {SalesRuleCouponRepositoryV1SavePostBody} [salesRuleCouponRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponRepositoryV1Api
     */
    public salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody?: SalesRuleCouponRepositoryV1SavePostBody, options?: any) {
        return SalesRuleCouponRepositoryV1ApiFp(this.configuration).salesRuleCouponRepositoryV1SavePost(salesRuleCouponRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save a coupon.
     * @param {string} couponId
     * @param {SalesRuleCouponRepositoryV1SavePutBody} [salesRuleCouponRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleCouponRepositoryV1Api
     */
    public salesRuleCouponRepositoryV1SavePut(couponId: string, salesRuleCouponRepositoryV1SavePutBody?: SalesRuleCouponRepositoryV1SavePutBody, options?: any) {
        return SalesRuleCouponRepositoryV1ApiFp(this.configuration).salesRuleCouponRepositoryV1SavePut(couponId, salesRuleCouponRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesRuleRuleRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesRuleRuleRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete rule by ID.
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling salesRuleRuleRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/salesRules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get rule by ID.
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1GetByIdGet(ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling salesRuleRuleRepositoryV1GetByIdGet.');
            }
            const localVarPath = `/V1/salesRules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve sales rules that match te specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#RuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/salesRules/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save sales rule.
         * @param {SalesRuleRuleRepositoryV1SavePostBody} [salesRuleRuleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody?: SalesRuleRuleRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/salesRules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleRuleRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleRuleRepositoryV1SavePostBody || {}) : (salesRuleRuleRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save sales rule.
         * @param {string} ruleId
         * @param {SalesRuleRuleRepositoryV1SavePutBody} [salesRuleRuleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1SavePut(ruleId: string, salesRuleRuleRepositoryV1SavePutBody?: SalesRuleRuleRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling salesRuleRuleRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/salesRules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesRuleRuleRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesRuleRuleRepositoryV1SavePutBody || {}) : (salesRuleRuleRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesRuleRuleRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesRuleRuleRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete rule by ID.
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesRuleRuleRepositoryV1ApiFetchParamCreator(configuration).salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get rule by ID.
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1GetByIdGet(ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataRuleInterface> {
            const localVarFetchArgs = SalesRuleRuleRepositoryV1ApiFetchParamCreator(configuration).salesRuleRuleRepositoryV1GetByIdGet(ruleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve sales rules that match te specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#RuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataRuleSearchResultInterface> {
            const localVarFetchArgs = SalesRuleRuleRepositoryV1ApiFetchParamCreator(configuration).salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save sales rule.
         * @param {SalesRuleRuleRepositoryV1SavePostBody} [salesRuleRuleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody?: SalesRuleRuleRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataRuleInterface> {
            const localVarFetchArgs = SalesRuleRuleRepositoryV1ApiFetchParamCreator(configuration).salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save sales rule.
         * @param {string} ruleId
         * @param {SalesRuleRuleRepositoryV1SavePutBody} [salesRuleRuleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1SavePut(ruleId: string, salesRuleRuleRepositoryV1SavePutBody?: SalesRuleRuleRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesRuleDataRuleInterface> {
            const localVarFetchArgs = SalesRuleRuleRepositoryV1ApiFetchParamCreator(configuration).salesRuleRuleRepositoryV1SavePut(ruleId, salesRuleRuleRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesRuleRuleRepositoryV1Api - factory interface
 * @export
 */
export const SalesRuleRuleRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete rule by ID.
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId: number, options?: any) {
            return SalesRuleRuleRepositoryV1ApiFp(configuration).salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId, options)(fetch, basePath);
        },
        /**
         * Get rule by ID.
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1GetByIdGet(ruleId: number, options?: any) {
            return SalesRuleRuleRepositoryV1ApiFp(configuration).salesRuleRuleRepositoryV1GetByIdGet(ruleId, options)(fetch, basePath);
        },
        /**
         * Retrieve sales rules that match te specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#RuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesRuleRuleRepositoryV1ApiFp(configuration).salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save sales rule.
         * @param {SalesRuleRuleRepositoryV1SavePostBody} [salesRuleRuleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody?: SalesRuleRuleRepositoryV1SavePostBody, options?: any) {
            return SalesRuleRuleRepositoryV1ApiFp(configuration).salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save sales rule.
         * @param {string} ruleId
         * @param {SalesRuleRuleRepositoryV1SavePutBody} [salesRuleRuleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesRuleRuleRepositoryV1SavePut(ruleId: string, salesRuleRuleRepositoryV1SavePutBody?: SalesRuleRuleRepositoryV1SavePutBody, options?: any) {
            return SalesRuleRuleRepositoryV1ApiFp(configuration).salesRuleRuleRepositoryV1SavePut(ruleId, salesRuleRuleRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesRuleRuleRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesRuleRuleRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesRuleRuleRepositoryV1Api extends BaseAPI {
    /**
     * Delete rule by ID.
     * @param {number} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleRuleRepositoryV1Api
     */
    public salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId: number, options?: any) {
        return SalesRuleRuleRepositoryV1ApiFp(this.configuration).salesRuleRuleRepositoryV1DeleteByIdDelete(ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * Get rule by ID.
     * @param {number} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleRuleRepositoryV1Api
     */
    public salesRuleRuleRepositoryV1GetByIdGet(ruleId: number, options?: any) {
        return SalesRuleRuleRepositoryV1ApiFp(this.configuration).salesRuleRuleRepositoryV1GetByIdGet(ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve sales rules that match te specified criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#RuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleRuleRepositoryV1Api
     */
    public salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesRuleRuleRepositoryV1ApiFp(this.configuration).salesRuleRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save sales rule.
     * @param {SalesRuleRuleRepositoryV1SavePostBody} [salesRuleRuleRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleRuleRepositoryV1Api
     */
    public salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody?: SalesRuleRuleRepositoryV1SavePostBody, options?: any) {
        return SalesRuleRuleRepositoryV1ApiFp(this.configuration).salesRuleRuleRepositoryV1SavePost(salesRuleRuleRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save sales rule.
     * @param {string} ruleId
     * @param {SalesRuleRuleRepositoryV1SavePutBody} [salesRuleRuleRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesRuleRuleRepositoryV1Api
     */
    public salesRuleRuleRepositoryV1SavePut(ruleId: string, salesRuleRuleRepositoryV1SavePutBody?: SalesRuleRuleRepositoryV1SavePutBody, options?: any) {
        return SalesRuleRuleRepositoryV1ApiFp(this.configuration).salesRuleRuleRepositoryV1SavePut(ruleId, salesRuleRuleRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesShipOrderV1Api - fetch parameter creator
 * @export
 */
export const SalesShipOrderV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new Shipment for given Order.
         * @param {number} orderId
         * @param {SalesShipOrderV1ExecutePostBody} [salesShipOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipOrderV1ExecutePost(orderId: number, salesShipOrderV1ExecutePostBody?: SalesShipOrderV1ExecutePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling salesShipOrderV1ExecutePost.');
            }
            const localVarPath = `/V1/order/{orderId}/ship`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesShipOrderV1ExecutePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesShipOrderV1ExecutePostBody || {}) : (salesShipOrderV1ExecutePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesShipOrderV1Api - functional programming interface
 * @export
 */
export const SalesShipOrderV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new Shipment for given Order.
         * @param {number} orderId
         * @param {SalesShipOrderV1ExecutePostBody} [salesShipOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipOrderV1ExecutePost(orderId: number, salesShipOrderV1ExecutePostBody?: SalesShipOrderV1ExecutePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = SalesShipOrderV1ApiFetchParamCreator(configuration).salesShipOrderV1ExecutePost(orderId, salesShipOrderV1ExecutePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesShipOrderV1Api - factory interface
 * @export
 */
export const SalesShipOrderV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates new Shipment for given Order.
         * @param {number} orderId
         * @param {SalesShipOrderV1ExecutePostBody} [salesShipOrderV1ExecutePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipOrderV1ExecutePost(orderId: number, salesShipOrderV1ExecutePostBody?: SalesShipOrderV1ExecutePostBody, options?: any) {
            return SalesShipOrderV1ApiFp(configuration).salesShipOrderV1ExecutePost(orderId, salesShipOrderV1ExecutePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesShipOrderV1Api - object-oriented interface
 * @export
 * @class SalesShipOrderV1Api
 * @extends {BaseAPI}
 */
export class SalesShipOrderV1Api extends BaseAPI {
    /**
     * Creates new Shipment for given Order.
     * @param {number} orderId
     * @param {SalesShipOrderV1ExecutePostBody} [salesShipOrderV1ExecutePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipOrderV1Api
     */
    public salesShipOrderV1ExecutePost(orderId: number, salesShipOrderV1ExecutePostBody?: SalesShipOrderV1ExecutePostBody, options?: any) {
        return SalesShipOrderV1ApiFp(this.configuration).salesShipOrderV1ExecutePost(orderId, salesShipOrderV1ExecutePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesShipmentCommentRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesShipmentCommentRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified shipment comment.
         * @param {string} id
         * @param {SalesShipmentCommentRepositoryV1SavePostBody} [salesShipmentCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentCommentRepositoryV1SavePost(id: string, salesShipmentCommentRepositoryV1SavePostBody?: SalesShipmentCommentRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesShipmentCommentRepositoryV1SavePost.');
            }
            const localVarPath = `/V1/shipment/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesShipmentCommentRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesShipmentCommentRepositoryV1SavePostBody || {}) : (salesShipmentCommentRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesShipmentCommentRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesShipmentCommentRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs persist operations for a specified shipment comment.
         * @param {string} id
         * @param {SalesShipmentCommentRepositoryV1SavePostBody} [salesShipmentCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentCommentRepositoryV1SavePost(id: string, salesShipmentCommentRepositoryV1SavePostBody?: SalesShipmentCommentRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataShipmentCommentInterface> {
            const localVarFetchArgs = SalesShipmentCommentRepositoryV1ApiFetchParamCreator(configuration).salesShipmentCommentRepositoryV1SavePost(id, salesShipmentCommentRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesShipmentCommentRepositoryV1Api - factory interface
 * @export
 */
export const SalesShipmentCommentRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Performs persist operations for a specified shipment comment.
         * @param {string} id
         * @param {SalesShipmentCommentRepositoryV1SavePostBody} [salesShipmentCommentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentCommentRepositoryV1SavePost(id: string, salesShipmentCommentRepositoryV1SavePostBody?: SalesShipmentCommentRepositoryV1SavePostBody, options?: any) {
            return SalesShipmentCommentRepositoryV1ApiFp(configuration).salesShipmentCommentRepositoryV1SavePost(id, salesShipmentCommentRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesShipmentCommentRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesShipmentCommentRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesShipmentCommentRepositoryV1Api extends BaseAPI {
    /**
     * Performs persist operations for a specified shipment comment.
     * @param {string} id
     * @param {SalesShipmentCommentRepositoryV1SavePostBody} [salesShipmentCommentRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentCommentRepositoryV1Api
     */
    public salesShipmentCommentRepositoryV1SavePost(id: string, salesShipmentCommentRepositoryV1SavePostBody?: SalesShipmentCommentRepositoryV1SavePostBody, options?: any) {
        return SalesShipmentCommentRepositoryV1ApiFp(this.configuration).salesShipmentCommentRepositoryV1SavePost(id, salesShipmentCommentRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesShipmentManagementV1Api - fetch parameter creator
 * @export
 */
export const SalesShipmentManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists comments for a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1GetCommentsListGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesShipmentManagementV1GetCommentsListGet.');
            }
            const localVarPath = `/V1/shipment/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specified shipment label.
         * @param {number} id The shipment label ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1GetLabelGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesShipmentManagementV1GetLabelGet.');
            }
            const localVarPath = `/V1/shipment/{id}/label`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Emails user a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1NotifyPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesShipmentManagementV1NotifyPost.');
            }
            const localVarPath = `/V1/shipment/{id}/emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesShipmentManagementV1Api - functional programming interface
 * @export
 */
export const SalesShipmentManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists comments for a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1GetCommentsListGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataShipmentCommentSearchResultInterface> {
            const localVarFetchArgs = SalesShipmentManagementV1ApiFetchParamCreator(configuration).salesShipmentManagementV1GetCommentsListGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a specified shipment label.
         * @param {number} id The shipment label ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1GetLabelGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SalesShipmentManagementV1ApiFetchParamCreator(configuration).salesShipmentManagementV1GetLabelGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Emails user a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1NotifyPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesShipmentManagementV1ApiFetchParamCreator(configuration).salesShipmentManagementV1NotifyPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesShipmentManagementV1Api - factory interface
 * @export
 */
export const SalesShipmentManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists comments for a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1GetCommentsListGet(id: number, options?: any) {
            return SalesShipmentManagementV1ApiFp(configuration).salesShipmentManagementV1GetCommentsListGet(id, options)(fetch, basePath);
        },
        /**
         * Gets a specified shipment label.
         * @param {number} id The shipment label ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1GetLabelGet(id: number, options?: any) {
            return SalesShipmentManagementV1ApiFp(configuration).salesShipmentManagementV1GetLabelGet(id, options)(fetch, basePath);
        },
        /**
         * Emails user a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentManagementV1NotifyPost(id: number, options?: any) {
            return SalesShipmentManagementV1ApiFp(configuration).salesShipmentManagementV1NotifyPost(id, options)(fetch, basePath);
        },
    };
};

/**
 * SalesShipmentManagementV1Api - object-oriented interface
 * @export
 * @class SalesShipmentManagementV1Api
 * @extends {BaseAPI}
 */
export class SalesShipmentManagementV1Api extends BaseAPI {
    /**
     * Lists comments for a specified shipment.
     * @param {number} id The shipment ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentManagementV1Api
     */
    public salesShipmentManagementV1GetCommentsListGet(id: number, options?: any) {
        return SalesShipmentManagementV1ApiFp(this.configuration).salesShipmentManagementV1GetCommentsListGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a specified shipment label.
     * @param {number} id The shipment label ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentManagementV1Api
     */
    public salesShipmentManagementV1GetLabelGet(id: number, options?: any) {
        return SalesShipmentManagementV1ApiFp(this.configuration).salesShipmentManagementV1GetLabelGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Emails user a specified shipment.
     * @param {number} id The shipment ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentManagementV1Api
     */
    public salesShipmentManagementV1NotifyPost(id: number, options?: any) {
        return SalesShipmentManagementV1ApiFp(this.configuration).salesShipmentManagementV1NotifyPost(id, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesShipmentRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesShipmentRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loads a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesShipmentRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/shipment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists shipments that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#ShipmentRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/shipments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs persist operations for a specified shipment.
         * @param {SalesShipmentRepositoryV1SavePostBody} [salesShipmentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody?: SalesShipmentRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/shipment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesShipmentRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesShipmentRepositoryV1SavePostBody || {}) : (salesShipmentRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesShipmentRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesShipmentRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loads a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataShipmentInterface> {
            const localVarFetchArgs = SalesShipmentRepositoryV1ApiFetchParamCreator(configuration).salesShipmentRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists shipments that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#ShipmentRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataShipmentSearchResultInterface> {
            const localVarFetchArgs = SalesShipmentRepositoryV1ApiFetchParamCreator(configuration).salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs persist operations for a specified shipment.
         * @param {SalesShipmentRepositoryV1SavePostBody} [salesShipmentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody?: SalesShipmentRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataShipmentInterface> {
            const localVarFetchArgs = SalesShipmentRepositoryV1ApiFetchParamCreator(configuration).salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesShipmentRepositoryV1Api - factory interface
 * @export
 */
export const SalesShipmentRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loads a specified shipment.
         * @param {number} id The shipment ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1GetGet(id: number, options?: any) {
            return SalesShipmentRepositoryV1ApiFp(configuration).salesShipmentRepositoryV1GetGet(id, options)(fetch, basePath);
        },
        /**
         * Lists shipments that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#ShipmentRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesShipmentRepositoryV1ApiFp(configuration).salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Performs persist operations for a specified shipment.
         * @param {SalesShipmentRepositoryV1SavePostBody} [salesShipmentRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody?: SalesShipmentRepositoryV1SavePostBody, options?: any) {
            return SalesShipmentRepositoryV1ApiFp(configuration).salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesShipmentRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesShipmentRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesShipmentRepositoryV1Api extends BaseAPI {
    /**
     * Loads a specified shipment.
     * @param {number} id The shipment ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentRepositoryV1Api
     */
    public salesShipmentRepositoryV1GetGet(id: number, options?: any) {
        return SalesShipmentRepositoryV1ApiFp(this.configuration).salesShipmentRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists shipments that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#ShipmentRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentRepositoryV1Api
     */
    public salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesShipmentRepositoryV1ApiFp(this.configuration).salesShipmentRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Performs persist operations for a specified shipment.
     * @param {SalesShipmentRepositoryV1SavePostBody} [salesShipmentRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentRepositoryV1Api
     */
    public salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody?: SalesShipmentRepositoryV1SavePostBody, options?: any) {
        return SalesShipmentRepositoryV1ApiFp(this.configuration).salesShipmentRepositoryV1SavePost(salesShipmentRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesShipmentTrackRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesShipmentTrackRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specified shipment track by ID.
         * @param {number} id The shipment track ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentTrackRepositoryV1DeleteByIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesShipmentTrackRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/shipment/track/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs persist operations for a specified shipment track.
         * @param {SalesShipmentTrackRepositoryV1SavePostBody} [salesShipmentTrackRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody?: SalesShipmentTrackRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/shipment/track`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SalesShipmentTrackRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(salesShipmentTrackRepositoryV1SavePostBody || {}) : (salesShipmentTrackRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesShipmentTrackRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesShipmentTrackRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a specified shipment track by ID.
         * @param {number} id The shipment track ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentTrackRepositoryV1DeleteByIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SalesShipmentTrackRepositoryV1ApiFetchParamCreator(configuration).salesShipmentTrackRepositoryV1DeleteByIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs persist operations for a specified shipment track.
         * @param {SalesShipmentTrackRepositoryV1SavePostBody} [salesShipmentTrackRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody?: SalesShipmentTrackRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataShipmentTrackInterface> {
            const localVarFetchArgs = SalesShipmentTrackRepositoryV1ApiFetchParamCreator(configuration).salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesShipmentTrackRepositoryV1Api - factory interface
 * @export
 */
export const SalesShipmentTrackRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a specified shipment track by ID.
         * @param {number} id The shipment track ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentTrackRepositoryV1DeleteByIdDelete(id: number, options?: any) {
            return SalesShipmentTrackRepositoryV1ApiFp(configuration).salesShipmentTrackRepositoryV1DeleteByIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Performs persist operations for a specified shipment track.
         * @param {SalesShipmentTrackRepositoryV1SavePostBody} [salesShipmentTrackRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody?: SalesShipmentTrackRepositoryV1SavePostBody, options?: any) {
            return SalesShipmentTrackRepositoryV1ApiFp(configuration).salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SalesShipmentTrackRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesShipmentTrackRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesShipmentTrackRepositoryV1Api extends BaseAPI {
    /**
     * Deletes a specified shipment track by ID.
     * @param {number} id The shipment track ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentTrackRepositoryV1Api
     */
    public salesShipmentTrackRepositoryV1DeleteByIdDelete(id: number, options?: any) {
        return SalesShipmentTrackRepositoryV1ApiFp(this.configuration).salesShipmentTrackRepositoryV1DeleteByIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Performs persist operations for a specified shipment track.
     * @param {SalesShipmentTrackRepositoryV1SavePostBody} [salesShipmentTrackRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesShipmentTrackRepositoryV1Api
     */
    public salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody?: SalesShipmentTrackRepositoryV1SavePostBody, options?: any) {
        return SalesShipmentTrackRepositoryV1ApiFp(this.configuration).salesShipmentTrackRepositoryV1SavePost(salesShipmentTrackRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SalesTransactionRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SalesTransactionRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Loads a specified transaction.
         * @param {number} id The transaction ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesTransactionRepositoryV1GetGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling salesTransactionRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists transactions that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TransactionRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SalesTransactionRepositoryV1Api - functional programming interface
 * @export
 */
export const SalesTransactionRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Loads a specified transaction.
         * @param {number} id The transaction ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesTransactionRepositoryV1GetGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataTransactionInterface> {
            const localVarFetchArgs = SalesTransactionRepositoryV1ApiFetchParamCreator(configuration).salesTransactionRepositoryV1GetGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists transactions that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TransactionRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SalesDataTransactionSearchResultInterface> {
            const localVarFetchArgs = SalesTransactionRepositoryV1ApiFetchParamCreator(configuration).salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SalesTransactionRepositoryV1Api - factory interface
 * @export
 */
export const SalesTransactionRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Loads a specified transaction.
         * @param {number} id The transaction ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesTransactionRepositoryV1GetGet(id: number, options?: any) {
            return SalesTransactionRepositoryV1ApiFp(configuration).salesTransactionRepositoryV1GetGet(id, options)(fetch, basePath);
        },
        /**
         * Lists transactions that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TransactionRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SalesTransactionRepositoryV1ApiFp(configuration).salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * SalesTransactionRepositoryV1Api - object-oriented interface
 * @export
 * @class SalesTransactionRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SalesTransactionRepositoryV1Api extends BaseAPI {
    /**
     * Loads a specified transaction.
     * @param {number} id The transaction ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesTransactionRepositoryV1Api
     */
    public salesTransactionRepositoryV1GetGet(id: number, options?: any) {
        return SalesTransactionRepositoryV1ApiFp(this.configuration).salesTransactionRepositoryV1GetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists transactions that match specified search criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TransactionRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SalesTransactionRepositoryV1Api
     */
    public salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SalesTransactionRepositoryV1ApiFp(this.configuration).salesTransactionRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchV1Api - fetch parameter creator
 * @export
 */
export const SearchV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make Full Text Search and return found Documents
         * @param {string} [searchCriteriaRequestName]
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchV1SearchGet(searchCriteriaRequestName?: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaRequestName !== undefined) {
                localVarQueryParameter['searchCriteria[requestName]'] = searchCriteriaRequestName;
            }

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchV1Api - functional programming interface
 * @export
 */
export const SearchV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Make Full Text Search and return found Documents
         * @param {string} [searchCriteriaRequestName]
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchV1SearchGet(searchCriteriaRequestName?: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FrameworkSearchSearchResultInterface> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).searchV1SearchGet(searchCriteriaRequestName, searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchV1Api - factory interface
 * @export
 */
export const SearchV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Make Full Text Search and return found Documents
         * @param {string} [searchCriteriaRequestName]
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchV1SearchGet(searchCriteriaRequestName?: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SearchV1ApiFp(configuration).searchV1SearchGet(searchCriteriaRequestName, searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
    };
};

/**
 * SearchV1Api - object-oriented interface
 * @export
 * @class SearchV1Api
 * @extends {BaseAPI}
 */
export class SearchV1Api extends BaseAPI {
    /**
     * Make Full Text Search and return found Documents
     * @param {string} [searchCriteriaRequestName]
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public searchV1SearchGet(searchCriteriaRequestName?: string, searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SearchV1ApiFp(this.configuration).searchV1SearchGet(searchCriteriaRequestName, searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

}

/**
 * SharedCatalogCategoryManagementV1Api - fetch parameter creator
 * @export
 */
export const SharedCatalogCategoryManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add categories into the shared catalog.
         * @param {number} id
         * @param {SharedCatalogCategoryManagementV1AssignCategoriesPostBody} [sharedCatalogCategoryManagementV1AssignCategoriesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1AssignCategoriesPost(id: number, sharedCatalogCategoryManagementV1AssignCategoriesPostBody?: SharedCatalogCategoryManagementV1AssignCategoriesPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogCategoryManagementV1AssignCategoriesPost.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}/assignCategories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogCategoryManagementV1AssignCategoriesPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogCategoryManagementV1AssignCategoriesPostBody || {}) : (sharedCatalogCategoryManagementV1AssignCategoriesPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of categories in the selected shared catalog.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1GetCategoriesGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogCategoryManagementV1GetCategoriesGet.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}/categories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified categories from the shared catalog.
         * @param {number} id
         * @param {SharedCatalogCategoryManagementV1UnassignCategoriesPostBody} [sharedCatalogCategoryManagementV1UnassignCategoriesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1UnassignCategoriesPost(id: number, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody?: SharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogCategoryManagementV1UnassignCategoriesPost.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}/unassignCategories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogCategoryManagementV1UnassignCategoriesPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogCategoryManagementV1UnassignCategoriesPostBody || {}) : (sharedCatalogCategoryManagementV1UnassignCategoriesPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedCatalogCategoryManagementV1Api - functional programming interface
 * @export
 */
export const SharedCatalogCategoryManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add categories into the shared catalog.
         * @param {number} id
         * @param {SharedCatalogCategoryManagementV1AssignCategoriesPostBody} [sharedCatalogCategoryManagementV1AssignCategoriesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1AssignCategoriesPost(id: number, sharedCatalogCategoryManagementV1AssignCategoriesPostBody?: SharedCatalogCategoryManagementV1AssignCategoriesPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogCategoryManagementV1ApiFetchParamCreator(configuration).sharedCatalogCategoryManagementV1AssignCategoriesPost(id, sharedCatalogCategoryManagementV1AssignCategoriesPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the list of categories in the selected shared catalog.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1GetCategoriesGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = SharedCatalogCategoryManagementV1ApiFetchParamCreator(configuration).sharedCatalogCategoryManagementV1GetCategoriesGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove the specified categories from the shared catalog.
         * @param {number} id
         * @param {SharedCatalogCategoryManagementV1UnassignCategoriesPostBody} [sharedCatalogCategoryManagementV1UnassignCategoriesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1UnassignCategoriesPost(id: number, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody?: SharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogCategoryManagementV1ApiFetchParamCreator(configuration).sharedCatalogCategoryManagementV1UnassignCategoriesPost(id, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SharedCatalogCategoryManagementV1Api - factory interface
 * @export
 */
export const SharedCatalogCategoryManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add categories into the shared catalog.
         * @param {number} id
         * @param {SharedCatalogCategoryManagementV1AssignCategoriesPostBody} [sharedCatalogCategoryManagementV1AssignCategoriesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1AssignCategoriesPost(id: number, sharedCatalogCategoryManagementV1AssignCategoriesPostBody?: SharedCatalogCategoryManagementV1AssignCategoriesPostBody, options?: any) {
            return SharedCatalogCategoryManagementV1ApiFp(configuration).sharedCatalogCategoryManagementV1AssignCategoriesPost(id, sharedCatalogCategoryManagementV1AssignCategoriesPostBody, options)(fetch, basePath);
        },
        /**
         * Return the list of categories in the selected shared catalog.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1GetCategoriesGet(id: number, options?: any) {
            return SharedCatalogCategoryManagementV1ApiFp(configuration).sharedCatalogCategoryManagementV1GetCategoriesGet(id, options)(fetch, basePath);
        },
        /**
         * Remove the specified categories from the shared catalog.
         * @param {number} id
         * @param {SharedCatalogCategoryManagementV1UnassignCategoriesPostBody} [sharedCatalogCategoryManagementV1UnassignCategoriesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCategoryManagementV1UnassignCategoriesPost(id: number, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody?: SharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options?: any) {
            return SharedCatalogCategoryManagementV1ApiFp(configuration).sharedCatalogCategoryManagementV1UnassignCategoriesPost(id, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SharedCatalogCategoryManagementV1Api - object-oriented interface
 * @export
 * @class SharedCatalogCategoryManagementV1Api
 * @extends {BaseAPI}
 */
export class SharedCatalogCategoryManagementV1Api extends BaseAPI {
    /**
     * Add categories into the shared catalog.
     * @param {number} id
     * @param {SharedCatalogCategoryManagementV1AssignCategoriesPostBody} [sharedCatalogCategoryManagementV1AssignCategoriesPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogCategoryManagementV1Api
     */
    public sharedCatalogCategoryManagementV1AssignCategoriesPost(id: number, sharedCatalogCategoryManagementV1AssignCategoriesPostBody?: SharedCatalogCategoryManagementV1AssignCategoriesPostBody, options?: any) {
        return SharedCatalogCategoryManagementV1ApiFp(this.configuration).sharedCatalogCategoryManagementV1AssignCategoriesPost(id, sharedCatalogCategoryManagementV1AssignCategoriesPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return the list of categories in the selected shared catalog.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogCategoryManagementV1Api
     */
    public sharedCatalogCategoryManagementV1GetCategoriesGet(id: number, options?: any) {
        return SharedCatalogCategoryManagementV1ApiFp(this.configuration).sharedCatalogCategoryManagementV1GetCategoriesGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Remove the specified categories from the shared catalog.
     * @param {number} id
     * @param {SharedCatalogCategoryManagementV1UnassignCategoriesPostBody} [sharedCatalogCategoryManagementV1UnassignCategoriesPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogCategoryManagementV1Api
     */
    public sharedCatalogCategoryManagementV1UnassignCategoriesPost(id: number, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody?: SharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options?: any) {
        return SharedCatalogCategoryManagementV1ApiFp(this.configuration).sharedCatalogCategoryManagementV1UnassignCategoriesPost(id, sharedCatalogCategoryManagementV1UnassignCategoriesPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SharedCatalogCompanyManagementV1Api - fetch parameter creator
 * @export
 */
export const SharedCatalogCompanyManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign companies to a shared catalog.
         * @param {number} sharedCatalogId
         * @param {SharedCatalogCompanyManagementV1AssignCompaniesPostBody} [sharedCatalogCompanyManagementV1AssignCompaniesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1AssignCompaniesPostBody?: SharedCatalogCompanyManagementV1AssignCompaniesPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sharedCatalogId' is not null or undefined
            if (sharedCatalogId === null || sharedCatalogId === undefined) {
                throw new RequiredError('sharedCatalogId','Required parameter sharedCatalogId was null or undefined when calling sharedCatalogCompanyManagementV1AssignCompaniesPost.');
            }
            const localVarPath = `/V1/sharedCatalog/{sharedCatalogId}/assignCompanies`
                .replace(`{${"sharedCatalogId"}}`, encodeURIComponent(String(sharedCatalogId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogCompanyManagementV1AssignCompaniesPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogCompanyManagementV1AssignCompaniesPostBody || {}) : (sharedCatalogCompanyManagementV1AssignCompaniesPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of company IDs for the companies assigned to the selected catalog.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sharedCatalogId' is not null or undefined
            if (sharedCatalogId === null || sharedCatalogId === undefined) {
                throw new RequiredError('sharedCatalogId','Required parameter sharedCatalogId was null or undefined when calling sharedCatalogCompanyManagementV1GetCompaniesGet.');
            }
            const localVarPath = `/V1/sharedCatalog/{sharedCatalogId}/companies`
                .replace(`{${"sharedCatalogId"}}`, encodeURIComponent(String(sharedCatalogId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassign companies from a shared catalog.
         * @param {number} sharedCatalogId
         * @param {SharedCatalogCompanyManagementV1UnassignCompaniesPostBody} [sharedCatalogCompanyManagementV1UnassignCompaniesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody?: SharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'sharedCatalogId' is not null or undefined
            if (sharedCatalogId === null || sharedCatalogId === undefined) {
                throw new RequiredError('sharedCatalogId','Required parameter sharedCatalogId was null or undefined when calling sharedCatalogCompanyManagementV1UnassignCompaniesPost.');
            }
            const localVarPath = `/V1/sharedCatalog/{sharedCatalogId}/unassignCompanies`
                .replace(`{${"sharedCatalogId"}}`, encodeURIComponent(String(sharedCatalogId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogCompanyManagementV1UnassignCompaniesPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogCompanyManagementV1UnassignCompaniesPostBody || {}) : (sharedCatalogCompanyManagementV1UnassignCompaniesPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedCatalogCompanyManagementV1Api - functional programming interface
 * @export
 */
export const SharedCatalogCompanyManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assign companies to a shared catalog.
         * @param {number} sharedCatalogId
         * @param {SharedCatalogCompanyManagementV1AssignCompaniesPostBody} [sharedCatalogCompanyManagementV1AssignCompaniesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1AssignCompaniesPostBody?: SharedCatalogCompanyManagementV1AssignCompaniesPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogCompanyManagementV1ApiFetchParamCreator(configuration).sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId, sharedCatalogCompanyManagementV1AssignCompaniesPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the list of company IDs for the companies assigned to the selected catalog.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SharedCatalogCompanyManagementV1ApiFetchParamCreator(configuration).sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unassign companies from a shared catalog.
         * @param {number} sharedCatalogId
         * @param {SharedCatalogCompanyManagementV1UnassignCompaniesPostBody} [sharedCatalogCompanyManagementV1UnassignCompaniesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody?: SharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogCompanyManagementV1ApiFetchParamCreator(configuration).sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SharedCatalogCompanyManagementV1Api - factory interface
 * @export
 */
export const SharedCatalogCompanyManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assign companies to a shared catalog.
         * @param {number} sharedCatalogId
         * @param {SharedCatalogCompanyManagementV1AssignCompaniesPostBody} [sharedCatalogCompanyManagementV1AssignCompaniesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1AssignCompaniesPostBody?: SharedCatalogCompanyManagementV1AssignCompaniesPostBody, options?: any) {
            return SharedCatalogCompanyManagementV1ApiFp(configuration).sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId, sharedCatalogCompanyManagementV1AssignCompaniesPostBody, options)(fetch, basePath);
        },
        /**
         * Return the list of company IDs for the companies assigned to the selected catalog.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId: number, options?: any) {
            return SharedCatalogCompanyManagementV1ApiFp(configuration).sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId, options)(fetch, basePath);
        },
        /**
         * Unassign companies from a shared catalog.
         * @param {number} sharedCatalogId
         * @param {SharedCatalogCompanyManagementV1UnassignCompaniesPostBody} [sharedCatalogCompanyManagementV1UnassignCompaniesPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody?: SharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options?: any) {
            return SharedCatalogCompanyManagementV1ApiFp(configuration).sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SharedCatalogCompanyManagementV1Api - object-oriented interface
 * @export
 * @class SharedCatalogCompanyManagementV1Api
 * @extends {BaseAPI}
 */
export class SharedCatalogCompanyManagementV1Api extends BaseAPI {
    /**
     * Assign companies to a shared catalog.
     * @param {number} sharedCatalogId
     * @param {SharedCatalogCompanyManagementV1AssignCompaniesPostBody} [sharedCatalogCompanyManagementV1AssignCompaniesPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogCompanyManagementV1Api
     */
    public sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1AssignCompaniesPostBody?: SharedCatalogCompanyManagementV1AssignCompaniesPostBody, options?: any) {
        return SharedCatalogCompanyManagementV1ApiFp(this.configuration).sharedCatalogCompanyManagementV1AssignCompaniesPost(sharedCatalogId, sharedCatalogCompanyManagementV1AssignCompaniesPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return the list of company IDs for the companies assigned to the selected catalog.
     * @param {number} sharedCatalogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogCompanyManagementV1Api
     */
    public sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId: number, options?: any) {
        return SharedCatalogCompanyManagementV1ApiFp(this.configuration).sharedCatalogCompanyManagementV1GetCompaniesGet(sharedCatalogId, options)(this.fetch, this.basePath);
    }

    /**
     * Unassign companies from a shared catalog.
     * @param {number} sharedCatalogId
     * @param {SharedCatalogCompanyManagementV1UnassignCompaniesPostBody} [sharedCatalogCompanyManagementV1UnassignCompaniesPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogCompanyManagementV1Api
     */
    public sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId: number, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody?: SharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options?: any) {
        return SharedCatalogCompanyManagementV1ApiFp(this.configuration).sharedCatalogCompanyManagementV1UnassignCompaniesPost(sharedCatalogId, sharedCatalogCompanyManagementV1UnassignCompaniesPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SharedCatalogProductManagementV1Api - fetch parameter creator
 * @export
 */
export const SharedCatalogProductManagementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add products into the shared catalog.
         * @param {number} id
         * @param {SharedCatalogProductManagementV1AssignProductsPostBody} [sharedCatalogProductManagementV1AssignProductsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1AssignProductsPost(id: number, sharedCatalogProductManagementV1AssignProductsPostBody?: SharedCatalogProductManagementV1AssignProductsPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogProductManagementV1AssignProductsPost.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}/assignProducts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogProductManagementV1AssignProductsPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogProductManagementV1AssignProductsPostBody || {}) : (sharedCatalogProductManagementV1AssignProductsPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of product SKUs in the selected shared catalog.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1GetProductsGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogProductManagementV1GetProductsGet.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified products from the shared catalog.
         * @param {number} id
         * @param {SharedCatalogProductManagementV1UnassignProductsPostBody} [sharedCatalogProductManagementV1UnassignProductsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1UnassignProductsPost(id: number, sharedCatalogProductManagementV1UnassignProductsPostBody?: SharedCatalogProductManagementV1UnassignProductsPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogProductManagementV1UnassignProductsPost.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}/unassignProducts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogProductManagementV1UnassignProductsPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogProductManagementV1UnassignProductsPostBody || {}) : (sharedCatalogProductManagementV1UnassignProductsPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedCatalogProductManagementV1Api - functional programming interface
 * @export
 */
export const SharedCatalogProductManagementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add products into the shared catalog.
         * @param {number} id
         * @param {SharedCatalogProductManagementV1AssignProductsPostBody} [sharedCatalogProductManagementV1AssignProductsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1AssignProductsPost(id: number, sharedCatalogProductManagementV1AssignProductsPostBody?: SharedCatalogProductManagementV1AssignProductsPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogProductManagementV1ApiFetchParamCreator(configuration).sharedCatalogProductManagementV1AssignProductsPost(id, sharedCatalogProductManagementV1AssignProductsPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the list of product SKUs in the selected shared catalog.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1GetProductsGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SharedCatalogProductManagementV1ApiFetchParamCreator(configuration).sharedCatalogProductManagementV1GetProductsGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove the specified products from the shared catalog.
         * @param {number} id
         * @param {SharedCatalogProductManagementV1UnassignProductsPostBody} [sharedCatalogProductManagementV1UnassignProductsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1UnassignProductsPost(id: number, sharedCatalogProductManagementV1UnassignProductsPostBody?: SharedCatalogProductManagementV1UnassignProductsPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogProductManagementV1ApiFetchParamCreator(configuration).sharedCatalogProductManagementV1UnassignProductsPost(id, sharedCatalogProductManagementV1UnassignProductsPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SharedCatalogProductManagementV1Api - factory interface
 * @export
 */
export const SharedCatalogProductManagementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add products into the shared catalog.
         * @param {number} id
         * @param {SharedCatalogProductManagementV1AssignProductsPostBody} [sharedCatalogProductManagementV1AssignProductsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1AssignProductsPost(id: number, sharedCatalogProductManagementV1AssignProductsPostBody?: SharedCatalogProductManagementV1AssignProductsPostBody, options?: any) {
            return SharedCatalogProductManagementV1ApiFp(configuration).sharedCatalogProductManagementV1AssignProductsPost(id, sharedCatalogProductManagementV1AssignProductsPostBody, options)(fetch, basePath);
        },
        /**
         * Return the list of product SKUs in the selected shared catalog.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1GetProductsGet(id: number, options?: any) {
            return SharedCatalogProductManagementV1ApiFp(configuration).sharedCatalogProductManagementV1GetProductsGet(id, options)(fetch, basePath);
        },
        /**
         * Remove the specified products from the shared catalog.
         * @param {number} id
         * @param {SharedCatalogProductManagementV1UnassignProductsPostBody} [sharedCatalogProductManagementV1UnassignProductsPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogProductManagementV1UnassignProductsPost(id: number, sharedCatalogProductManagementV1UnassignProductsPostBody?: SharedCatalogProductManagementV1UnassignProductsPostBody, options?: any) {
            return SharedCatalogProductManagementV1ApiFp(configuration).sharedCatalogProductManagementV1UnassignProductsPost(id, sharedCatalogProductManagementV1UnassignProductsPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * SharedCatalogProductManagementV1Api - object-oriented interface
 * @export
 * @class SharedCatalogProductManagementV1Api
 * @extends {BaseAPI}
 */
export class SharedCatalogProductManagementV1Api extends BaseAPI {
    /**
     * Add products into the shared catalog.
     * @param {number} id
     * @param {SharedCatalogProductManagementV1AssignProductsPostBody} [sharedCatalogProductManagementV1AssignProductsPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogProductManagementV1Api
     */
    public sharedCatalogProductManagementV1AssignProductsPost(id: number, sharedCatalogProductManagementV1AssignProductsPostBody?: SharedCatalogProductManagementV1AssignProductsPostBody, options?: any) {
        return SharedCatalogProductManagementV1ApiFp(this.configuration).sharedCatalogProductManagementV1AssignProductsPost(id, sharedCatalogProductManagementV1AssignProductsPostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Return the list of product SKUs in the selected shared catalog.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogProductManagementV1Api
     */
    public sharedCatalogProductManagementV1GetProductsGet(id: number, options?: any) {
        return SharedCatalogProductManagementV1ApiFp(this.configuration).sharedCatalogProductManagementV1GetProductsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Remove the specified products from the shared catalog.
     * @param {number} id
     * @param {SharedCatalogProductManagementV1UnassignProductsPostBody} [sharedCatalogProductManagementV1UnassignProductsPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogProductManagementV1Api
     */
    public sharedCatalogProductManagementV1UnassignProductsPost(id: number, sharedCatalogProductManagementV1UnassignProductsPostBody?: SharedCatalogProductManagementV1UnassignProductsPostBody, options?: any) {
        return SharedCatalogProductManagementV1ApiFp(this.configuration).sharedCatalogProductManagementV1UnassignProductsPost(id, sharedCatalogProductManagementV1UnassignProductsPostBody, options)(this.fetch, this.basePath);
    }

}

/**
 * SharedCatalogSharedCatalogRepositoryV1Api - fetch parameter creator
 * @export
 */
export const SharedCatalogSharedCatalogRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a shared catalog by ID.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sharedCatalogId' is not null or undefined
            if (sharedCatalogId === null || sharedCatalogId === undefined) {
                throw new RequiredError('sharedCatalogId','Required parameter sharedCatalogId was null or undefined when calling sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/sharedCatalog/{sharedCatalogId}`
                .replace(`{${"sharedCatalogId"}}`, encodeURIComponent(String(sharedCatalogId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the following properties for the selected shared catalog: ID, Store Group ID, Name, Type, Description, Customer Group, Tax Class.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sharedCatalogId' is not null or undefined
            if (sharedCatalogId === null || sharedCatalogId === undefined) {
                throw new RequiredError('sharedCatalogId','Required parameter sharedCatalogId was null or undefined when calling sharedCatalogSharedCatalogRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/sharedCatalog/{sharedCatalogId}`
                .replace(`{${"sharedCatalogId"}}`, encodeURIComponent(String(sharedCatalogId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of shared catalogs and basic properties for each catalog.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/sharedCatalog/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update Shared Catalog service.
         * @param {SharedCatalogSharedCatalogRepositoryV1SavePostBody} [sharedCatalogSharedCatalogRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody?: SharedCatalogSharedCatalogRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/sharedCatalog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogSharedCatalogRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogSharedCatalogRepositoryV1SavePostBody || {}) : (sharedCatalogSharedCatalogRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update Shared Catalog service.
         * @param {string} id
         * @param {SharedCatalogSharedCatalogRepositoryV1SavePutBody} [sharedCatalogSharedCatalogRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1SavePut(id: string, sharedCatalogSharedCatalogRepositoryV1SavePutBody?: SharedCatalogSharedCatalogRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sharedCatalogSharedCatalogRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/sharedCatalog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharedCatalogSharedCatalogRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sharedCatalogSharedCatalogRepositoryV1SavePutBody || {}) : (sharedCatalogSharedCatalogRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedCatalogSharedCatalogRepositoryV1Api - functional programming interface
 * @export
 */
export const SharedCatalogSharedCatalogRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a shared catalog by ID.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SharedCatalogSharedCatalogRepositoryV1ApiFetchParamCreator(configuration).sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the following properties for the selected shared catalog: ID, Store Group ID, Name, Type, Description, Customer Group, Tax Class.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SharedCatalogDataSharedCatalogInterface> {
            const localVarFetchArgs = SharedCatalogSharedCatalogRepositoryV1ApiFetchParamCreator(configuration).sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the list of shared catalogs and basic properties for each catalog.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SharedCatalogDataSearchResultsInterface> {
            const localVarFetchArgs = SharedCatalogSharedCatalogRepositoryV1ApiFetchParamCreator(configuration).sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update Shared Catalog service.
         * @param {SharedCatalogSharedCatalogRepositoryV1SavePostBody} [sharedCatalogSharedCatalogRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody?: SharedCatalogSharedCatalogRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = SharedCatalogSharedCatalogRepositoryV1ApiFetchParamCreator(configuration).sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update Shared Catalog service.
         * @param {string} id
         * @param {SharedCatalogSharedCatalogRepositoryV1SavePutBody} [sharedCatalogSharedCatalogRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1SavePut(id: string, sharedCatalogSharedCatalogRepositoryV1SavePutBody?: SharedCatalogSharedCatalogRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = SharedCatalogSharedCatalogRepositoryV1ApiFetchParamCreator(configuration).sharedCatalogSharedCatalogRepositoryV1SavePut(id, sharedCatalogSharedCatalogRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SharedCatalogSharedCatalogRepositoryV1Api - factory interface
 * @export
 */
export const SharedCatalogSharedCatalogRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a shared catalog by ID.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId: number, options?: any) {
            return SharedCatalogSharedCatalogRepositoryV1ApiFp(configuration).sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId, options)(fetch, basePath);
        },
        /**
         * Return the following properties for the selected shared catalog: ID, Store Group ID, Name, Type, Description, Customer Group, Tax Class.
         * @param {number} sharedCatalogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId: number, options?: any) {
            return SharedCatalogSharedCatalogRepositoryV1ApiFp(configuration).sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId, options)(fetch, basePath);
        },
        /**
         * Return the list of shared catalogs and basic properties for each catalog.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return SharedCatalogSharedCatalogRepositoryV1ApiFp(configuration).sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create or update Shared Catalog service.
         * @param {SharedCatalogSharedCatalogRepositoryV1SavePostBody} [sharedCatalogSharedCatalogRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody?: SharedCatalogSharedCatalogRepositoryV1SavePostBody, options?: any) {
            return SharedCatalogSharedCatalogRepositoryV1ApiFp(configuration).sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create or update Shared Catalog service.
         * @param {string} id
         * @param {SharedCatalogSharedCatalogRepositoryV1SavePutBody} [sharedCatalogSharedCatalogRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedCatalogSharedCatalogRepositoryV1SavePut(id: string, sharedCatalogSharedCatalogRepositoryV1SavePutBody?: SharedCatalogSharedCatalogRepositoryV1SavePutBody, options?: any) {
            return SharedCatalogSharedCatalogRepositoryV1ApiFp(configuration).sharedCatalogSharedCatalogRepositoryV1SavePut(id, sharedCatalogSharedCatalogRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * SharedCatalogSharedCatalogRepositoryV1Api - object-oriented interface
 * @export
 * @class SharedCatalogSharedCatalogRepositoryV1Api
 * @extends {BaseAPI}
 */
export class SharedCatalogSharedCatalogRepositoryV1Api extends BaseAPI {
    /**
     * Delete a shared catalog by ID.
     * @param {number} sharedCatalogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogSharedCatalogRepositoryV1Api
     */
    public sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId: number, options?: any) {
        return SharedCatalogSharedCatalogRepositoryV1ApiFp(this.configuration).sharedCatalogSharedCatalogRepositoryV1DeleteByIdDelete(sharedCatalogId, options)(this.fetch, this.basePath);
    }

    /**
     * Return the following properties for the selected shared catalog: ID, Store Group ID, Name, Type, Description, Customer Group, Tax Class.
     * @param {number} sharedCatalogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogSharedCatalogRepositoryV1Api
     */
    public sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId: number, options?: any) {
        return SharedCatalogSharedCatalogRepositoryV1ApiFp(this.configuration).sharedCatalogSharedCatalogRepositoryV1GetGet(sharedCatalogId, options)(this.fetch, this.basePath);
    }

    /**
     * Return the list of shared catalogs and basic properties for each catalog.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogSharedCatalogRepositoryV1Api
     */
    public sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return SharedCatalogSharedCatalogRepositoryV1ApiFp(this.configuration).sharedCatalogSharedCatalogRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update Shared Catalog service.
     * @param {SharedCatalogSharedCatalogRepositoryV1SavePostBody} [sharedCatalogSharedCatalogRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogSharedCatalogRepositoryV1Api
     */
    public sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody?: SharedCatalogSharedCatalogRepositoryV1SavePostBody, options?: any) {
        return SharedCatalogSharedCatalogRepositoryV1ApiFp(this.configuration).sharedCatalogSharedCatalogRepositoryV1SavePost(sharedCatalogSharedCatalogRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update Shared Catalog service.
     * @param {string} id
     * @param {SharedCatalogSharedCatalogRepositoryV1SavePutBody} [sharedCatalogSharedCatalogRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedCatalogSharedCatalogRepositoryV1Api
     */
    public sharedCatalogSharedCatalogRepositoryV1SavePut(id: string, sharedCatalogSharedCatalogRepositoryV1SavePutBody?: SharedCatalogSharedCatalogRepositoryV1SavePutBody, options?: any) {
        return SharedCatalogSharedCatalogRepositoryV1ApiFp(this.configuration).sharedCatalogSharedCatalogRepositoryV1SavePut(id, sharedCatalogSharedCatalogRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * StoreGroupRepositoryV1Api - fetch parameter creator
 * @export
 */
export const StoreGroupRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve list of all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGroupRepositoryV1GetListGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/store/storeGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreGroupRepositoryV1Api - functional programming interface
 * @export
 */
export const StoreGroupRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve list of all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGroupRepositoryV1GetListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StoreDataGroupInterface>> {
            const localVarFetchArgs = StoreGroupRepositoryV1ApiFetchParamCreator(configuration).storeGroupRepositoryV1GetListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoreGroupRepositoryV1Api - factory interface
 * @export
 */
export const StoreGroupRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve list of all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGroupRepositoryV1GetListGet(options?: any) {
            return StoreGroupRepositoryV1ApiFp(configuration).storeGroupRepositoryV1GetListGet(options)(fetch, basePath);
        },
    };
};

/**
 * StoreGroupRepositoryV1Api - object-oriented interface
 * @export
 * @class StoreGroupRepositoryV1Api
 * @extends {BaseAPI}
 */
export class StoreGroupRepositoryV1Api extends BaseAPI {
    /**
     * Retrieve list of all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreGroupRepositoryV1Api
     */
    public storeGroupRepositoryV1GetListGet(options?: any) {
        return StoreGroupRepositoryV1ApiFp(this.configuration).storeGroupRepositoryV1GetListGet(options)(this.fetch, this.basePath);
    }

}

/**
 * StoreStoreConfigManagerV1Api - fetch parameter creator
 * @export
 */
export const StoreStoreConfigManagerV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Array<string>} [storeCodes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/V1/store/storeConfigs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeCodes) {
                localVarQueryParameter['storeCodes'] = storeCodes.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreStoreConfigManagerV1Api - functional programming interface
 * @export
 */
export const StoreStoreConfigManagerV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {Array<string>} [storeCodes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StoreDataStoreConfigInterface>> {
            const localVarFetchArgs = StoreStoreConfigManagerV1ApiFetchParamCreator(configuration).storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoreStoreConfigManagerV1Api - factory interface
 * @export
 */
export const StoreStoreConfigManagerV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {Array<string>} [storeCodes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes?: Array<string>, options?: any) {
            return StoreStoreConfigManagerV1ApiFp(configuration).storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes, options)(fetch, basePath);
        },
    };
};

/**
 * StoreStoreConfigManagerV1Api - object-oriented interface
 * @export
 * @class StoreStoreConfigManagerV1Api
 * @extends {BaseAPI}
 */
export class StoreStoreConfigManagerV1Api extends BaseAPI {
    /**
     *
     * @param {Array<string>} [storeCodes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreStoreConfigManagerV1Api
     */
    public storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes?: Array<string>, options?: any) {
        return StoreStoreConfigManagerV1ApiFp(this.configuration).storeStoreConfigManagerV1GetStoreConfigsGet(storeCodes, options)(this.fetch, this.basePath);
    }

}

/**
 * StoreStoreRepositoryV1Api - fetch parameter creator
 * @export
 */
export const StoreStoreRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve list of all stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeStoreRepositoryV1GetListGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/store/storeViews`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreStoreRepositoryV1Api - functional programming interface
 * @export
 */
export const StoreStoreRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve list of all stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeStoreRepositoryV1GetListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StoreDataStoreInterface>> {
            const localVarFetchArgs = StoreStoreRepositoryV1ApiFetchParamCreator(configuration).storeStoreRepositoryV1GetListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoreStoreRepositoryV1Api - factory interface
 * @export
 */
export const StoreStoreRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve list of all stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeStoreRepositoryV1GetListGet(options?: any) {
            return StoreStoreRepositoryV1ApiFp(configuration).storeStoreRepositoryV1GetListGet(options)(fetch, basePath);
        },
    };
};

/**
 * StoreStoreRepositoryV1Api - object-oriented interface
 * @export
 * @class StoreStoreRepositoryV1Api
 * @extends {BaseAPI}
 */
export class StoreStoreRepositoryV1Api extends BaseAPI {
    /**
     * Retrieve list of all stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreStoreRepositoryV1Api
     */
    public storeStoreRepositoryV1GetListGet(options?: any) {
        return StoreStoreRepositoryV1ApiFp(this.configuration).storeStoreRepositoryV1GetListGet(options)(this.fetch, this.basePath);
    }

}

/**
 * StoreWebsiteRepositoryV1Api - fetch parameter creator
 * @export
 */
export const StoreWebsiteRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve list of all websites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebsiteRepositoryV1GetListGet(options: any = {}): FetchArgs {
            const localVarPath = `/V1/store/websites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreWebsiteRepositoryV1Api - functional programming interface
 * @export
 */
export const StoreWebsiteRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve list of all websites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebsiteRepositoryV1GetListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StoreDataWebsiteInterface>> {
            const localVarFetchArgs = StoreWebsiteRepositoryV1ApiFetchParamCreator(configuration).storeWebsiteRepositoryV1GetListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoreWebsiteRepositoryV1Api - factory interface
 * @export
 */
export const StoreWebsiteRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve list of all websites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebsiteRepositoryV1GetListGet(options?: any) {
            return StoreWebsiteRepositoryV1ApiFp(configuration).storeWebsiteRepositoryV1GetListGet(options)(fetch, basePath);
        },
    };
};

/**
 * StoreWebsiteRepositoryV1Api - object-oriented interface
 * @export
 * @class StoreWebsiteRepositoryV1Api
 * @extends {BaseAPI}
 */
export class StoreWebsiteRepositoryV1Api extends BaseAPI {
    /**
     * Retrieve list of all websites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWebsiteRepositoryV1Api
     */
    public storeWebsiteRepositoryV1GetListGet(options?: any) {
        return StoreWebsiteRepositoryV1ApiFp(this.configuration).storeWebsiteRepositoryV1GetListGet(options)(this.fetch, this.basePath);
    }

}

/**
 * TaxTaxClassRepositoryV1Api - fetch parameter creator
 * @export
 */
export const TaxTaxClassRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a tax class with the given tax class id.
         * @param {number} taxClassId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId: number, options: any = {}): FetchArgs {
            // verify required parameter 'taxClassId' is not null or undefined
            if (taxClassId === null || taxClassId === undefined) {
                throw new RequiredError('taxClassId','Required parameter taxClassId was null or undefined when calling taxTaxClassRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/taxClasses/{taxClassId}`
                .replace(`{${"taxClassId"}}`, encodeURIComponent(String(taxClassId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a tax class with the given tax class id.
         * @param {number} taxClassId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1GetGet(taxClassId: number, options: any = {}): FetchArgs {
            // verify required parameter 'taxClassId' is not null or undefined
            if (taxClassId === null || taxClassId === undefined) {
                throw new RequiredError('taxClassId','Required parameter taxClassId was null or undefined when calling taxTaxClassRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/taxClasses/{taxClassId}`
                .replace(`{${"taxClassId"}}`, encodeURIComponent(String(taxClassId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve tax classes which match a specific criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxClassRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxClasses/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Tax Class
         * @param {TaxTaxClassRepositoryV1SavePostBody} [taxTaxClassRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody?: TaxTaxClassRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxTaxClassRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxTaxClassRepositoryV1SavePostBody || {}) : (taxTaxClassRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Tax Class
         * @param {string} classId
         * @param {TaxTaxClassRepositoryV1SavePutBody} [taxTaxClassRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1SavePut(classId: string, taxTaxClassRepositoryV1SavePutBody?: TaxTaxClassRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            // verify required parameter 'classId' is not null or undefined
            if (classId === null || classId === undefined) {
                throw new RequiredError('classId','Required parameter classId was null or undefined when calling taxTaxClassRepositoryV1SavePut.');
            }
            const localVarPath = `/V1/taxClasses/{classId}`
                .replace(`{${"classId"}}`, encodeURIComponent(String(classId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxTaxClassRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxTaxClassRepositoryV1SavePutBody || {}) : (taxTaxClassRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxTaxClassRepositoryV1Api - functional programming interface
 * @export
 */
export const TaxTaxClassRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a tax class with the given tax class id.
         * @param {number} taxClassId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = TaxTaxClassRepositoryV1ApiFetchParamCreator(configuration).taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a tax class with the given tax class id.
         * @param {number} taxClassId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1GetGet(taxClassId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxClassInterface> {
            const localVarFetchArgs = TaxTaxClassRepositoryV1ApiFetchParamCreator(configuration).taxTaxClassRepositoryV1GetGet(taxClassId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve tax classes which match a specific criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxClassRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxClassSearchResultsInterface> {
            const localVarFetchArgs = TaxTaxClassRepositoryV1ApiFetchParamCreator(configuration).taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Tax Class
         * @param {TaxTaxClassRepositoryV1SavePostBody} [taxTaxClassRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody?: TaxTaxClassRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = TaxTaxClassRepositoryV1ApiFetchParamCreator(configuration).taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Tax Class
         * @param {string} classId
         * @param {TaxTaxClassRepositoryV1SavePutBody} [taxTaxClassRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1SavePut(classId: string, taxTaxClassRepositoryV1SavePutBody?: TaxTaxClassRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = TaxTaxClassRepositoryV1ApiFetchParamCreator(configuration).taxTaxClassRepositoryV1SavePut(classId, taxTaxClassRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaxTaxClassRepositoryV1Api - factory interface
 * @export
 */
export const TaxTaxClassRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a tax class with the given tax class id.
         * @param {number} taxClassId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId: number, options?: any) {
            return TaxTaxClassRepositoryV1ApiFp(configuration).taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId, options)(fetch, basePath);
        },
        /**
         * Get a tax class with the given tax class id.
         * @param {number} taxClassId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1GetGet(taxClassId: number, options?: any) {
            return TaxTaxClassRepositoryV1ApiFp(configuration).taxTaxClassRepositoryV1GetGet(taxClassId, options)(fetch, basePath);
        },
        /**
         * Retrieve tax classes which match a specific criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxClassRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return TaxTaxClassRepositoryV1ApiFp(configuration).taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create a Tax Class
         * @param {TaxTaxClassRepositoryV1SavePostBody} [taxTaxClassRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody?: TaxTaxClassRepositoryV1SavePostBody, options?: any) {
            return TaxTaxClassRepositoryV1ApiFp(configuration).taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create a Tax Class
         * @param {string} classId
         * @param {TaxTaxClassRepositoryV1SavePutBody} [taxTaxClassRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxClassRepositoryV1SavePut(classId: string, taxTaxClassRepositoryV1SavePutBody?: TaxTaxClassRepositoryV1SavePutBody, options?: any) {
            return TaxTaxClassRepositoryV1ApiFp(configuration).taxTaxClassRepositoryV1SavePut(classId, taxTaxClassRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * TaxTaxClassRepositoryV1Api - object-oriented interface
 * @export
 * @class TaxTaxClassRepositoryV1Api
 * @extends {BaseAPI}
 */
export class TaxTaxClassRepositoryV1Api extends BaseAPI {
    /**
     * Delete a tax class with the given tax class id.
     * @param {number} taxClassId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxClassRepositoryV1Api
     */
    public taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId: number, options?: any) {
        return TaxTaxClassRepositoryV1ApiFp(this.configuration).taxTaxClassRepositoryV1DeleteByIdDelete(taxClassId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a tax class with the given tax class id.
     * @param {number} taxClassId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxClassRepositoryV1Api
     */
    public taxTaxClassRepositoryV1GetGet(taxClassId: number, options?: any) {
        return TaxTaxClassRepositoryV1ApiFp(this.configuration).taxTaxClassRepositoryV1GetGet(taxClassId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve tax classes which match a specific criteria. This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxClassRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxClassRepositoryV1Api
     */
    public taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return TaxTaxClassRepositoryV1ApiFp(this.configuration).taxTaxClassRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Tax Class
     * @param {TaxTaxClassRepositoryV1SavePostBody} [taxTaxClassRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxClassRepositoryV1Api
     */
    public taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody?: TaxTaxClassRepositoryV1SavePostBody, options?: any) {
        return TaxTaxClassRepositoryV1ApiFp(this.configuration).taxTaxClassRepositoryV1SavePost(taxTaxClassRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Tax Class
     * @param {string} classId
     * @param {TaxTaxClassRepositoryV1SavePutBody} [taxTaxClassRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxClassRepositoryV1Api
     */
    public taxTaxClassRepositoryV1SavePut(classId: string, taxTaxClassRepositoryV1SavePutBody?: TaxTaxClassRepositoryV1SavePutBody, options?: any) {
        return TaxTaxClassRepositoryV1ApiFp(this.configuration).taxTaxClassRepositoryV1SavePut(classId, taxTaxClassRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * TaxTaxRateRepositoryV1Api - fetch parameter creator
 * @export
 */
export const TaxTaxRateRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete tax rate
         * @param {number} rateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1DeleteByIdDelete(rateId: number, options: any = {}): FetchArgs {
            // verify required parameter 'rateId' is not null or undefined
            if (rateId === null || rateId === undefined) {
                throw new RequiredError('rateId','Required parameter rateId was null or undefined when calling taxTaxRateRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/taxRates/{rateId}`
                .replace(`{${"rateId"}}`, encodeURIComponent(String(rateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tax rate
         * @param {number} rateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1GetGet(rateId: number, options: any = {}): FetchArgs {
            // verify required parameter 'rateId' is not null or undefined
            if (rateId === null || rateId === undefined) {
                throw new RequiredError('rateId','Required parameter rateId was null or undefined when calling taxTaxRateRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/taxRates/{rateId}`
                .replace(`{${"rateId"}}`, encodeURIComponent(String(rateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search TaxRates This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRateRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxRates/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update tax rate
         * @param {TaxTaxRateRepositoryV1SavePostBody} [taxTaxRateRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody?: TaxTaxRateRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxRates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxTaxRateRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxTaxRateRepositoryV1SavePostBody || {}) : (taxTaxRateRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update tax rate
         * @param {TaxTaxRateRepositoryV1SavePutBody} [taxTaxRateRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody?: TaxTaxRateRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxRates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxTaxRateRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxTaxRateRepositoryV1SavePutBody || {}) : (taxTaxRateRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxTaxRateRepositoryV1Api - functional programming interface
 * @export
 */
export const TaxTaxRateRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete tax rate
         * @param {number} rateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1DeleteByIdDelete(rateId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = TaxTaxRateRepositoryV1ApiFetchParamCreator(configuration).taxTaxRateRepositoryV1DeleteByIdDelete(rateId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get tax rate
         * @param {number} rateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1GetGet(rateId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRateInterface> {
            const localVarFetchArgs = TaxTaxRateRepositoryV1ApiFetchParamCreator(configuration).taxTaxRateRepositoryV1GetGet(rateId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search TaxRates This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRateRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRateSearchResultsInterface> {
            const localVarFetchArgs = TaxTaxRateRepositoryV1ApiFetchParamCreator(configuration).taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update tax rate
         * @param {TaxTaxRateRepositoryV1SavePostBody} [taxTaxRateRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody?: TaxTaxRateRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRateInterface> {
            const localVarFetchArgs = TaxTaxRateRepositoryV1ApiFetchParamCreator(configuration).taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update tax rate
         * @param {TaxTaxRateRepositoryV1SavePutBody} [taxTaxRateRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody?: TaxTaxRateRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRateInterface> {
            const localVarFetchArgs = TaxTaxRateRepositoryV1ApiFetchParamCreator(configuration).taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaxTaxRateRepositoryV1Api - factory interface
 * @export
 */
export const TaxTaxRateRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete tax rate
         * @param {number} rateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1DeleteByIdDelete(rateId: number, options?: any) {
            return TaxTaxRateRepositoryV1ApiFp(configuration).taxTaxRateRepositoryV1DeleteByIdDelete(rateId, options)(fetch, basePath);
        },
        /**
         * Get tax rate
         * @param {number} rateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1GetGet(rateId: number, options?: any) {
            return TaxTaxRateRepositoryV1ApiFp(configuration).taxTaxRateRepositoryV1GetGet(rateId, options)(fetch, basePath);
        },
        /**
         * Search TaxRates This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRateRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return TaxTaxRateRepositoryV1ApiFp(configuration).taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Create or update tax rate
         * @param {TaxTaxRateRepositoryV1SavePostBody} [taxTaxRateRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody?: TaxTaxRateRepositoryV1SavePostBody, options?: any) {
            return TaxTaxRateRepositoryV1ApiFp(configuration).taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Create or update tax rate
         * @param {TaxTaxRateRepositoryV1SavePutBody} [taxTaxRateRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody?: TaxTaxRateRepositoryV1SavePutBody, options?: any) {
            return TaxTaxRateRepositoryV1ApiFp(configuration).taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * TaxTaxRateRepositoryV1Api - object-oriented interface
 * @export
 * @class TaxTaxRateRepositoryV1Api
 * @extends {BaseAPI}
 */
export class TaxTaxRateRepositoryV1Api extends BaseAPI {
    /**
     * Delete tax rate
     * @param {number} rateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRateRepositoryV1Api
     */
    public taxTaxRateRepositoryV1DeleteByIdDelete(rateId: number, options?: any) {
        return TaxTaxRateRepositoryV1ApiFp(this.configuration).taxTaxRateRepositoryV1DeleteByIdDelete(rateId, options)(this.fetch, this.basePath);
    }

    /**
     * Get tax rate
     * @param {number} rateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRateRepositoryV1Api
     */
    public taxTaxRateRepositoryV1GetGet(rateId: number, options?: any) {
        return TaxTaxRateRepositoryV1ApiFp(this.configuration).taxTaxRateRepositoryV1GetGet(rateId, options)(this.fetch, this.basePath);
    }

    /**
     * Search TaxRates This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRateRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRateRepositoryV1Api
     */
    public taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return TaxTaxRateRepositoryV1ApiFp(this.configuration).taxTaxRateRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update tax rate
     * @param {TaxTaxRateRepositoryV1SavePostBody} [taxTaxRateRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRateRepositoryV1Api
     */
    public taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody?: TaxTaxRateRepositoryV1SavePostBody, options?: any) {
        return TaxTaxRateRepositoryV1ApiFp(this.configuration).taxTaxRateRepositoryV1SavePost(taxTaxRateRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update tax rate
     * @param {TaxTaxRateRepositoryV1SavePutBody} [taxTaxRateRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRateRepositoryV1Api
     */
    public taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody?: TaxTaxRateRepositoryV1SavePutBody, options?: any) {
        return TaxTaxRateRepositoryV1ApiFp(this.configuration).taxTaxRateRepositoryV1SavePut(taxTaxRateRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * TaxTaxRuleRepositoryV1Api - fetch parameter creator
 * @export
 */
export const TaxTaxRuleRepositoryV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete TaxRule
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling taxTaxRuleRepositoryV1DeleteByIdDelete.');
            }
            const localVarPath = `/V1/taxRules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get TaxRule
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1GetGet(ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling taxTaxRuleRepositoryV1GetGet.');
            }
            const localVarPath = `/V1/taxRules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search TaxRules This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxRules/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCriteriaFilterGroupsFiltersField !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][field]'] = searchCriteriaFilterGroupsFiltersField;
            }

            if (searchCriteriaFilterGroupsFiltersValue !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][value]'] = searchCriteriaFilterGroupsFiltersValue;
            }

            if (searchCriteriaFilterGroupsFiltersConditionType !== undefined) {
                localVarQueryParameter['searchCriteria[filterGroups][][filters][][conditionType]'] = searchCriteriaFilterGroupsFiltersConditionType;
            }

            if (searchCriteriaSortOrdersField !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][field]'] = searchCriteriaSortOrdersField;
            }

            if (searchCriteriaSortOrdersDirection !== undefined) {
                localVarQueryParameter['searchCriteria[sortOrders][][direction]'] = searchCriteriaSortOrdersDirection;
            }

            if (searchCriteriaPageSize !== undefined) {
                localVarQueryParameter['searchCriteria[pageSize]'] = searchCriteriaPageSize;
            }

            if (searchCriteriaCurrentPage !== undefined) {
                localVarQueryParameter['searchCriteria[currentPage]'] = searchCriteriaCurrentPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save TaxRule
         * @param {TaxTaxRuleRepositoryV1SavePostBody} [taxTaxRuleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody?: TaxTaxRuleRepositoryV1SavePostBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxRules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxTaxRuleRepositoryV1SavePostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxTaxRuleRepositoryV1SavePostBody || {}) : (taxTaxRuleRepositoryV1SavePostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save TaxRule
         * @param {TaxTaxRuleRepositoryV1SavePutBody} [taxTaxRuleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody?: TaxTaxRuleRepositoryV1SavePutBody, options: any = {}): FetchArgs {
            const localVarPath = `/V1/taxRules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxTaxRuleRepositoryV1SavePutBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxTaxRuleRepositoryV1SavePutBody || {}) : (taxTaxRuleRepositoryV1SavePutBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxTaxRuleRepositoryV1Api - functional programming interface
 * @export
 */
export const TaxTaxRuleRepositoryV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete TaxRule
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = TaxTaxRuleRepositoryV1ApiFetchParamCreator(configuration).taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get TaxRule
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1GetGet(ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRuleInterface> {
            const localVarFetchArgs = TaxTaxRuleRepositoryV1ApiFetchParamCreator(configuration).taxTaxRuleRepositoryV1GetGet(ruleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search TaxRules This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRuleSearchResultsInterface> {
            const localVarFetchArgs = TaxTaxRuleRepositoryV1ApiFetchParamCreator(configuration).taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save TaxRule
         * @param {TaxTaxRuleRepositoryV1SavePostBody} [taxTaxRuleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody?: TaxTaxRuleRepositoryV1SavePostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRuleInterface> {
            const localVarFetchArgs = TaxTaxRuleRepositoryV1ApiFetchParamCreator(configuration).taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save TaxRule
         * @param {TaxTaxRuleRepositoryV1SavePutBody} [taxTaxRuleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody?: TaxTaxRuleRepositoryV1SavePutBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxDataTaxRuleInterface> {
            const localVarFetchArgs = TaxTaxRuleRepositoryV1ApiFetchParamCreator(configuration).taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaxTaxRuleRepositoryV1Api - factory interface
 * @export
 */
export const TaxTaxRuleRepositoryV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete TaxRule
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId: number, options?: any) {
            return TaxTaxRuleRepositoryV1ApiFp(configuration).taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId, options)(fetch, basePath);
        },
        /**
         * Get TaxRule
         * @param {number} ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1GetGet(ruleId: number, options?: any) {
            return TaxTaxRuleRepositoryV1ApiFp(configuration).taxTaxRuleRepositoryV1GetGet(ruleId, options)(fetch, basePath);
        },
        /**
         * Search TaxRules This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
         * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
         * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
         * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
         * @param {string} [searchCriteriaSortOrdersField] Sorting field.
         * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
         * @param {number} [searchCriteriaPageSize] Page size.
         * @param {number} [searchCriteriaCurrentPage] Current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
            return TaxTaxRuleRepositoryV1ApiFp(configuration).taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(fetch, basePath);
        },
        /**
         * Save TaxRule
         * @param {TaxTaxRuleRepositoryV1SavePostBody} [taxTaxRuleRepositoryV1SavePostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody?: TaxTaxRuleRepositoryV1SavePostBody, options?: any) {
            return TaxTaxRuleRepositoryV1ApiFp(configuration).taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody, options)(fetch, basePath);
        },
        /**
         * Save TaxRule
         * @param {TaxTaxRuleRepositoryV1SavePutBody} [taxTaxRuleRepositoryV1SavePutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody?: TaxTaxRuleRepositoryV1SavePutBody, options?: any) {
            return TaxTaxRuleRepositoryV1ApiFp(configuration).taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody, options)(fetch, basePath);
        },
    };
};

/**
 * TaxTaxRuleRepositoryV1Api - object-oriented interface
 * @export
 * @class TaxTaxRuleRepositoryV1Api
 * @extends {BaseAPI}
 */
export class TaxTaxRuleRepositoryV1Api extends BaseAPI {
    /**
     * Delete TaxRule
     * @param {number} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRuleRepositoryV1Api
     */
    public taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId: number, options?: any) {
        return TaxTaxRuleRepositoryV1ApiFp(this.configuration).taxTaxRuleRepositoryV1DeleteByIdDelete(ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * Get TaxRule
     * @param {number} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRuleRepositoryV1Api
     */
    public taxTaxRuleRepositoryV1GetGet(ruleId: number, options?: any) {
        return TaxTaxRuleRepositoryV1ApiFp(this.configuration).taxTaxRuleRepositoryV1GetGet(ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * Search TaxRules This call returns an array of objects, but detailed information about each objects attributes might not be included. See http://devdocs.magento.com/codelinks/attributes.html#TaxRuleRepositoryInterface to determine which call to use to get detailed information about all attributes for an object.
     * @param {string} [searchCriteriaFilterGroupsFiltersField] Field
     * @param {string} [searchCriteriaFilterGroupsFiltersValue] Value
     * @param {string} [searchCriteriaFilterGroupsFiltersConditionType] Condition type
     * @param {string} [searchCriteriaSortOrdersField] Sorting field.
     * @param {string} [searchCriteriaSortOrdersDirection] Sorting direction.
     * @param {number} [searchCriteriaPageSize] Page size.
     * @param {number} [searchCriteriaCurrentPage] Current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRuleRepositoryV1Api
     */
    public taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField?: string, searchCriteriaFilterGroupsFiltersValue?: string, searchCriteriaFilterGroupsFiltersConditionType?: string, searchCriteriaSortOrdersField?: string, searchCriteriaSortOrdersDirection?: string, searchCriteriaPageSize?: number, searchCriteriaCurrentPage?: number, options?: any) {
        return TaxTaxRuleRepositoryV1ApiFp(this.configuration).taxTaxRuleRepositoryV1GetListGet(searchCriteriaFilterGroupsFiltersField, searchCriteriaFilterGroupsFiltersValue, searchCriteriaFilterGroupsFiltersConditionType, searchCriteriaSortOrdersField, searchCriteriaSortOrdersDirection, searchCriteriaPageSize, searchCriteriaCurrentPage, options)(this.fetch, this.basePath);
    }

    /**
     * Save TaxRule
     * @param {TaxTaxRuleRepositoryV1SavePostBody} [taxTaxRuleRepositoryV1SavePostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRuleRepositoryV1Api
     */
    public taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody?: TaxTaxRuleRepositoryV1SavePostBody, options?: any) {
        return TaxTaxRuleRepositoryV1ApiFp(this.configuration).taxTaxRuleRepositoryV1SavePost(taxTaxRuleRepositoryV1SavePostBody, options)(this.fetch, this.basePath);
    }

    /**
     * Save TaxRule
     * @param {TaxTaxRuleRepositoryV1SavePutBody} [taxTaxRuleRepositoryV1SavePutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxTaxRuleRepositoryV1Api
     */
    public taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody?: TaxTaxRuleRepositoryV1SavePutBody, options?: any) {
        return TaxTaxRuleRepositoryV1ApiFp(this.configuration).taxTaxRuleRepositoryV1SavePut(taxTaxRuleRepositoryV1SavePutBody, options)(this.fetch, this.basePath);
    }

}

/**
 * WorldpayGuestPaymentInformationManagementProxyV1Api - fetch parameter creator
 * @export
 */
export const WorldpayGuestPaymentInformationManagementProxyV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Proxy handler for guest place order
         * @param {string} cartId
         * @param {WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody} [worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId: string, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody?: WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost.');
            }
            const localVarPath = `/V1/worldpay-guest-carts/{cartId}/payment-information`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody || {}) : (worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorldpayGuestPaymentInformationManagementProxyV1Api - functional programming interface
 * @export
 */
export const WorldpayGuestPaymentInformationManagementProxyV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Proxy handler for guest place order
         * @param {string} cartId
         * @param {WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody} [worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId: string, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody?: WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = WorldpayGuestPaymentInformationManagementProxyV1ApiFetchParamCreator(configuration).worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorldpayGuestPaymentInformationManagementProxyV1Api - factory interface
 * @export
 */
export const WorldpayGuestPaymentInformationManagementProxyV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Proxy handler for guest place order
         * @param {string} cartId
         * @param {WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody} [worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId: string, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody?: WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
            return WorldpayGuestPaymentInformationManagementProxyV1ApiFp(configuration).worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options)(fetch, basePath);
        },
    };
};

/**
 * WorldpayGuestPaymentInformationManagementProxyV1Api - object-oriented interface
 * @export
 * @class WorldpayGuestPaymentInformationManagementProxyV1Api
 * @extends {BaseAPI}
 */
export class WorldpayGuestPaymentInformationManagementProxyV1Api extends BaseAPI {
    /**
     * Proxy handler for guest place order
     * @param {string} cartId
     * @param {WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody} [worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldpayGuestPaymentInformationManagementProxyV1Api
     */
    public worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId: string, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody?: WorldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options?: any) {
        return WorldpayGuestPaymentInformationManagementProxyV1ApiFp(this.configuration).worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPost(cartId, worldpayGuestPaymentInformationManagementProxyV1SavePaymentInformationAndPlaceOrderPostBody, options)(this.fetch, this.basePath);
    }

}

